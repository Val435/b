
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model OtpCode
 * 
 */
export type OtpCode = $Result.DefaultSelection<Prisma.$OtpCodePayload>
/**
 * Model Journey
 * 
 */
export type Journey = $Result.DefaultSelection<Prisma.$JourneyPayload>
/**
 * Model Recommendation
 * 
 */
export type Recommendation = $Result.DefaultSelection<Prisma.$RecommendationPayload>
/**
 * Model RecommendedArea
 * 
 */
export type RecommendedArea = $Result.DefaultSelection<Prisma.$RecommendedAreaPayload>
/**
 * Model RaceEthnicity
 * 
 */
export type RaceEthnicity = $Result.DefaultSelection<Prisma.$RaceEthnicityPayload>
/**
 * Model IncomeLevels
 * 
 */
export type IncomeLevels = $Result.DefaultSelection<Prisma.$IncomeLevelsPayload>
/**
 * Model CrimeData
 * 
 */
export type CrimeData = $Result.DefaultSelection<Prisma.$CrimeDataPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model SocialLife
 * 
 */
export type SocialLife = $Result.DefaultSelection<Prisma.$SocialLifePayload>
/**
 * Model Shopping
 * 
 */
export type Shopping = $Result.DefaultSelection<Prisma.$ShoppingPayload>
/**
 * Model GreenSpace
 * 
 */
export type GreenSpace = $Result.DefaultSelection<Prisma.$GreenSpacePayload>
/**
 * Model Sport
 * 
 */
export type Sport = $Result.DefaultSelection<Prisma.$SportPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model PropertySuggestion
 * 
 */
export type PropertySuggestion = $Result.DefaultSelection<Prisma.$PropertySuggestionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const JourneyStatus: {
  DRAFT: 'DRAFT',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type JourneyStatus = (typeof JourneyStatus)[keyof typeof JourneyStatus]

}

export type JourneyStatus = $Enums.JourneyStatus

export const JourneyStatus: typeof $Enums.JourneyStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otpCode`: Exposes CRUD operations for the **OtpCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtpCodes
    * const otpCodes = await prisma.otpCode.findMany()
    * ```
    */
  get otpCode(): Prisma.OtpCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journey`: Exposes CRUD operations for the **Journey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journeys
    * const journeys = await prisma.journey.findMany()
    * ```
    */
  get journey(): Prisma.JourneyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recommendation`: Exposes CRUD operations for the **Recommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recommendations
    * const recommendations = await prisma.recommendation.findMany()
    * ```
    */
  get recommendation(): Prisma.RecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recommendedArea`: Exposes CRUD operations for the **RecommendedArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecommendedAreas
    * const recommendedAreas = await prisma.recommendedArea.findMany()
    * ```
    */
  get recommendedArea(): Prisma.RecommendedAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raceEthnicity`: Exposes CRUD operations for the **RaceEthnicity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaceEthnicities
    * const raceEthnicities = await prisma.raceEthnicity.findMany()
    * ```
    */
  get raceEthnicity(): Prisma.RaceEthnicityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incomeLevels`: Exposes CRUD operations for the **IncomeLevels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomeLevels
    * const incomeLevels = await prisma.incomeLevels.findMany()
    * ```
    */
  get incomeLevels(): Prisma.IncomeLevelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crimeData`: Exposes CRUD operations for the **CrimeData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrimeData
    * const crimeData = await prisma.crimeData.findMany()
    * ```
    */
  get crimeData(): Prisma.CrimeDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialLife`: Exposes CRUD operations for the **SocialLife** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLives
    * const socialLives = await prisma.socialLife.findMany()
    * ```
    */
  get socialLife(): Prisma.SocialLifeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopping`: Exposes CRUD operations for the **Shopping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shoppings
    * const shoppings = await prisma.shopping.findMany()
    * ```
    */
  get shopping(): Prisma.ShoppingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.greenSpace`: Exposes CRUD operations for the **GreenSpace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GreenSpaces
    * const greenSpaces = await prisma.greenSpace.findMany()
    * ```
    */
  get greenSpace(): Prisma.GreenSpaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sport`: Exposes CRUD operations for the **Sport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sports
    * const sports = await prisma.sport.findMany()
    * ```
    */
  get sport(): Prisma.SportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertySuggestion`: Exposes CRUD operations for the **PropertySuggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertySuggestions
    * const propertySuggestions = await prisma.propertySuggestion.findMany()
    * ```
    */
  get propertySuggestion(): Prisma.PropertySuggestionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    OtpCode: 'OtpCode',
    Journey: 'Journey',
    Recommendation: 'Recommendation',
    RecommendedArea: 'RecommendedArea',
    RaceEthnicity: 'RaceEthnicity',
    IncomeLevels: 'IncomeLevels',
    CrimeData: 'CrimeData',
    School: 'School',
    SocialLife: 'SocialLife',
    Shopping: 'Shopping',
    GreenSpace: 'GreenSpace',
    Sport: 'Sport',
    Property: 'Property',
    PropertySuggestion: 'PropertySuggestion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "otpCode" | "journey" | "recommendation" | "recommendedArea" | "raceEthnicity" | "incomeLevels" | "crimeData" | "school" | "socialLife" | "shopping" | "greenSpace" | "sport" | "property" | "propertySuggestion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      OtpCode: {
        payload: Prisma.$OtpCodePayload<ExtArgs>
        fields: Prisma.OtpCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>
          }
          findFirst: {
            args: Prisma.OtpCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>
          }
          findMany: {
            args: Prisma.OtpCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>[]
          }
          create: {
            args: Prisma.OtpCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>
          }
          createMany: {
            args: Prisma.OtpCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>[]
          }
          delete: {
            args: Prisma.OtpCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>
          }
          update: {
            args: Prisma.OtpCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>
          }
          deleteMany: {
            args: Prisma.OtpCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>[]
          }
          upsert: {
            args: Prisma.OtpCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpCodePayload>
          }
          aggregate: {
            args: Prisma.OtpCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtpCode>
          }
          groupBy: {
            args: Prisma.OtpCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCodeCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCodeCountAggregateOutputType> | number
          }
        }
      }
      Journey: {
        payload: Prisma.$JourneyPayload<ExtArgs>
        fields: Prisma.JourneyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JourneyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JourneyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>
          }
          findFirst: {
            args: Prisma.JourneyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JourneyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>
          }
          findMany: {
            args: Prisma.JourneyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>[]
          }
          create: {
            args: Prisma.JourneyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>
          }
          createMany: {
            args: Prisma.JourneyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JourneyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>[]
          }
          delete: {
            args: Prisma.JourneyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>
          }
          update: {
            args: Prisma.JourneyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>
          }
          deleteMany: {
            args: Prisma.JourneyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JourneyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JourneyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>[]
          }
          upsert: {
            args: Prisma.JourneyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPayload>
          }
          aggregate: {
            args: Prisma.JourneyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJourney>
          }
          groupBy: {
            args: Prisma.JourneyGroupByArgs<ExtArgs>
            result: $Utils.Optional<JourneyGroupByOutputType>[]
          }
          count: {
            args: Prisma.JourneyCountArgs<ExtArgs>
            result: $Utils.Optional<JourneyCountAggregateOutputType> | number
          }
        }
      }
      Recommendation: {
        payload: Prisma.$RecommendationPayload<ExtArgs>
        fields: Prisma.RecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          findFirst: {
            args: Prisma.RecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          findMany: {
            args: Prisma.RecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
          }
          create: {
            args: Prisma.RecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          createMany: {
            args: Prisma.RecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
          }
          delete: {
            args: Prisma.RecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          update: {
            args: Prisma.RecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          deleteMany: {
            args: Prisma.RecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
          }
          upsert: {
            args: Prisma.RecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          aggregate: {
            args: Prisma.RecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecommendation>
          }
          groupBy: {
            args: Prisma.RecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<RecommendationCountAggregateOutputType> | number
          }
        }
      }
      RecommendedArea: {
        payload: Prisma.$RecommendedAreaPayload<ExtArgs>
        fields: Prisma.RecommendedAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecommendedAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecommendedAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>
          }
          findFirst: {
            args: Prisma.RecommendedAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecommendedAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>
          }
          findMany: {
            args: Prisma.RecommendedAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>[]
          }
          create: {
            args: Prisma.RecommendedAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>
          }
          createMany: {
            args: Prisma.RecommendedAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecommendedAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>[]
          }
          delete: {
            args: Prisma.RecommendedAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>
          }
          update: {
            args: Prisma.RecommendedAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>
          }
          deleteMany: {
            args: Prisma.RecommendedAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecommendedAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecommendedAreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>[]
          }
          upsert: {
            args: Prisma.RecommendedAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendedAreaPayload>
          }
          aggregate: {
            args: Prisma.RecommendedAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecommendedArea>
          }
          groupBy: {
            args: Prisma.RecommendedAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecommendedAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecommendedAreaCountArgs<ExtArgs>
            result: $Utils.Optional<RecommendedAreaCountAggregateOutputType> | number
          }
        }
      }
      RaceEthnicity: {
        payload: Prisma.$RaceEthnicityPayload<ExtArgs>
        fields: Prisma.RaceEthnicityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceEthnicityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceEthnicityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>
          }
          findFirst: {
            args: Prisma.RaceEthnicityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceEthnicityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>
          }
          findMany: {
            args: Prisma.RaceEthnicityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>[]
          }
          create: {
            args: Prisma.RaceEthnicityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>
          }
          createMany: {
            args: Prisma.RaceEthnicityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceEthnicityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>[]
          }
          delete: {
            args: Prisma.RaceEthnicityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>
          }
          update: {
            args: Prisma.RaceEthnicityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>
          }
          deleteMany: {
            args: Prisma.RaceEthnicityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceEthnicityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaceEthnicityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>[]
          }
          upsert: {
            args: Prisma.RaceEthnicityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaceEthnicityPayload>
          }
          aggregate: {
            args: Prisma.RaceEthnicityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaceEthnicity>
          }
          groupBy: {
            args: Prisma.RaceEthnicityGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceEthnicityGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceEthnicityCountArgs<ExtArgs>
            result: $Utils.Optional<RaceEthnicityCountAggregateOutputType> | number
          }
        }
      }
      IncomeLevels: {
        payload: Prisma.$IncomeLevelsPayload<ExtArgs>
        fields: Prisma.IncomeLevelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomeLevelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomeLevelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>
          }
          findFirst: {
            args: Prisma.IncomeLevelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomeLevelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>
          }
          findMany: {
            args: Prisma.IncomeLevelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>[]
          }
          create: {
            args: Prisma.IncomeLevelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>
          }
          createMany: {
            args: Prisma.IncomeLevelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncomeLevelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>[]
          }
          delete: {
            args: Prisma.IncomeLevelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>
          }
          update: {
            args: Prisma.IncomeLevelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>
          }
          deleteMany: {
            args: Prisma.IncomeLevelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomeLevelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncomeLevelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>[]
          }
          upsert: {
            args: Prisma.IncomeLevelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeLevelsPayload>
          }
          aggregate: {
            args: Prisma.IncomeLevelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncomeLevels>
          }
          groupBy: {
            args: Prisma.IncomeLevelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomeLevelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncomeLevelsCountArgs<ExtArgs>
            result: $Utils.Optional<IncomeLevelsCountAggregateOutputType> | number
          }
        }
      }
      CrimeData: {
        payload: Prisma.$CrimeDataPayload<ExtArgs>
        fields: Prisma.CrimeDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrimeDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrimeDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>
          }
          findFirst: {
            args: Prisma.CrimeDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrimeDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>
          }
          findMany: {
            args: Prisma.CrimeDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>[]
          }
          create: {
            args: Prisma.CrimeDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>
          }
          createMany: {
            args: Prisma.CrimeDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrimeDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>[]
          }
          delete: {
            args: Prisma.CrimeDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>
          }
          update: {
            args: Prisma.CrimeDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>
          }
          deleteMany: {
            args: Prisma.CrimeDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrimeDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrimeDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>[]
          }
          upsert: {
            args: Prisma.CrimeDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrimeDataPayload>
          }
          aggregate: {
            args: Prisma.CrimeDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrimeData>
          }
          groupBy: {
            args: Prisma.CrimeDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrimeDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrimeDataCountArgs<ExtArgs>
            result: $Utils.Optional<CrimeDataCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      SocialLife: {
        payload: Prisma.$SocialLifePayload<ExtArgs>
        fields: Prisma.SocialLifeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialLifeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialLifeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>
          }
          findFirst: {
            args: Prisma.SocialLifeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialLifeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>
          }
          findMany: {
            args: Prisma.SocialLifeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>[]
          }
          create: {
            args: Prisma.SocialLifeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>
          }
          createMany: {
            args: Prisma.SocialLifeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialLifeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>[]
          }
          delete: {
            args: Prisma.SocialLifeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>
          }
          update: {
            args: Prisma.SocialLifeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>
          }
          deleteMany: {
            args: Prisma.SocialLifeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialLifeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialLifeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>[]
          }
          upsert: {
            args: Prisma.SocialLifeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLifePayload>
          }
          aggregate: {
            args: Prisma.SocialLifeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialLife>
          }
          groupBy: {
            args: Prisma.SocialLifeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialLifeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialLifeCountArgs<ExtArgs>
            result: $Utils.Optional<SocialLifeCountAggregateOutputType> | number
          }
        }
      }
      Shopping: {
        payload: Prisma.$ShoppingPayload<ExtArgs>
        fields: Prisma.ShoppingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShoppingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShoppingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>
          }
          findFirst: {
            args: Prisma.ShoppingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShoppingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>
          }
          findMany: {
            args: Prisma.ShoppingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>[]
          }
          create: {
            args: Prisma.ShoppingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>
          }
          createMany: {
            args: Prisma.ShoppingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShoppingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>[]
          }
          delete: {
            args: Prisma.ShoppingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>
          }
          update: {
            args: Prisma.ShoppingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>
          }
          deleteMany: {
            args: Prisma.ShoppingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShoppingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShoppingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>[]
          }
          upsert: {
            args: Prisma.ShoppingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingPayload>
          }
          aggregate: {
            args: Prisma.ShoppingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopping>
          }
          groupBy: {
            args: Prisma.ShoppingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShoppingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShoppingCountArgs<ExtArgs>
            result: $Utils.Optional<ShoppingCountAggregateOutputType> | number
          }
        }
      }
      GreenSpace: {
        payload: Prisma.$GreenSpacePayload<ExtArgs>
        fields: Prisma.GreenSpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GreenSpaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GreenSpaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>
          }
          findFirst: {
            args: Prisma.GreenSpaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GreenSpaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>
          }
          findMany: {
            args: Prisma.GreenSpaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>[]
          }
          create: {
            args: Prisma.GreenSpaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>
          }
          createMany: {
            args: Prisma.GreenSpaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GreenSpaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>[]
          }
          delete: {
            args: Prisma.GreenSpaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>
          }
          update: {
            args: Prisma.GreenSpaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>
          }
          deleteMany: {
            args: Prisma.GreenSpaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GreenSpaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GreenSpaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>[]
          }
          upsert: {
            args: Prisma.GreenSpaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GreenSpacePayload>
          }
          aggregate: {
            args: Prisma.GreenSpaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGreenSpace>
          }
          groupBy: {
            args: Prisma.GreenSpaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<GreenSpaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.GreenSpaceCountArgs<ExtArgs>
            result: $Utils.Optional<GreenSpaceCountAggregateOutputType> | number
          }
        }
      }
      Sport: {
        payload: Prisma.$SportPayload<ExtArgs>
        fields: Prisma.SportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          findFirst: {
            args: Prisma.SportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          findMany: {
            args: Prisma.SportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          create: {
            args: Prisma.SportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          createMany: {
            args: Prisma.SportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          delete: {
            args: Prisma.SportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          update: {
            args: Prisma.SportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          deleteMany: {
            args: Prisma.SportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          upsert: {
            args: Prisma.SportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          aggregate: {
            args: Prisma.SportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSport>
          }
          groupBy: {
            args: Prisma.SportGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportCountArgs<ExtArgs>
            result: $Utils.Optional<SportCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      PropertySuggestion: {
        payload: Prisma.$PropertySuggestionPayload<ExtArgs>
        fields: Prisma.PropertySuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertySuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertySuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>
          }
          findFirst: {
            args: Prisma.PropertySuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertySuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>
          }
          findMany: {
            args: Prisma.PropertySuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>[]
          }
          create: {
            args: Prisma.PropertySuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>
          }
          createMany: {
            args: Prisma.PropertySuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertySuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>[]
          }
          delete: {
            args: Prisma.PropertySuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>
          }
          update: {
            args: Prisma.PropertySuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>
          }
          deleteMany: {
            args: Prisma.PropertySuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertySuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertySuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>[]
          }
          upsert: {
            args: Prisma.PropertySuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySuggestionPayload>
          }
          aggregate: {
            args: Prisma.PropertySuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertySuggestion>
          }
          groupBy: {
            args: Prisma.PropertySuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertySuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertySuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<PropertySuggestionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    otpCode?: OtpCodeOmit
    journey?: JourneyOmit
    recommendation?: RecommendationOmit
    recommendedArea?: RecommendedAreaOmit
    raceEthnicity?: RaceEthnicityOmit
    incomeLevels?: IncomeLevelsOmit
    crimeData?: CrimeDataOmit
    school?: SchoolOmit
    socialLife?: SocialLifeOmit
    shopping?: ShoppingOmit
    greenSpace?: GreenSpaceOmit
    sport?: SportOmit
    property?: PropertyOmit
    propertySuggestion?: PropertySuggestionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    otpCodes: number
    Recommendation: number
    journeys: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otpCodes?: boolean | UserCountOutputTypeCountOtpCodesArgs
    Recommendation?: boolean | UserCountOutputTypeCountRecommendationArgs
    journeys?: boolean | UserCountOutputTypeCountJourneysArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJourneysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyWhereInput
  }


  /**
   * Count Type RecommendationCountOutputType
   */

  export type RecommendationCountOutputType = {
    areas: number
  }

  export type RecommendationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | RecommendationCountOutputTypeCountAreasArgs
  }

  // Custom InputTypes
  /**
   * RecommendationCountOutputType without action
   */
  export type RecommendationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendationCountOutputType
     */
    select?: RecommendationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecommendationCountOutputType without action
   */
  export type RecommendationCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendedAreaWhereInput
  }


  /**
   * Count Type RecommendedAreaCountOutputType
   */

  export type RecommendedAreaCountOutputType = {
    schools: number
    socialLife: number
    shopping: number
    greenSpaces: number
    sports: number
    properties: number
  }

  export type RecommendedAreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | RecommendedAreaCountOutputTypeCountSchoolsArgs
    socialLife?: boolean | RecommendedAreaCountOutputTypeCountSocialLifeArgs
    shopping?: boolean | RecommendedAreaCountOutputTypeCountShoppingArgs
    greenSpaces?: boolean | RecommendedAreaCountOutputTypeCountGreenSpacesArgs
    sports?: boolean | RecommendedAreaCountOutputTypeCountSportsArgs
    properties?: boolean | RecommendedAreaCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * RecommendedAreaCountOutputType without action
   */
  export type RecommendedAreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedAreaCountOutputType
     */
    select?: RecommendedAreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecommendedAreaCountOutputType without action
   */
  export type RecommendedAreaCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * RecommendedAreaCountOutputType without action
   */
  export type RecommendedAreaCountOutputTypeCountSocialLifeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLifeWhereInput
  }

  /**
   * RecommendedAreaCountOutputType without action
   */
  export type RecommendedAreaCountOutputTypeCountShoppingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingWhereInput
  }

  /**
   * RecommendedAreaCountOutputType without action
   */
  export type RecommendedAreaCountOutputTypeCountGreenSpacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GreenSpaceWhereInput
  }

  /**
   * RecommendedAreaCountOutputType without action
   */
  export type RecommendedAreaCountOutputTypeCountSportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportWhereInput
  }

  /**
   * RecommendedAreaCountOutputType without action
   */
  export type RecommendedAreaCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    grossAnnual: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    grossAnnual: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    countryCode: string | null
    name: string | null
    state: string | null
    environment: string | null
    occupancy: string | null
    property: string | null
    timeframe: string | null
    priceRange: string | null
    downPayment: string | null
    employmentStatus: string | null
    grossAnnual: number | null
    credit: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    countryCode: string | null
    name: string | null
    state: string | null
    environment: string | null
    occupancy: string | null
    property: string | null
    timeframe: string | null
    priceRange: string | null
    downPayment: string | null
    employmentStatus: string | null
    grossAnnual: number | null
    credit: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    createdAt: number
    countryCode: number
    name: number
    state: number
    city: number
    environment: number
    education1: number
    education2: number
    family: number
    employment1: number
    employment2: number
    socialLife: number
    hobbies: number
    transportation: number
    pets: number
    greenSpace: number
    shopping: number
    restaurants: number
    occupancy: number
    property: number
    timeframe: number
    priceRange: number
    downPayment: number
    employmentStatus: number
    grossAnnual: number
    credit: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    grossAnnual?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    grossAnnual?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    createdAt?: true
    countryCode?: true
    name?: true
    state?: true
    environment?: true
    occupancy?: true
    property?: true
    timeframe?: true
    priceRange?: true
    downPayment?: true
    employmentStatus?: true
    grossAnnual?: true
    credit?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    createdAt?: true
    countryCode?: true
    name?: true
    state?: true
    environment?: true
    occupancy?: true
    property?: true
    timeframe?: true
    priceRange?: true
    downPayment?: true
    employmentStatus?: true
    grossAnnual?: true
    credit?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    createdAt?: true
    countryCode?: true
    name?: true
    state?: true
    city?: true
    environment?: true
    education1?: true
    education2?: true
    family?: true
    employment1?: true
    employment2?: true
    socialLife?: true
    hobbies?: true
    transportation?: true
    pets?: true
    greenSpace?: true
    shopping?: true
    restaurants?: true
    occupancy?: true
    property?: true
    timeframe?: true
    priceRange?: true
    downPayment?: true
    employmentStatus?: true
    grossAnnual?: true
    credit?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    phone: string
    createdAt: Date
    countryCode: string
    name: string | null
    state: string | null
    city: string[]
    environment: string | null
    education1: string[]
    education2: string[]
    family: string[]
    employment1: string[]
    employment2: string[]
    socialLife: string[]
    hobbies: string[]
    transportation: string[]
    pets: string[]
    greenSpace: string[]
    shopping: string[]
    restaurants: string[]
    occupancy: string | null
    property: string | null
    timeframe: string | null
    priceRange: string | null
    downPayment: string | null
    employmentStatus: string | null
    grossAnnual: number | null
    credit: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    countryCode?: boolean
    name?: boolean
    state?: boolean
    city?: boolean
    environment?: boolean
    education1?: boolean
    education2?: boolean
    family?: boolean
    employment1?: boolean
    employment2?: boolean
    socialLife?: boolean
    hobbies?: boolean
    transportation?: boolean
    pets?: boolean
    greenSpace?: boolean
    shopping?: boolean
    restaurants?: boolean
    occupancy?: boolean
    property?: boolean
    timeframe?: boolean
    priceRange?: boolean
    downPayment?: boolean
    employmentStatus?: boolean
    grossAnnual?: boolean
    credit?: boolean
    otpCodes?: boolean | User$otpCodesArgs<ExtArgs>
    Recommendation?: boolean | User$RecommendationArgs<ExtArgs>
    journeys?: boolean | User$journeysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    countryCode?: boolean
    name?: boolean
    state?: boolean
    city?: boolean
    environment?: boolean
    education1?: boolean
    education2?: boolean
    family?: boolean
    employment1?: boolean
    employment2?: boolean
    socialLife?: boolean
    hobbies?: boolean
    transportation?: boolean
    pets?: boolean
    greenSpace?: boolean
    shopping?: boolean
    restaurants?: boolean
    occupancy?: boolean
    property?: boolean
    timeframe?: boolean
    priceRange?: boolean
    downPayment?: boolean
    employmentStatus?: boolean
    grossAnnual?: boolean
    credit?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    countryCode?: boolean
    name?: boolean
    state?: boolean
    city?: boolean
    environment?: boolean
    education1?: boolean
    education2?: boolean
    family?: boolean
    employment1?: boolean
    employment2?: boolean
    socialLife?: boolean
    hobbies?: boolean
    transportation?: boolean
    pets?: boolean
    greenSpace?: boolean
    shopping?: boolean
    restaurants?: boolean
    occupancy?: boolean
    property?: boolean
    timeframe?: boolean
    priceRange?: boolean
    downPayment?: boolean
    employmentStatus?: boolean
    grossAnnual?: boolean
    credit?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    countryCode?: boolean
    name?: boolean
    state?: boolean
    city?: boolean
    environment?: boolean
    education1?: boolean
    education2?: boolean
    family?: boolean
    employment1?: boolean
    employment2?: boolean
    socialLife?: boolean
    hobbies?: boolean
    transportation?: boolean
    pets?: boolean
    greenSpace?: boolean
    shopping?: boolean
    restaurants?: boolean
    occupancy?: boolean
    property?: boolean
    timeframe?: boolean
    priceRange?: boolean
    downPayment?: boolean
    employmentStatus?: boolean
    grossAnnual?: boolean
    credit?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone" | "createdAt" | "countryCode" | "name" | "state" | "city" | "environment" | "education1" | "education2" | "family" | "employment1" | "employment2" | "socialLife" | "hobbies" | "transportation" | "pets" | "greenSpace" | "shopping" | "restaurants" | "occupancy" | "property" | "timeframe" | "priceRange" | "downPayment" | "employmentStatus" | "grossAnnual" | "credit", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otpCodes?: boolean | User$otpCodesArgs<ExtArgs>
    Recommendation?: boolean | User$RecommendationArgs<ExtArgs>
    journeys?: boolean | User$journeysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      otpCodes: Prisma.$OtpCodePayload<ExtArgs>[]
      Recommendation: Prisma.$RecommendationPayload<ExtArgs>[]
      journeys: Prisma.$JourneyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      phone: string
      createdAt: Date
      countryCode: string
      name: string | null
      state: string | null
      city: string[]
      environment: string | null
      education1: string[]
      education2: string[]
      family: string[]
      employment1: string[]
      employment2: string[]
      socialLife: string[]
      hobbies: string[]
      transportation: string[]
      pets: string[]
      greenSpace: string[]
      shopping: string[]
      restaurants: string[]
      occupancy: string | null
      property: string | null
      timeframe: string | null
      priceRange: string | null
      downPayment: string | null
      employmentStatus: string | null
      grossAnnual: number | null
      credit: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    otpCodes<T extends User$otpCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$otpCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Recommendation<T extends User$RecommendationArgs<ExtArgs> = {}>(args?: Subset<T, User$RecommendationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journeys<T extends User$journeysArgs<ExtArgs> = {}>(args?: Subset<T, User$journeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly countryCode: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String[]'>
    readonly environment: FieldRef<"User", 'String'>
    readonly education1: FieldRef<"User", 'String[]'>
    readonly education2: FieldRef<"User", 'String[]'>
    readonly family: FieldRef<"User", 'String[]'>
    readonly employment1: FieldRef<"User", 'String[]'>
    readonly employment2: FieldRef<"User", 'String[]'>
    readonly socialLife: FieldRef<"User", 'String[]'>
    readonly hobbies: FieldRef<"User", 'String[]'>
    readonly transportation: FieldRef<"User", 'String[]'>
    readonly pets: FieldRef<"User", 'String[]'>
    readonly greenSpace: FieldRef<"User", 'String[]'>
    readonly shopping: FieldRef<"User", 'String[]'>
    readonly restaurants: FieldRef<"User", 'String[]'>
    readonly occupancy: FieldRef<"User", 'String'>
    readonly property: FieldRef<"User", 'String'>
    readonly timeframe: FieldRef<"User", 'String'>
    readonly priceRange: FieldRef<"User", 'String'>
    readonly downPayment: FieldRef<"User", 'String'>
    readonly employmentStatus: FieldRef<"User", 'String'>
    readonly grossAnnual: FieldRef<"User", 'Int'>
    readonly credit: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.otpCodes
   */
  export type User$otpCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    where?: OtpCodeWhereInput
    orderBy?: OtpCodeOrderByWithRelationInput | OtpCodeOrderByWithRelationInput[]
    cursor?: OtpCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpCodeScalarFieldEnum | OtpCodeScalarFieldEnum[]
  }

  /**
   * User.Recommendation
   */
  export type User$RecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    where?: RecommendationWhereInput
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    cursor?: RecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * User.journeys
   */
  export type User$journeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    where?: JourneyWhereInput
    orderBy?: JourneyOrderByWithRelationInput | JourneyOrderByWithRelationInput[]
    cursor?: JourneyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JourneyScalarFieldEnum | JourneyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model OtpCode
   */

  export type AggregateOtpCode = {
    _count: OtpCodeCountAggregateOutputType | null
    _avg: OtpCodeAvgAggregateOutputType | null
    _sum: OtpCodeSumAggregateOutputType | null
    _min: OtpCodeMinAggregateOutputType | null
    _max: OtpCodeMaxAggregateOutputType | null
  }

  export type OtpCodeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    attempts: number | null
  }

  export type OtpCodeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    attempts: number | null
  }

  export type OtpCodeMinAggregateOutputType = {
    id: number | null
    code: string | null
    phone: string | null
    email: string | null
    countryCode: string | null
    expiresAt: Date | null
    userId: number | null
    createdAt: Date | null
    attempts: number | null
  }

  export type OtpCodeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    phone: string | null
    email: string | null
    countryCode: string | null
    expiresAt: Date | null
    userId: number | null
    createdAt: Date | null
    attempts: number | null
  }

  export type OtpCodeCountAggregateOutputType = {
    id: number
    code: number
    phone: number
    email: number
    countryCode: number
    expiresAt: number
    userId: number
    createdAt: number
    attempts: number
    _all: number
  }


  export type OtpCodeAvgAggregateInputType = {
    id?: true
    userId?: true
    attempts?: true
  }

  export type OtpCodeSumAggregateInputType = {
    id?: true
    userId?: true
    attempts?: true
  }

  export type OtpCodeMinAggregateInputType = {
    id?: true
    code?: true
    phone?: true
    email?: true
    countryCode?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    attempts?: true
  }

  export type OtpCodeMaxAggregateInputType = {
    id?: true
    code?: true
    phone?: true
    email?: true
    countryCode?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    attempts?: true
  }

  export type OtpCodeCountAggregateInputType = {
    id?: true
    code?: true
    phone?: true
    email?: true
    countryCode?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    attempts?: true
    _all?: true
  }

  export type OtpCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpCode to aggregate.
     */
    where?: OtpCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpCodes to fetch.
     */
    orderBy?: OtpCodeOrderByWithRelationInput | OtpCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtpCodes
    **/
    _count?: true | OtpCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpCodeMaxAggregateInputType
  }

  export type GetOtpCodeAggregateType<T extends OtpCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateOtpCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtpCode[P]>
      : GetScalarType<T[P], AggregateOtpCode[P]>
  }




  export type OtpCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpCodeWhereInput
    orderBy?: OtpCodeOrderByWithAggregationInput | OtpCodeOrderByWithAggregationInput[]
    by: OtpCodeScalarFieldEnum[] | OtpCodeScalarFieldEnum
    having?: OtpCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCodeCountAggregateInputType | true
    _avg?: OtpCodeAvgAggregateInputType
    _sum?: OtpCodeSumAggregateInputType
    _min?: OtpCodeMinAggregateInputType
    _max?: OtpCodeMaxAggregateInputType
  }

  export type OtpCodeGroupByOutputType = {
    id: number
    code: string
    phone: string
    email: string
    countryCode: string
    expiresAt: Date
    userId: number | null
    createdAt: Date
    attempts: number
    _count: OtpCodeCountAggregateOutputType | null
    _avg: OtpCodeAvgAggregateOutputType | null
    _sum: OtpCodeSumAggregateOutputType | null
    _min: OtpCodeMinAggregateOutputType | null
    _max: OtpCodeMaxAggregateOutputType | null
  }

  type GetOtpCodeGroupByPayload<T extends OtpCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpCodeGroupByOutputType[P]>
            : GetScalarType<T[P], OtpCodeGroupByOutputType[P]>
        }
      >
    >


  export type OtpCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    phone?: boolean
    email?: boolean
    countryCode?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    attempts?: boolean
    user?: boolean | OtpCode$userArgs<ExtArgs>
  }, ExtArgs["result"]["otpCode"]>

  export type OtpCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    phone?: boolean
    email?: boolean
    countryCode?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    attempts?: boolean
    user?: boolean | OtpCode$userArgs<ExtArgs>
  }, ExtArgs["result"]["otpCode"]>

  export type OtpCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    phone?: boolean
    email?: boolean
    countryCode?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    attempts?: boolean
    user?: boolean | OtpCode$userArgs<ExtArgs>
  }, ExtArgs["result"]["otpCode"]>

  export type OtpCodeSelectScalar = {
    id?: boolean
    code?: boolean
    phone?: boolean
    email?: boolean
    countryCode?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    attempts?: boolean
  }

  export type OtpCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "phone" | "email" | "countryCode" | "expiresAt" | "userId" | "createdAt" | "attempts", ExtArgs["result"]["otpCode"]>
  export type OtpCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | OtpCode$userArgs<ExtArgs>
  }
  export type OtpCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | OtpCode$userArgs<ExtArgs>
  }
  export type OtpCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | OtpCode$userArgs<ExtArgs>
  }

  export type $OtpCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtpCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      phone: string
      email: string
      countryCode: string
      expiresAt: Date
      userId: number | null
      createdAt: Date
      attempts: number
    }, ExtArgs["result"]["otpCode"]>
    composites: {}
  }

  type OtpCodeGetPayload<S extends boolean | null | undefined | OtpCodeDefaultArgs> = $Result.GetResult<Prisma.$OtpCodePayload, S>

  type OtpCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCodeCountAggregateInputType | true
    }

  export interface OtpCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtpCode'], meta: { name: 'OtpCode' } }
    /**
     * Find zero or one OtpCode that matches the filter.
     * @param {OtpCodeFindUniqueArgs} args - Arguments to find a OtpCode
     * @example
     * // Get one OtpCode
     * const otpCode = await prisma.otpCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpCodeFindUniqueArgs>(args: SelectSubset<T, OtpCodeFindUniqueArgs<ExtArgs>>): Prisma__OtpCodeClient<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OtpCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpCodeFindUniqueOrThrowArgs} args - Arguments to find a OtpCode
     * @example
     * // Get one OtpCode
     * const otpCode = await prisma.otpCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpCodeClient<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OtpCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCodeFindFirstArgs} args - Arguments to find a OtpCode
     * @example
     * // Get one OtpCode
     * const otpCode = await prisma.otpCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpCodeFindFirstArgs>(args?: SelectSubset<T, OtpCodeFindFirstArgs<ExtArgs>>): Prisma__OtpCodeClient<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OtpCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCodeFindFirstOrThrowArgs} args - Arguments to find a OtpCode
     * @example
     * // Get one OtpCode
     * const otpCode = await prisma.otpCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpCodeClient<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OtpCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtpCodes
     * const otpCodes = await prisma.otpCode.findMany()
     * 
     * // Get first 10 OtpCodes
     * const otpCodes = await prisma.otpCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpCodeWithIdOnly = await prisma.otpCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpCodeFindManyArgs>(args?: SelectSubset<T, OtpCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OtpCode.
     * @param {OtpCodeCreateArgs} args - Arguments to create a OtpCode.
     * @example
     * // Create one OtpCode
     * const OtpCode = await prisma.otpCode.create({
     *   data: {
     *     // ... data to create a OtpCode
     *   }
     * })
     * 
     */
    create<T extends OtpCodeCreateArgs>(args: SelectSubset<T, OtpCodeCreateArgs<ExtArgs>>): Prisma__OtpCodeClient<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OtpCodes.
     * @param {OtpCodeCreateManyArgs} args - Arguments to create many OtpCodes.
     * @example
     * // Create many OtpCodes
     * const otpCode = await prisma.otpCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCodeCreateManyArgs>(args?: SelectSubset<T, OtpCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OtpCodes and returns the data saved in the database.
     * @param {OtpCodeCreateManyAndReturnArgs} args - Arguments to create many OtpCodes.
     * @example
     * // Create many OtpCodes
     * const otpCode = await prisma.otpCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OtpCodes and only return the `id`
     * const otpCodeWithIdOnly = await prisma.otpCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OtpCode.
     * @param {OtpCodeDeleteArgs} args - Arguments to delete one OtpCode.
     * @example
     * // Delete one OtpCode
     * const OtpCode = await prisma.otpCode.delete({
     *   where: {
     *     // ... filter to delete one OtpCode
     *   }
     * })
     * 
     */
    delete<T extends OtpCodeDeleteArgs>(args: SelectSubset<T, OtpCodeDeleteArgs<ExtArgs>>): Prisma__OtpCodeClient<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OtpCode.
     * @param {OtpCodeUpdateArgs} args - Arguments to update one OtpCode.
     * @example
     * // Update one OtpCode
     * const otpCode = await prisma.otpCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpCodeUpdateArgs>(args: SelectSubset<T, OtpCodeUpdateArgs<ExtArgs>>): Prisma__OtpCodeClient<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OtpCodes.
     * @param {OtpCodeDeleteManyArgs} args - Arguments to filter OtpCodes to delete.
     * @example
     * // Delete a few OtpCodes
     * const { count } = await prisma.otpCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpCodeDeleteManyArgs>(args?: SelectSubset<T, OtpCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtpCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtpCodes
     * const otpCode = await prisma.otpCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpCodeUpdateManyArgs>(args: SelectSubset<T, OtpCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtpCodes and returns the data updated in the database.
     * @param {OtpCodeUpdateManyAndReturnArgs} args - Arguments to update many OtpCodes.
     * @example
     * // Update many OtpCodes
     * const otpCode = await prisma.otpCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OtpCodes and only return the `id`
     * const otpCodeWithIdOnly = await prisma.otpCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OtpCode.
     * @param {OtpCodeUpsertArgs} args - Arguments to update or create a OtpCode.
     * @example
     * // Update or create a OtpCode
     * const otpCode = await prisma.otpCode.upsert({
     *   create: {
     *     // ... data to create a OtpCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtpCode we want to update
     *   }
     * })
     */
    upsert<T extends OtpCodeUpsertArgs>(args: SelectSubset<T, OtpCodeUpsertArgs<ExtArgs>>): Prisma__OtpCodeClient<$Result.GetResult<Prisma.$OtpCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OtpCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCodeCountArgs} args - Arguments to filter OtpCodes to count.
     * @example
     * // Count the number of OtpCodes
     * const count = await prisma.otpCode.count({
     *   where: {
     *     // ... the filter for the OtpCodes we want to count
     *   }
     * })
    **/
    count<T extends OtpCodeCountArgs>(
      args?: Subset<T, OtpCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtpCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpCodeAggregateArgs>(args: Subset<T, OtpCodeAggregateArgs>): Prisma.PrismaPromise<GetOtpCodeAggregateType<T>>

    /**
     * Group by OtpCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpCodeGroupByArgs['orderBy'] }
        : { orderBy?: OtpCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtpCode model
   */
  readonly fields: OtpCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtpCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends OtpCode$userArgs<ExtArgs> = {}>(args?: Subset<T, OtpCode$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OtpCode model
   */
  interface OtpCodeFieldRefs {
    readonly id: FieldRef<"OtpCode", 'Int'>
    readonly code: FieldRef<"OtpCode", 'String'>
    readonly phone: FieldRef<"OtpCode", 'String'>
    readonly email: FieldRef<"OtpCode", 'String'>
    readonly countryCode: FieldRef<"OtpCode", 'String'>
    readonly expiresAt: FieldRef<"OtpCode", 'DateTime'>
    readonly userId: FieldRef<"OtpCode", 'Int'>
    readonly createdAt: FieldRef<"OtpCode", 'DateTime'>
    readonly attempts: FieldRef<"OtpCode", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OtpCode findUnique
   */
  export type OtpCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * Filter, which OtpCode to fetch.
     */
    where: OtpCodeWhereUniqueInput
  }

  /**
   * OtpCode findUniqueOrThrow
   */
  export type OtpCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * Filter, which OtpCode to fetch.
     */
    where: OtpCodeWhereUniqueInput
  }

  /**
   * OtpCode findFirst
   */
  export type OtpCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * Filter, which OtpCode to fetch.
     */
    where?: OtpCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpCodes to fetch.
     */
    orderBy?: OtpCodeOrderByWithRelationInput | OtpCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpCodes.
     */
    cursor?: OtpCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpCodes.
     */
    distinct?: OtpCodeScalarFieldEnum | OtpCodeScalarFieldEnum[]
  }

  /**
   * OtpCode findFirstOrThrow
   */
  export type OtpCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * Filter, which OtpCode to fetch.
     */
    where?: OtpCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpCodes to fetch.
     */
    orderBy?: OtpCodeOrderByWithRelationInput | OtpCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpCodes.
     */
    cursor?: OtpCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpCodes.
     */
    distinct?: OtpCodeScalarFieldEnum | OtpCodeScalarFieldEnum[]
  }

  /**
   * OtpCode findMany
   */
  export type OtpCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * Filter, which OtpCodes to fetch.
     */
    where?: OtpCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpCodes to fetch.
     */
    orderBy?: OtpCodeOrderByWithRelationInput | OtpCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtpCodes.
     */
    cursor?: OtpCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpCodes.
     */
    skip?: number
    distinct?: OtpCodeScalarFieldEnum | OtpCodeScalarFieldEnum[]
  }

  /**
   * OtpCode create
   */
  export type OtpCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a OtpCode.
     */
    data: XOR<OtpCodeCreateInput, OtpCodeUncheckedCreateInput>
  }

  /**
   * OtpCode createMany
   */
  export type OtpCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtpCodes.
     */
    data: OtpCodeCreateManyInput | OtpCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtpCode createManyAndReturn
   */
  export type OtpCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * The data used to create many OtpCodes.
     */
    data: OtpCodeCreateManyInput | OtpCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OtpCode update
   */
  export type OtpCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a OtpCode.
     */
    data: XOR<OtpCodeUpdateInput, OtpCodeUncheckedUpdateInput>
    /**
     * Choose, which OtpCode to update.
     */
    where: OtpCodeWhereUniqueInput
  }

  /**
   * OtpCode updateMany
   */
  export type OtpCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtpCodes.
     */
    data: XOR<OtpCodeUpdateManyMutationInput, OtpCodeUncheckedUpdateManyInput>
    /**
     * Filter which OtpCodes to update
     */
    where?: OtpCodeWhereInput
    /**
     * Limit how many OtpCodes to update.
     */
    limit?: number
  }

  /**
   * OtpCode updateManyAndReturn
   */
  export type OtpCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * The data used to update OtpCodes.
     */
    data: XOR<OtpCodeUpdateManyMutationInput, OtpCodeUncheckedUpdateManyInput>
    /**
     * Filter which OtpCodes to update
     */
    where?: OtpCodeWhereInput
    /**
     * Limit how many OtpCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OtpCode upsert
   */
  export type OtpCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the OtpCode to update in case it exists.
     */
    where: OtpCodeWhereUniqueInput
    /**
     * In case the OtpCode found by the `where` argument doesn't exist, create a new OtpCode with this data.
     */
    create: XOR<OtpCodeCreateInput, OtpCodeUncheckedCreateInput>
    /**
     * In case the OtpCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpCodeUpdateInput, OtpCodeUncheckedUpdateInput>
  }

  /**
   * OtpCode delete
   */
  export type OtpCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
    /**
     * Filter which OtpCode to delete.
     */
    where: OtpCodeWhereUniqueInput
  }

  /**
   * OtpCode deleteMany
   */
  export type OtpCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpCodes to delete
     */
    where?: OtpCodeWhereInput
    /**
     * Limit how many OtpCodes to delete.
     */
    limit?: number
  }

  /**
   * OtpCode.user
   */
  export type OtpCode$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * OtpCode without action
   */
  export type OtpCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpCode
     */
    select?: OtpCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpCode
     */
    omit?: OtpCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpCodeInclude<ExtArgs> | null
  }


  /**
   * Model Journey
   */

  export type AggregateJourney = {
    _count: JourneyCountAggregateOutputType | null
    _avg: JourneyAvgAggregateOutputType | null
    _sum: JourneySumAggregateOutputType | null
    _min: JourneyMinAggregateOutputType | null
    _max: JourneyMaxAggregateOutputType | null
  }

  export type JourneyAvgAggregateOutputType = {
    id: number | null
    index: number | null
    userId: number | null
  }

  export type JourneySumAggregateOutputType = {
    id: number | null
    index: number | null
    userId: number | null
  }

  export type JourneyMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    completedAt: Date | null
    status: $Enums.JourneyStatus | null
    label: string | null
    selectedState: string | null
    index: number | null
    userId: number | null
  }

  export type JourneyMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    completedAt: Date | null
    status: $Enums.JourneyStatus | null
    label: string | null
    selectedState: string | null
    index: number | null
    userId: number | null
  }

  export type JourneyCountAggregateOutputType = {
    id: number
    createdAt: number
    completedAt: number
    status: number
    label: number
    selectedState: number
    selectedCities: number
    inputs: number
    index: number
    userId: number
    _all: number
  }


  export type JourneyAvgAggregateInputType = {
    id?: true
    index?: true
    userId?: true
  }

  export type JourneySumAggregateInputType = {
    id?: true
    index?: true
    userId?: true
  }

  export type JourneyMinAggregateInputType = {
    id?: true
    createdAt?: true
    completedAt?: true
    status?: true
    label?: true
    selectedState?: true
    index?: true
    userId?: true
  }

  export type JourneyMaxAggregateInputType = {
    id?: true
    createdAt?: true
    completedAt?: true
    status?: true
    label?: true
    selectedState?: true
    index?: true
    userId?: true
  }

  export type JourneyCountAggregateInputType = {
    id?: true
    createdAt?: true
    completedAt?: true
    status?: true
    label?: true
    selectedState?: true
    selectedCities?: true
    inputs?: true
    index?: true
    userId?: true
    _all?: true
  }

  export type JourneyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journey to aggregate.
     */
    where?: JourneyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journeys to fetch.
     */
    orderBy?: JourneyOrderByWithRelationInput | JourneyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JourneyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journeys
    **/
    _count?: true | JourneyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JourneyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JourneySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JourneyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JourneyMaxAggregateInputType
  }

  export type GetJourneyAggregateType<T extends JourneyAggregateArgs> = {
        [P in keyof T & keyof AggregateJourney]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJourney[P]>
      : GetScalarType<T[P], AggregateJourney[P]>
  }




  export type JourneyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyWhereInput
    orderBy?: JourneyOrderByWithAggregationInput | JourneyOrderByWithAggregationInput[]
    by: JourneyScalarFieldEnum[] | JourneyScalarFieldEnum
    having?: JourneyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JourneyCountAggregateInputType | true
    _avg?: JourneyAvgAggregateInputType
    _sum?: JourneySumAggregateInputType
    _min?: JourneyMinAggregateInputType
    _max?: JourneyMaxAggregateInputType
  }

  export type JourneyGroupByOutputType = {
    id: number
    createdAt: Date
    completedAt: Date | null
    status: $Enums.JourneyStatus
    label: string | null
    selectedState: string | null
    selectedCities: string[]
    inputs: JsonValue | null
    index: number
    userId: number
    _count: JourneyCountAggregateOutputType | null
    _avg: JourneyAvgAggregateOutputType | null
    _sum: JourneySumAggregateOutputType | null
    _min: JourneyMinAggregateOutputType | null
    _max: JourneyMaxAggregateOutputType | null
  }

  type GetJourneyGroupByPayload<T extends JourneyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JourneyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JourneyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JourneyGroupByOutputType[P]>
            : GetScalarType<T[P], JourneyGroupByOutputType[P]>
        }
      >
    >


  export type JourneySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    completedAt?: boolean
    status?: boolean
    label?: boolean
    selectedState?: boolean
    selectedCities?: boolean
    inputs?: boolean
    index?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    recommendation?: boolean | Journey$recommendationArgs<ExtArgs>
  }, ExtArgs["result"]["journey"]>

  export type JourneySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    completedAt?: boolean
    status?: boolean
    label?: boolean
    selectedState?: boolean
    selectedCities?: boolean
    inputs?: boolean
    index?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journey"]>

  export type JourneySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    completedAt?: boolean
    status?: boolean
    label?: boolean
    selectedState?: boolean
    selectedCities?: boolean
    inputs?: boolean
    index?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journey"]>

  export type JourneySelectScalar = {
    id?: boolean
    createdAt?: boolean
    completedAt?: boolean
    status?: boolean
    label?: boolean
    selectedState?: boolean
    selectedCities?: boolean
    inputs?: boolean
    index?: boolean
    userId?: boolean
  }

  export type JourneyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "completedAt" | "status" | "label" | "selectedState" | "selectedCities" | "inputs" | "index" | "userId", ExtArgs["result"]["journey"]>
  export type JourneyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    recommendation?: boolean | Journey$recommendationArgs<ExtArgs>
  }
  export type JourneyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JourneyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JourneyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      recommendation: Prisma.$RecommendationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      completedAt: Date | null
      status: $Enums.JourneyStatus
      label: string | null
      selectedState: string | null
      selectedCities: string[]
      inputs: Prisma.JsonValue | null
      index: number
      userId: number
    }, ExtArgs["result"]["journey"]>
    composites: {}
  }

  type JourneyGetPayload<S extends boolean | null | undefined | JourneyDefaultArgs> = $Result.GetResult<Prisma.$JourneyPayload, S>

  type JourneyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JourneyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JourneyCountAggregateInputType | true
    }

  export interface JourneyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journey'], meta: { name: 'Journey' } }
    /**
     * Find zero or one Journey that matches the filter.
     * @param {JourneyFindUniqueArgs} args - Arguments to find a Journey
     * @example
     * // Get one Journey
     * const journey = await prisma.journey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JourneyFindUniqueArgs>(args: SelectSubset<T, JourneyFindUniqueArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Journey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JourneyFindUniqueOrThrowArgs} args - Arguments to find a Journey
     * @example
     * // Get one Journey
     * const journey = await prisma.journey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JourneyFindUniqueOrThrowArgs>(args: SelectSubset<T, JourneyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyFindFirstArgs} args - Arguments to find a Journey
     * @example
     * // Get one Journey
     * const journey = await prisma.journey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JourneyFindFirstArgs>(args?: SelectSubset<T, JourneyFindFirstArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Journey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyFindFirstOrThrowArgs} args - Arguments to find a Journey
     * @example
     * // Get one Journey
     * const journey = await prisma.journey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JourneyFindFirstOrThrowArgs>(args?: SelectSubset<T, JourneyFindFirstOrThrowArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Journeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journeys
     * const journeys = await prisma.journey.findMany()
     * 
     * // Get first 10 Journeys
     * const journeys = await prisma.journey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journeyWithIdOnly = await prisma.journey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JourneyFindManyArgs>(args?: SelectSubset<T, JourneyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Journey.
     * @param {JourneyCreateArgs} args - Arguments to create a Journey.
     * @example
     * // Create one Journey
     * const Journey = await prisma.journey.create({
     *   data: {
     *     // ... data to create a Journey
     *   }
     * })
     * 
     */
    create<T extends JourneyCreateArgs>(args: SelectSubset<T, JourneyCreateArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Journeys.
     * @param {JourneyCreateManyArgs} args - Arguments to create many Journeys.
     * @example
     * // Create many Journeys
     * const journey = await prisma.journey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JourneyCreateManyArgs>(args?: SelectSubset<T, JourneyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Journeys and returns the data saved in the database.
     * @param {JourneyCreateManyAndReturnArgs} args - Arguments to create many Journeys.
     * @example
     * // Create many Journeys
     * const journey = await prisma.journey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Journeys and only return the `id`
     * const journeyWithIdOnly = await prisma.journey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JourneyCreateManyAndReturnArgs>(args?: SelectSubset<T, JourneyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Journey.
     * @param {JourneyDeleteArgs} args - Arguments to delete one Journey.
     * @example
     * // Delete one Journey
     * const Journey = await prisma.journey.delete({
     *   where: {
     *     // ... filter to delete one Journey
     *   }
     * })
     * 
     */
    delete<T extends JourneyDeleteArgs>(args: SelectSubset<T, JourneyDeleteArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Journey.
     * @param {JourneyUpdateArgs} args - Arguments to update one Journey.
     * @example
     * // Update one Journey
     * const journey = await prisma.journey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JourneyUpdateArgs>(args: SelectSubset<T, JourneyUpdateArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Journeys.
     * @param {JourneyDeleteManyArgs} args - Arguments to filter Journeys to delete.
     * @example
     * // Delete a few Journeys
     * const { count } = await prisma.journey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JourneyDeleteManyArgs>(args?: SelectSubset<T, JourneyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journeys
     * const journey = await prisma.journey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JourneyUpdateManyArgs>(args: SelectSubset<T, JourneyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journeys and returns the data updated in the database.
     * @param {JourneyUpdateManyAndReturnArgs} args - Arguments to update many Journeys.
     * @example
     * // Update many Journeys
     * const journey = await prisma.journey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Journeys and only return the `id`
     * const journeyWithIdOnly = await prisma.journey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JourneyUpdateManyAndReturnArgs>(args: SelectSubset<T, JourneyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Journey.
     * @param {JourneyUpsertArgs} args - Arguments to update or create a Journey.
     * @example
     * // Update or create a Journey
     * const journey = await prisma.journey.upsert({
     *   create: {
     *     // ... data to create a Journey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journey we want to update
     *   }
     * })
     */
    upsert<T extends JourneyUpsertArgs>(args: SelectSubset<T, JourneyUpsertArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Journeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyCountArgs} args - Arguments to filter Journeys to count.
     * @example
     * // Count the number of Journeys
     * const count = await prisma.journey.count({
     *   where: {
     *     // ... the filter for the Journeys we want to count
     *   }
     * })
    **/
    count<T extends JourneyCountArgs>(
      args?: Subset<T, JourneyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JourneyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JourneyAggregateArgs>(args: Subset<T, JourneyAggregateArgs>): Prisma.PrismaPromise<GetJourneyAggregateType<T>>

    /**
     * Group by Journey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JourneyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JourneyGroupByArgs['orderBy'] }
        : { orderBy?: JourneyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JourneyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJourneyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journey model
   */
  readonly fields: JourneyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JourneyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recommendation<T extends Journey$recommendationArgs<ExtArgs> = {}>(args?: Subset<T, Journey$recommendationArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journey model
   */
  interface JourneyFieldRefs {
    readonly id: FieldRef<"Journey", 'Int'>
    readonly createdAt: FieldRef<"Journey", 'DateTime'>
    readonly completedAt: FieldRef<"Journey", 'DateTime'>
    readonly status: FieldRef<"Journey", 'JourneyStatus'>
    readonly label: FieldRef<"Journey", 'String'>
    readonly selectedState: FieldRef<"Journey", 'String'>
    readonly selectedCities: FieldRef<"Journey", 'String[]'>
    readonly inputs: FieldRef<"Journey", 'Json'>
    readonly index: FieldRef<"Journey", 'Int'>
    readonly userId: FieldRef<"Journey", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Journey findUnique
   */
  export type JourneyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * Filter, which Journey to fetch.
     */
    where: JourneyWhereUniqueInput
  }

  /**
   * Journey findUniqueOrThrow
   */
  export type JourneyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * Filter, which Journey to fetch.
     */
    where: JourneyWhereUniqueInput
  }

  /**
   * Journey findFirst
   */
  export type JourneyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * Filter, which Journey to fetch.
     */
    where?: JourneyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journeys to fetch.
     */
    orderBy?: JourneyOrderByWithRelationInput | JourneyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journeys.
     */
    cursor?: JourneyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journeys.
     */
    distinct?: JourneyScalarFieldEnum | JourneyScalarFieldEnum[]
  }

  /**
   * Journey findFirstOrThrow
   */
  export type JourneyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * Filter, which Journey to fetch.
     */
    where?: JourneyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journeys to fetch.
     */
    orderBy?: JourneyOrderByWithRelationInput | JourneyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journeys.
     */
    cursor?: JourneyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journeys.
     */
    distinct?: JourneyScalarFieldEnum | JourneyScalarFieldEnum[]
  }

  /**
   * Journey findMany
   */
  export type JourneyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * Filter, which Journeys to fetch.
     */
    where?: JourneyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journeys to fetch.
     */
    orderBy?: JourneyOrderByWithRelationInput | JourneyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journeys.
     */
    cursor?: JourneyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journeys.
     */
    skip?: number
    distinct?: JourneyScalarFieldEnum | JourneyScalarFieldEnum[]
  }

  /**
   * Journey create
   */
  export type JourneyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * The data needed to create a Journey.
     */
    data: XOR<JourneyCreateInput, JourneyUncheckedCreateInput>
  }

  /**
   * Journey createMany
   */
  export type JourneyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journeys.
     */
    data: JourneyCreateManyInput | JourneyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journey createManyAndReturn
   */
  export type JourneyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * The data used to create many Journeys.
     */
    data: JourneyCreateManyInput | JourneyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journey update
   */
  export type JourneyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * The data needed to update a Journey.
     */
    data: XOR<JourneyUpdateInput, JourneyUncheckedUpdateInput>
    /**
     * Choose, which Journey to update.
     */
    where: JourneyWhereUniqueInput
  }

  /**
   * Journey updateMany
   */
  export type JourneyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journeys.
     */
    data: XOR<JourneyUpdateManyMutationInput, JourneyUncheckedUpdateManyInput>
    /**
     * Filter which Journeys to update
     */
    where?: JourneyWhereInput
    /**
     * Limit how many Journeys to update.
     */
    limit?: number
  }

  /**
   * Journey updateManyAndReturn
   */
  export type JourneyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * The data used to update Journeys.
     */
    data: XOR<JourneyUpdateManyMutationInput, JourneyUncheckedUpdateManyInput>
    /**
     * Filter which Journeys to update
     */
    where?: JourneyWhereInput
    /**
     * Limit how many Journeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journey upsert
   */
  export type JourneyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * The filter to search for the Journey to update in case it exists.
     */
    where: JourneyWhereUniqueInput
    /**
     * In case the Journey found by the `where` argument doesn't exist, create a new Journey with this data.
     */
    create: XOR<JourneyCreateInput, JourneyUncheckedCreateInput>
    /**
     * In case the Journey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JourneyUpdateInput, JourneyUncheckedUpdateInput>
  }

  /**
   * Journey delete
   */
  export type JourneyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    /**
     * Filter which Journey to delete.
     */
    where: JourneyWhereUniqueInput
  }

  /**
   * Journey deleteMany
   */
  export type JourneyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journeys to delete
     */
    where?: JourneyWhereInput
    /**
     * Limit how many Journeys to delete.
     */
    limit?: number
  }

  /**
   * Journey.recommendation
   */
  export type Journey$recommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    where?: RecommendationWhereInput
  }

  /**
   * Journey without action
   */
  export type JourneyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
  }


  /**
   * Model Recommendation
   */

  export type AggregateRecommendation = {
    _count: RecommendationCountAggregateOutputType | null
    _avg: RecommendationAvgAggregateOutputType | null
    _sum: RecommendationSumAggregateOutputType | null
    _min: RecommendationMinAggregateOutputType | null
    _max: RecommendationMaxAggregateOutputType | null
  }

  export type RecommendationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    journeyId: number | null
  }

  export type RecommendationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    journeyId: number | null
  }

  export type RecommendationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: number | null
    journeyId: number | null
  }

  export type RecommendationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: number | null
    journeyId: number | null
  }

  export type RecommendationCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    journeyId: number
    _all: number
  }


  export type RecommendationAvgAggregateInputType = {
    id?: true
    userId?: true
    journeyId?: true
  }

  export type RecommendationSumAggregateInputType = {
    id?: true
    userId?: true
    journeyId?: true
  }

  export type RecommendationMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    journeyId?: true
  }

  export type RecommendationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    journeyId?: true
  }

  export type RecommendationCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    journeyId?: true
    _all?: true
  }

  export type RecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recommendation to aggregate.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recommendations
    **/
    _count?: true | RecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecommendationMaxAggregateInputType
  }

  export type GetRecommendationAggregateType<T extends RecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendation[P]>
      : GetScalarType<T[P], AggregateRecommendation[P]>
  }




  export type RecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendationWhereInput
    orderBy?: RecommendationOrderByWithAggregationInput | RecommendationOrderByWithAggregationInput[]
    by: RecommendationScalarFieldEnum[] | RecommendationScalarFieldEnum
    having?: RecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecommendationCountAggregateInputType | true
    _avg?: RecommendationAvgAggregateInputType
    _sum?: RecommendationSumAggregateInputType
    _min?: RecommendationMinAggregateInputType
    _max?: RecommendationMaxAggregateInputType
  }

  export type RecommendationGroupByOutputType = {
    id: number
    createdAt: Date
    userId: number
    journeyId: number | null
    _count: RecommendationCountAggregateOutputType | null
    _avg: RecommendationAvgAggregateOutputType | null
    _sum: RecommendationSumAggregateOutputType | null
    _min: RecommendationMinAggregateOutputType | null
    _max: RecommendationMaxAggregateOutputType | null
  }

  type GetRecommendationGroupByPayload<T extends RecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendationGroupByOutputType[P]>
        }
      >
    >


  export type RecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    journeyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    journey?: boolean | Recommendation$journeyArgs<ExtArgs>
    propertySuggestion?: boolean | Recommendation$propertySuggestionArgs<ExtArgs>
    areas?: boolean | Recommendation$areasArgs<ExtArgs>
    _count?: boolean | RecommendationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recommendation"]>

  export type RecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    journeyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    journey?: boolean | Recommendation$journeyArgs<ExtArgs>
  }, ExtArgs["result"]["recommendation"]>

  export type RecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    journeyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    journey?: boolean | Recommendation$journeyArgs<ExtArgs>
  }, ExtArgs["result"]["recommendation"]>

  export type RecommendationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    journeyId?: boolean
  }

  export type RecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "userId" | "journeyId", ExtArgs["result"]["recommendation"]>
  export type RecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    journey?: boolean | Recommendation$journeyArgs<ExtArgs>
    propertySuggestion?: boolean | Recommendation$propertySuggestionArgs<ExtArgs>
    areas?: boolean | Recommendation$areasArgs<ExtArgs>
    _count?: boolean | RecommendationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    journey?: boolean | Recommendation$journeyArgs<ExtArgs>
  }
  export type RecommendationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    journey?: boolean | Recommendation$journeyArgs<ExtArgs>
  }

  export type $RecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recommendation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      journey: Prisma.$JourneyPayload<ExtArgs> | null
      propertySuggestion: Prisma.$PropertySuggestionPayload<ExtArgs> | null
      areas: Prisma.$RecommendedAreaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      userId: number
      journeyId: number | null
    }, ExtArgs["result"]["recommendation"]>
    composites: {}
  }

  type RecommendationGetPayload<S extends boolean | null | undefined | RecommendationDefaultArgs> = $Result.GetResult<Prisma.$RecommendationPayload, S>

  type RecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecommendationCountAggregateInputType | true
    }

  export interface RecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recommendation'], meta: { name: 'Recommendation' } }
    /**
     * Find zero or one Recommendation that matches the filter.
     * @param {RecommendationFindUniqueArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecommendationFindUniqueArgs>(args: SelectSubset<T, RecommendationFindUniqueArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecommendationFindUniqueOrThrowArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, RecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindFirstArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecommendationFindFirstArgs>(args?: SelectSubset<T, RecommendationFindFirstArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindFirstOrThrowArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, RecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recommendations
     * const recommendations = await prisma.recommendation.findMany()
     * 
     * // Get first 10 Recommendations
     * const recommendations = await prisma.recommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recommendationWithIdOnly = await prisma.recommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecommendationFindManyArgs>(args?: SelectSubset<T, RecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recommendation.
     * @param {RecommendationCreateArgs} args - Arguments to create a Recommendation.
     * @example
     * // Create one Recommendation
     * const Recommendation = await prisma.recommendation.create({
     *   data: {
     *     // ... data to create a Recommendation
     *   }
     * })
     * 
     */
    create<T extends RecommendationCreateArgs>(args: SelectSubset<T, RecommendationCreateArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recommendations.
     * @param {RecommendationCreateManyArgs} args - Arguments to create many Recommendations.
     * @example
     * // Create many Recommendations
     * const recommendation = await prisma.recommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecommendationCreateManyArgs>(args?: SelectSubset<T, RecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recommendations and returns the data saved in the database.
     * @param {RecommendationCreateManyAndReturnArgs} args - Arguments to create many Recommendations.
     * @example
     * // Create many Recommendations
     * const recommendation = await prisma.recommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recommendations and only return the `id`
     * const recommendationWithIdOnly = await prisma.recommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, RecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recommendation.
     * @param {RecommendationDeleteArgs} args - Arguments to delete one Recommendation.
     * @example
     * // Delete one Recommendation
     * const Recommendation = await prisma.recommendation.delete({
     *   where: {
     *     // ... filter to delete one Recommendation
     *   }
     * })
     * 
     */
    delete<T extends RecommendationDeleteArgs>(args: SelectSubset<T, RecommendationDeleteArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recommendation.
     * @param {RecommendationUpdateArgs} args - Arguments to update one Recommendation.
     * @example
     * // Update one Recommendation
     * const recommendation = await prisma.recommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecommendationUpdateArgs>(args: SelectSubset<T, RecommendationUpdateArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recommendations.
     * @param {RecommendationDeleteManyArgs} args - Arguments to filter Recommendations to delete.
     * @example
     * // Delete a few Recommendations
     * const { count } = await prisma.recommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecommendationDeleteManyArgs>(args?: SelectSubset<T, RecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recommendations
     * const recommendation = await prisma.recommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecommendationUpdateManyArgs>(args: SelectSubset<T, RecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recommendations and returns the data updated in the database.
     * @param {RecommendationUpdateManyAndReturnArgs} args - Arguments to update many Recommendations.
     * @example
     * // Update many Recommendations
     * const recommendation = await prisma.recommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recommendations and only return the `id`
     * const recommendationWithIdOnly = await prisma.recommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, RecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recommendation.
     * @param {RecommendationUpsertArgs} args - Arguments to update or create a Recommendation.
     * @example
     * // Update or create a Recommendation
     * const recommendation = await prisma.recommendation.upsert({
     *   create: {
     *     // ... data to create a Recommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recommendation we want to update
     *   }
     * })
     */
    upsert<T extends RecommendationUpsertArgs>(args: SelectSubset<T, RecommendationUpsertArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationCountArgs} args - Arguments to filter Recommendations to count.
     * @example
     * // Count the number of Recommendations
     * const count = await prisma.recommendation.count({
     *   where: {
     *     // ... the filter for the Recommendations we want to count
     *   }
     * })
    **/
    count<T extends RecommendationCountArgs>(
      args?: Subset<T, RecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecommendationAggregateArgs>(args: Subset<T, RecommendationAggregateArgs>): Prisma.PrismaPromise<GetRecommendationAggregateType<T>>

    /**
     * Group by Recommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecommendationGroupByArgs['orderBy'] }
        : { orderBy?: RecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recommendation model
   */
  readonly fields: RecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    journey<T extends Recommendation$journeyArgs<ExtArgs> = {}>(args?: Subset<T, Recommendation$journeyArgs<ExtArgs>>): Prisma__JourneyClient<$Result.GetResult<Prisma.$JourneyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    propertySuggestion<T extends Recommendation$propertySuggestionArgs<ExtArgs> = {}>(args?: Subset<T, Recommendation$propertySuggestionArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    areas<T extends Recommendation$areasArgs<ExtArgs> = {}>(args?: Subset<T, Recommendation$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recommendation model
   */
  interface RecommendationFieldRefs {
    readonly id: FieldRef<"Recommendation", 'Int'>
    readonly createdAt: FieldRef<"Recommendation", 'DateTime'>
    readonly userId: FieldRef<"Recommendation", 'Int'>
    readonly journeyId: FieldRef<"Recommendation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Recommendation findUnique
   */
  export type RecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation findUniqueOrThrow
   */
  export type RecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation findFirst
   */
  export type RecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recommendations.
     */
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation findFirstOrThrow
   */
  export type RecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recommendations.
     */
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation findMany
   */
  export type RecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendations to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation create
   */
  export type RecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a Recommendation.
     */
    data: XOR<RecommendationCreateInput, RecommendationUncheckedCreateInput>
  }

  /**
   * Recommendation createMany
   */
  export type RecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recommendations.
     */
    data: RecommendationCreateManyInput | RecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recommendation createManyAndReturn
   */
  export type RecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many Recommendations.
     */
    data: RecommendationCreateManyInput | RecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recommendation update
   */
  export type RecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a Recommendation.
     */
    data: XOR<RecommendationUpdateInput, RecommendationUncheckedUpdateInput>
    /**
     * Choose, which Recommendation to update.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation updateMany
   */
  export type RecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recommendations.
     */
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyInput>
    /**
     * Filter which Recommendations to update
     */
    where?: RecommendationWhereInput
    /**
     * Limit how many Recommendations to update.
     */
    limit?: number
  }

  /**
   * Recommendation updateManyAndReturn
   */
  export type RecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * The data used to update Recommendations.
     */
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyInput>
    /**
     * Filter which Recommendations to update
     */
    where?: RecommendationWhereInput
    /**
     * Limit how many Recommendations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recommendation upsert
   */
  export type RecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the Recommendation to update in case it exists.
     */
    where: RecommendationWhereUniqueInput
    /**
     * In case the Recommendation found by the `where` argument doesn't exist, create a new Recommendation with this data.
     */
    create: XOR<RecommendationCreateInput, RecommendationUncheckedCreateInput>
    /**
     * In case the Recommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecommendationUpdateInput, RecommendationUncheckedUpdateInput>
  }

  /**
   * Recommendation delete
   */
  export type RecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter which Recommendation to delete.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation deleteMany
   */
  export type RecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recommendations to delete
     */
    where?: RecommendationWhereInput
    /**
     * Limit how many Recommendations to delete.
     */
    limit?: number
  }

  /**
   * Recommendation.journey
   */
  export type Recommendation$journeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journey
     */
    select?: JourneySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journey
     */
    omit?: JourneyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyInclude<ExtArgs> | null
    where?: JourneyWhereInput
  }

  /**
   * Recommendation.propertySuggestion
   */
  export type Recommendation$propertySuggestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    where?: PropertySuggestionWhereInput
  }

  /**
   * Recommendation.areas
   */
  export type Recommendation$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    where?: RecommendedAreaWhereInput
    orderBy?: RecommendedAreaOrderByWithRelationInput | RecommendedAreaOrderByWithRelationInput[]
    cursor?: RecommendedAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendedAreaScalarFieldEnum | RecommendedAreaScalarFieldEnum[]
  }

  /**
   * Recommendation without action
   */
  export type RecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recommendation
     */
    omit?: RecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
  }


  /**
   * Model RecommendedArea
   */

  export type AggregateRecommendedArea = {
    _count: RecommendedAreaCountAggregateOutputType | null
    _avg: RecommendedAreaAvgAggregateOutputType | null
    _sum: RecommendedAreaSumAggregateOutputType | null
    _min: RecommendedAreaMinAggregateOutputType | null
    _max: RecommendedAreaMaxAggregateOutputType | null
  }

  export type RecommendedAreaAvgAggregateOutputType = {
    id: number | null
    recommendationId: number | null
  }

  export type RecommendedAreaSumAggregateOutputType = {
    id: number | null
    recommendationId: number | null
  }

  export type RecommendedAreaMinAggregateOutputType = {
    id: number | null
    name: string | null
    state: string | null
    reason: string | null
    imageUrl: string | null
    fullDescription: string | null
    recommendationId: number | null
  }

  export type RecommendedAreaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    state: string | null
    reason: string | null
    imageUrl: string | null
    fullDescription: string | null
    recommendationId: number | null
  }

  export type RecommendedAreaCountAggregateOutputType = {
    id: number
    name: number
    state: number
    reason: number
    imageUrl: number
    fullDescription: number
    recommendationId: number
    placesOfInterest: number
    lifestyleTags: number
    _all: number
  }


  export type RecommendedAreaAvgAggregateInputType = {
    id?: true
    recommendationId?: true
  }

  export type RecommendedAreaSumAggregateInputType = {
    id?: true
    recommendationId?: true
  }

  export type RecommendedAreaMinAggregateInputType = {
    id?: true
    name?: true
    state?: true
    reason?: true
    imageUrl?: true
    fullDescription?: true
    recommendationId?: true
  }

  export type RecommendedAreaMaxAggregateInputType = {
    id?: true
    name?: true
    state?: true
    reason?: true
    imageUrl?: true
    fullDescription?: true
    recommendationId?: true
  }

  export type RecommendedAreaCountAggregateInputType = {
    id?: true
    name?: true
    state?: true
    reason?: true
    imageUrl?: true
    fullDescription?: true
    recommendationId?: true
    placesOfInterest?: true
    lifestyleTags?: true
    _all?: true
  }

  export type RecommendedAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecommendedArea to aggregate.
     */
    where?: RecommendedAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecommendedAreas to fetch.
     */
    orderBy?: RecommendedAreaOrderByWithRelationInput | RecommendedAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecommendedAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecommendedAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecommendedAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecommendedAreas
    **/
    _count?: true | RecommendedAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecommendedAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecommendedAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecommendedAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecommendedAreaMaxAggregateInputType
  }

  export type GetRecommendedAreaAggregateType<T extends RecommendedAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommendedArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendedArea[P]>
      : GetScalarType<T[P], AggregateRecommendedArea[P]>
  }




  export type RecommendedAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendedAreaWhereInput
    orderBy?: RecommendedAreaOrderByWithAggregationInput | RecommendedAreaOrderByWithAggregationInput[]
    by: RecommendedAreaScalarFieldEnum[] | RecommendedAreaScalarFieldEnum
    having?: RecommendedAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecommendedAreaCountAggregateInputType | true
    _avg?: RecommendedAreaAvgAggregateInputType
    _sum?: RecommendedAreaSumAggregateInputType
    _min?: RecommendedAreaMinAggregateInputType
    _max?: RecommendedAreaMaxAggregateInputType
  }

  export type RecommendedAreaGroupByOutputType = {
    id: number
    name: string
    state: string
    reason: string
    imageUrl: string | null
    fullDescription: string | null
    recommendationId: number
    placesOfInterest: string[]
    lifestyleTags: string[]
    _count: RecommendedAreaCountAggregateOutputType | null
    _avg: RecommendedAreaAvgAggregateOutputType | null
    _sum: RecommendedAreaSumAggregateOutputType | null
    _min: RecommendedAreaMinAggregateOutputType | null
    _max: RecommendedAreaMaxAggregateOutputType | null
  }

  type GetRecommendedAreaGroupByPayload<T extends RecommendedAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecommendedAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecommendedAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendedAreaGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendedAreaGroupByOutputType[P]>
        }
      >
    >


  export type RecommendedAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    reason?: boolean
    imageUrl?: boolean
    fullDescription?: boolean
    recommendationId?: boolean
    placesOfInterest?: boolean
    lifestyleTags?: boolean
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
    raceEthnicity?: boolean | RecommendedArea$raceEthnicityArgs<ExtArgs>
    incomeLevels?: boolean | RecommendedArea$incomeLevelsArgs<ExtArgs>
    crimeData?: boolean | RecommendedArea$crimeDataArgs<ExtArgs>
    schools?: boolean | RecommendedArea$schoolsArgs<ExtArgs>
    socialLife?: boolean | RecommendedArea$socialLifeArgs<ExtArgs>
    shopping?: boolean | RecommendedArea$shoppingArgs<ExtArgs>
    greenSpaces?: boolean | RecommendedArea$greenSpacesArgs<ExtArgs>
    sports?: boolean | RecommendedArea$sportsArgs<ExtArgs>
    properties?: boolean | RecommendedArea$propertiesArgs<ExtArgs>
    _count?: boolean | RecommendedAreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recommendedArea"]>

  export type RecommendedAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    reason?: boolean
    imageUrl?: boolean
    fullDescription?: boolean
    recommendationId?: boolean
    placesOfInterest?: boolean
    lifestyleTags?: boolean
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recommendedArea"]>

  export type RecommendedAreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    reason?: boolean
    imageUrl?: boolean
    fullDescription?: boolean
    recommendationId?: boolean
    placesOfInterest?: boolean
    lifestyleTags?: boolean
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recommendedArea"]>

  export type RecommendedAreaSelectScalar = {
    id?: boolean
    name?: boolean
    state?: boolean
    reason?: boolean
    imageUrl?: boolean
    fullDescription?: boolean
    recommendationId?: boolean
    placesOfInterest?: boolean
    lifestyleTags?: boolean
  }

  export type RecommendedAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "state" | "reason" | "imageUrl" | "fullDescription" | "recommendationId" | "placesOfInterest" | "lifestyleTags", ExtArgs["result"]["recommendedArea"]>
  export type RecommendedAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
    raceEthnicity?: boolean | RecommendedArea$raceEthnicityArgs<ExtArgs>
    incomeLevels?: boolean | RecommendedArea$incomeLevelsArgs<ExtArgs>
    crimeData?: boolean | RecommendedArea$crimeDataArgs<ExtArgs>
    schools?: boolean | RecommendedArea$schoolsArgs<ExtArgs>
    socialLife?: boolean | RecommendedArea$socialLifeArgs<ExtArgs>
    shopping?: boolean | RecommendedArea$shoppingArgs<ExtArgs>
    greenSpaces?: boolean | RecommendedArea$greenSpacesArgs<ExtArgs>
    sports?: boolean | RecommendedArea$sportsArgs<ExtArgs>
    properties?: boolean | RecommendedArea$propertiesArgs<ExtArgs>
    _count?: boolean | RecommendedAreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecommendedAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }
  export type RecommendedAreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }

  export type $RecommendedAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecommendedArea"
    objects: {
      recommendation: Prisma.$RecommendationPayload<ExtArgs>
      raceEthnicity: Prisma.$RaceEthnicityPayload<ExtArgs> | null
      incomeLevels: Prisma.$IncomeLevelsPayload<ExtArgs> | null
      crimeData: Prisma.$CrimeDataPayload<ExtArgs> | null
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      socialLife: Prisma.$SocialLifePayload<ExtArgs>[]
      shopping: Prisma.$ShoppingPayload<ExtArgs>[]
      greenSpaces: Prisma.$GreenSpacePayload<ExtArgs>[]
      sports: Prisma.$SportPayload<ExtArgs>[]
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      state: string
      reason: string
      imageUrl: string | null
      fullDescription: string | null
      recommendationId: number
      placesOfInterest: string[]
      lifestyleTags: string[]
    }, ExtArgs["result"]["recommendedArea"]>
    composites: {}
  }

  type RecommendedAreaGetPayload<S extends boolean | null | undefined | RecommendedAreaDefaultArgs> = $Result.GetResult<Prisma.$RecommendedAreaPayload, S>

  type RecommendedAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecommendedAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecommendedAreaCountAggregateInputType | true
    }

  export interface RecommendedAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecommendedArea'], meta: { name: 'RecommendedArea' } }
    /**
     * Find zero or one RecommendedArea that matches the filter.
     * @param {RecommendedAreaFindUniqueArgs} args - Arguments to find a RecommendedArea
     * @example
     * // Get one RecommendedArea
     * const recommendedArea = await prisma.recommendedArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecommendedAreaFindUniqueArgs>(args: SelectSubset<T, RecommendedAreaFindUniqueArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecommendedArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecommendedAreaFindUniqueOrThrowArgs} args - Arguments to find a RecommendedArea
     * @example
     * // Get one RecommendedArea
     * const recommendedArea = await prisma.recommendedArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecommendedAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, RecommendedAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecommendedArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAreaFindFirstArgs} args - Arguments to find a RecommendedArea
     * @example
     * // Get one RecommendedArea
     * const recommendedArea = await prisma.recommendedArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecommendedAreaFindFirstArgs>(args?: SelectSubset<T, RecommendedAreaFindFirstArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecommendedArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAreaFindFirstOrThrowArgs} args - Arguments to find a RecommendedArea
     * @example
     * // Get one RecommendedArea
     * const recommendedArea = await prisma.recommendedArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecommendedAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, RecommendedAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecommendedAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecommendedAreas
     * const recommendedAreas = await prisma.recommendedArea.findMany()
     * 
     * // Get first 10 RecommendedAreas
     * const recommendedAreas = await prisma.recommendedArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recommendedAreaWithIdOnly = await prisma.recommendedArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecommendedAreaFindManyArgs>(args?: SelectSubset<T, RecommendedAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecommendedArea.
     * @param {RecommendedAreaCreateArgs} args - Arguments to create a RecommendedArea.
     * @example
     * // Create one RecommendedArea
     * const RecommendedArea = await prisma.recommendedArea.create({
     *   data: {
     *     // ... data to create a RecommendedArea
     *   }
     * })
     * 
     */
    create<T extends RecommendedAreaCreateArgs>(args: SelectSubset<T, RecommendedAreaCreateArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecommendedAreas.
     * @param {RecommendedAreaCreateManyArgs} args - Arguments to create many RecommendedAreas.
     * @example
     * // Create many RecommendedAreas
     * const recommendedArea = await prisma.recommendedArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecommendedAreaCreateManyArgs>(args?: SelectSubset<T, RecommendedAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecommendedAreas and returns the data saved in the database.
     * @param {RecommendedAreaCreateManyAndReturnArgs} args - Arguments to create many RecommendedAreas.
     * @example
     * // Create many RecommendedAreas
     * const recommendedArea = await prisma.recommendedArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecommendedAreas and only return the `id`
     * const recommendedAreaWithIdOnly = await prisma.recommendedArea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecommendedAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, RecommendedAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecommendedArea.
     * @param {RecommendedAreaDeleteArgs} args - Arguments to delete one RecommendedArea.
     * @example
     * // Delete one RecommendedArea
     * const RecommendedArea = await prisma.recommendedArea.delete({
     *   where: {
     *     // ... filter to delete one RecommendedArea
     *   }
     * })
     * 
     */
    delete<T extends RecommendedAreaDeleteArgs>(args: SelectSubset<T, RecommendedAreaDeleteArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecommendedArea.
     * @param {RecommendedAreaUpdateArgs} args - Arguments to update one RecommendedArea.
     * @example
     * // Update one RecommendedArea
     * const recommendedArea = await prisma.recommendedArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecommendedAreaUpdateArgs>(args: SelectSubset<T, RecommendedAreaUpdateArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecommendedAreas.
     * @param {RecommendedAreaDeleteManyArgs} args - Arguments to filter RecommendedAreas to delete.
     * @example
     * // Delete a few RecommendedAreas
     * const { count } = await prisma.recommendedArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecommendedAreaDeleteManyArgs>(args?: SelectSubset<T, RecommendedAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecommendedAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecommendedAreas
     * const recommendedArea = await prisma.recommendedArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecommendedAreaUpdateManyArgs>(args: SelectSubset<T, RecommendedAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecommendedAreas and returns the data updated in the database.
     * @param {RecommendedAreaUpdateManyAndReturnArgs} args - Arguments to update many RecommendedAreas.
     * @example
     * // Update many RecommendedAreas
     * const recommendedArea = await prisma.recommendedArea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecommendedAreas and only return the `id`
     * const recommendedAreaWithIdOnly = await prisma.recommendedArea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecommendedAreaUpdateManyAndReturnArgs>(args: SelectSubset<T, RecommendedAreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecommendedArea.
     * @param {RecommendedAreaUpsertArgs} args - Arguments to update or create a RecommendedArea.
     * @example
     * // Update or create a RecommendedArea
     * const recommendedArea = await prisma.recommendedArea.upsert({
     *   create: {
     *     // ... data to create a RecommendedArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecommendedArea we want to update
     *   }
     * })
     */
    upsert<T extends RecommendedAreaUpsertArgs>(args: SelectSubset<T, RecommendedAreaUpsertArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecommendedAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAreaCountArgs} args - Arguments to filter RecommendedAreas to count.
     * @example
     * // Count the number of RecommendedAreas
     * const count = await prisma.recommendedArea.count({
     *   where: {
     *     // ... the filter for the RecommendedAreas we want to count
     *   }
     * })
    **/
    count<T extends RecommendedAreaCountArgs>(
      args?: Subset<T, RecommendedAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecommendedAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecommendedArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecommendedAreaAggregateArgs>(args: Subset<T, RecommendedAreaAggregateArgs>): Prisma.PrismaPromise<GetRecommendedAreaAggregateType<T>>

    /**
     * Group by RecommendedArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecommendedAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecommendedAreaGroupByArgs['orderBy'] }
        : { orderBy?: RecommendedAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecommendedAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommendedAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecommendedArea model
   */
  readonly fields: RecommendedAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecommendedArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecommendedAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recommendation<T extends RecommendationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendationDefaultArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    raceEthnicity<T extends RecommendedArea$raceEthnicityArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$raceEthnicityArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    incomeLevels<T extends RecommendedArea$incomeLevelsArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$incomeLevelsArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    crimeData<T extends RecommendedArea$crimeDataArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$crimeDataArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schools<T extends RecommendedArea$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialLife<T extends RecommendedArea$socialLifeArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$socialLifeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shopping<T extends RecommendedArea$shoppingArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$shoppingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    greenSpaces<T extends RecommendedArea$greenSpacesArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$greenSpacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sports<T extends RecommendedArea$sportsArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$sportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    properties<T extends RecommendedArea$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedArea$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecommendedArea model
   */
  interface RecommendedAreaFieldRefs {
    readonly id: FieldRef<"RecommendedArea", 'Int'>
    readonly name: FieldRef<"RecommendedArea", 'String'>
    readonly state: FieldRef<"RecommendedArea", 'String'>
    readonly reason: FieldRef<"RecommendedArea", 'String'>
    readonly imageUrl: FieldRef<"RecommendedArea", 'String'>
    readonly fullDescription: FieldRef<"RecommendedArea", 'String'>
    readonly recommendationId: FieldRef<"RecommendedArea", 'Int'>
    readonly placesOfInterest: FieldRef<"RecommendedArea", 'String[]'>
    readonly lifestyleTags: FieldRef<"RecommendedArea", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * RecommendedArea findUnique
   */
  export type RecommendedAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedArea to fetch.
     */
    where: RecommendedAreaWhereUniqueInput
  }

  /**
   * RecommendedArea findUniqueOrThrow
   */
  export type RecommendedAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedArea to fetch.
     */
    where: RecommendedAreaWhereUniqueInput
  }

  /**
   * RecommendedArea findFirst
   */
  export type RecommendedAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedArea to fetch.
     */
    where?: RecommendedAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecommendedAreas to fetch.
     */
    orderBy?: RecommendedAreaOrderByWithRelationInput | RecommendedAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecommendedAreas.
     */
    cursor?: RecommendedAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecommendedAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecommendedAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecommendedAreas.
     */
    distinct?: RecommendedAreaScalarFieldEnum | RecommendedAreaScalarFieldEnum[]
  }

  /**
   * RecommendedArea findFirstOrThrow
   */
  export type RecommendedAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedArea to fetch.
     */
    where?: RecommendedAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecommendedAreas to fetch.
     */
    orderBy?: RecommendedAreaOrderByWithRelationInput | RecommendedAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecommendedAreas.
     */
    cursor?: RecommendedAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecommendedAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecommendedAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecommendedAreas.
     */
    distinct?: RecommendedAreaScalarFieldEnum | RecommendedAreaScalarFieldEnum[]
  }

  /**
   * RecommendedArea findMany
   */
  export type RecommendedAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * Filter, which RecommendedAreas to fetch.
     */
    where?: RecommendedAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecommendedAreas to fetch.
     */
    orderBy?: RecommendedAreaOrderByWithRelationInput | RecommendedAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecommendedAreas.
     */
    cursor?: RecommendedAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecommendedAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecommendedAreas.
     */
    skip?: number
    distinct?: RecommendedAreaScalarFieldEnum | RecommendedAreaScalarFieldEnum[]
  }

  /**
   * RecommendedArea create
   */
  export type RecommendedAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a RecommendedArea.
     */
    data: XOR<RecommendedAreaCreateInput, RecommendedAreaUncheckedCreateInput>
  }

  /**
   * RecommendedArea createMany
   */
  export type RecommendedAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecommendedAreas.
     */
    data: RecommendedAreaCreateManyInput | RecommendedAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecommendedArea createManyAndReturn
   */
  export type RecommendedAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * The data used to create many RecommendedAreas.
     */
    data: RecommendedAreaCreateManyInput | RecommendedAreaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecommendedArea update
   */
  export type RecommendedAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a RecommendedArea.
     */
    data: XOR<RecommendedAreaUpdateInput, RecommendedAreaUncheckedUpdateInput>
    /**
     * Choose, which RecommendedArea to update.
     */
    where: RecommendedAreaWhereUniqueInput
  }

  /**
   * RecommendedArea updateMany
   */
  export type RecommendedAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecommendedAreas.
     */
    data: XOR<RecommendedAreaUpdateManyMutationInput, RecommendedAreaUncheckedUpdateManyInput>
    /**
     * Filter which RecommendedAreas to update
     */
    where?: RecommendedAreaWhereInput
    /**
     * Limit how many RecommendedAreas to update.
     */
    limit?: number
  }

  /**
   * RecommendedArea updateManyAndReturn
   */
  export type RecommendedAreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * The data used to update RecommendedAreas.
     */
    data: XOR<RecommendedAreaUpdateManyMutationInput, RecommendedAreaUncheckedUpdateManyInput>
    /**
     * Filter which RecommendedAreas to update
     */
    where?: RecommendedAreaWhereInput
    /**
     * Limit how many RecommendedAreas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecommendedArea upsert
   */
  export type RecommendedAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the RecommendedArea to update in case it exists.
     */
    where: RecommendedAreaWhereUniqueInput
    /**
     * In case the RecommendedArea found by the `where` argument doesn't exist, create a new RecommendedArea with this data.
     */
    create: XOR<RecommendedAreaCreateInput, RecommendedAreaUncheckedCreateInput>
    /**
     * In case the RecommendedArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecommendedAreaUpdateInput, RecommendedAreaUncheckedUpdateInput>
  }

  /**
   * RecommendedArea delete
   */
  export type RecommendedAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
    /**
     * Filter which RecommendedArea to delete.
     */
    where: RecommendedAreaWhereUniqueInput
  }

  /**
   * RecommendedArea deleteMany
   */
  export type RecommendedAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecommendedAreas to delete
     */
    where?: RecommendedAreaWhereInput
    /**
     * Limit how many RecommendedAreas to delete.
     */
    limit?: number
  }

  /**
   * RecommendedArea.raceEthnicity
   */
  export type RecommendedArea$raceEthnicityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    where?: RaceEthnicityWhereInput
  }

  /**
   * RecommendedArea.incomeLevels
   */
  export type RecommendedArea$incomeLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    where?: IncomeLevelsWhereInput
  }

  /**
   * RecommendedArea.crimeData
   */
  export type RecommendedArea$crimeDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    where?: CrimeDataWhereInput
  }

  /**
   * RecommendedArea.schools
   */
  export type RecommendedArea$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * RecommendedArea.socialLife
   */
  export type RecommendedArea$socialLifeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    where?: SocialLifeWhereInput
    orderBy?: SocialLifeOrderByWithRelationInput | SocialLifeOrderByWithRelationInput[]
    cursor?: SocialLifeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialLifeScalarFieldEnum | SocialLifeScalarFieldEnum[]
  }

  /**
   * RecommendedArea.shopping
   */
  export type RecommendedArea$shoppingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    where?: ShoppingWhereInput
    orderBy?: ShoppingOrderByWithRelationInput | ShoppingOrderByWithRelationInput[]
    cursor?: ShoppingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShoppingScalarFieldEnum | ShoppingScalarFieldEnum[]
  }

  /**
   * RecommendedArea.greenSpaces
   */
  export type RecommendedArea$greenSpacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    where?: GreenSpaceWhereInput
    orderBy?: GreenSpaceOrderByWithRelationInput | GreenSpaceOrderByWithRelationInput[]
    cursor?: GreenSpaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GreenSpaceScalarFieldEnum | GreenSpaceScalarFieldEnum[]
  }

  /**
   * RecommendedArea.sports
   */
  export type RecommendedArea$sportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    where?: SportWhereInput
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    cursor?: SportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * RecommendedArea.properties
   */
  export type RecommendedArea$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * RecommendedArea without action
   */
  export type RecommendedAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecommendedArea
     */
    select?: RecommendedAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecommendedArea
     */
    omit?: RecommendedAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedAreaInclude<ExtArgs> | null
  }


  /**
   * Model RaceEthnicity
   */

  export type AggregateRaceEthnicity = {
    _count: RaceEthnicityCountAggregateOutputType | null
    _avg: RaceEthnicityAvgAggregateOutputType | null
    _sum: RaceEthnicitySumAggregateOutputType | null
    _min: RaceEthnicityMinAggregateOutputType | null
    _max: RaceEthnicityMaxAggregateOutputType | null
  }

  export type RaceEthnicityAvgAggregateOutputType = {
    id: number | null
    white: number | null
    hispanic: number | null
    asian: number | null
    black: number | null
    other: number | null
    areaId: number | null
  }

  export type RaceEthnicitySumAggregateOutputType = {
    id: number | null
    white: number | null
    hispanic: number | null
    asian: number | null
    black: number | null
    other: number | null
    areaId: number | null
  }

  export type RaceEthnicityMinAggregateOutputType = {
    id: number | null
    white: number | null
    hispanic: number | null
    asian: number | null
    black: number | null
    other: number | null
    areaId: number | null
  }

  export type RaceEthnicityMaxAggregateOutputType = {
    id: number | null
    white: number | null
    hispanic: number | null
    asian: number | null
    black: number | null
    other: number | null
    areaId: number | null
  }

  export type RaceEthnicityCountAggregateOutputType = {
    id: number
    white: number
    hispanic: number
    asian: number
    black: number
    other: number
    areaId: number
    _all: number
  }


  export type RaceEthnicityAvgAggregateInputType = {
    id?: true
    white?: true
    hispanic?: true
    asian?: true
    black?: true
    other?: true
    areaId?: true
  }

  export type RaceEthnicitySumAggregateInputType = {
    id?: true
    white?: true
    hispanic?: true
    asian?: true
    black?: true
    other?: true
    areaId?: true
  }

  export type RaceEthnicityMinAggregateInputType = {
    id?: true
    white?: true
    hispanic?: true
    asian?: true
    black?: true
    other?: true
    areaId?: true
  }

  export type RaceEthnicityMaxAggregateInputType = {
    id?: true
    white?: true
    hispanic?: true
    asian?: true
    black?: true
    other?: true
    areaId?: true
  }

  export type RaceEthnicityCountAggregateInputType = {
    id?: true
    white?: true
    hispanic?: true
    asian?: true
    black?: true
    other?: true
    areaId?: true
    _all?: true
  }

  export type RaceEthnicityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceEthnicity to aggregate.
     */
    where?: RaceEthnicityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceEthnicities to fetch.
     */
    orderBy?: RaceEthnicityOrderByWithRelationInput | RaceEthnicityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceEthnicityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceEthnicities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceEthnicities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaceEthnicities
    **/
    _count?: true | RaceEthnicityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceEthnicityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceEthnicitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceEthnicityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceEthnicityMaxAggregateInputType
  }

  export type GetRaceEthnicityAggregateType<T extends RaceEthnicityAggregateArgs> = {
        [P in keyof T & keyof AggregateRaceEthnicity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaceEthnicity[P]>
      : GetScalarType<T[P], AggregateRaceEthnicity[P]>
  }




  export type RaceEthnicityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceEthnicityWhereInput
    orderBy?: RaceEthnicityOrderByWithAggregationInput | RaceEthnicityOrderByWithAggregationInput[]
    by: RaceEthnicityScalarFieldEnum[] | RaceEthnicityScalarFieldEnum
    having?: RaceEthnicityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceEthnicityCountAggregateInputType | true
    _avg?: RaceEthnicityAvgAggregateInputType
    _sum?: RaceEthnicitySumAggregateInputType
    _min?: RaceEthnicityMinAggregateInputType
    _max?: RaceEthnicityMaxAggregateInputType
  }

  export type RaceEthnicityGroupByOutputType = {
    id: number
    white: number
    hispanic: number
    asian: number
    black: number
    other: number
    areaId: number
    _count: RaceEthnicityCountAggregateOutputType | null
    _avg: RaceEthnicityAvgAggregateOutputType | null
    _sum: RaceEthnicitySumAggregateOutputType | null
    _min: RaceEthnicityMinAggregateOutputType | null
    _max: RaceEthnicityMaxAggregateOutputType | null
  }

  type GetRaceEthnicityGroupByPayload<T extends RaceEthnicityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceEthnicityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceEthnicityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceEthnicityGroupByOutputType[P]>
            : GetScalarType<T[P], RaceEthnicityGroupByOutputType[P]>
        }
      >
    >


  export type RaceEthnicitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    white?: boolean
    hispanic?: boolean
    asian?: boolean
    black?: boolean
    other?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceEthnicity"]>

  export type RaceEthnicitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    white?: boolean
    hispanic?: boolean
    asian?: boolean
    black?: boolean
    other?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceEthnicity"]>

  export type RaceEthnicitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    white?: boolean
    hispanic?: boolean
    asian?: boolean
    black?: boolean
    other?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raceEthnicity"]>

  export type RaceEthnicitySelectScalar = {
    id?: boolean
    white?: boolean
    hispanic?: boolean
    asian?: boolean
    black?: boolean
    other?: boolean
    areaId?: boolean
  }

  export type RaceEthnicityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "white" | "hispanic" | "asian" | "black" | "other" | "areaId", ExtArgs["result"]["raceEthnicity"]>
  export type RaceEthnicityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type RaceEthnicityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type RaceEthnicityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $RaceEthnicityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaceEthnicity"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      white: number
      hispanic: number
      asian: number
      black: number
      other: number
      areaId: number
    }, ExtArgs["result"]["raceEthnicity"]>
    composites: {}
  }

  type RaceEthnicityGetPayload<S extends boolean | null | undefined | RaceEthnicityDefaultArgs> = $Result.GetResult<Prisma.$RaceEthnicityPayload, S>

  type RaceEthnicityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaceEthnicityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaceEthnicityCountAggregateInputType | true
    }

  export interface RaceEthnicityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaceEthnicity'], meta: { name: 'RaceEthnicity' } }
    /**
     * Find zero or one RaceEthnicity that matches the filter.
     * @param {RaceEthnicityFindUniqueArgs} args - Arguments to find a RaceEthnicity
     * @example
     * // Get one RaceEthnicity
     * const raceEthnicity = await prisma.raceEthnicity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceEthnicityFindUniqueArgs>(args: SelectSubset<T, RaceEthnicityFindUniqueArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaceEthnicity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaceEthnicityFindUniqueOrThrowArgs} args - Arguments to find a RaceEthnicity
     * @example
     * // Get one RaceEthnicity
     * const raceEthnicity = await prisma.raceEthnicity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceEthnicityFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceEthnicityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceEthnicity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceEthnicityFindFirstArgs} args - Arguments to find a RaceEthnicity
     * @example
     * // Get one RaceEthnicity
     * const raceEthnicity = await prisma.raceEthnicity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceEthnicityFindFirstArgs>(args?: SelectSubset<T, RaceEthnicityFindFirstArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaceEthnicity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceEthnicityFindFirstOrThrowArgs} args - Arguments to find a RaceEthnicity
     * @example
     * // Get one RaceEthnicity
     * const raceEthnicity = await prisma.raceEthnicity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceEthnicityFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceEthnicityFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaceEthnicities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceEthnicityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaceEthnicities
     * const raceEthnicities = await prisma.raceEthnicity.findMany()
     * 
     * // Get first 10 RaceEthnicities
     * const raceEthnicities = await prisma.raceEthnicity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceEthnicityWithIdOnly = await prisma.raceEthnicity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaceEthnicityFindManyArgs>(args?: SelectSubset<T, RaceEthnicityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaceEthnicity.
     * @param {RaceEthnicityCreateArgs} args - Arguments to create a RaceEthnicity.
     * @example
     * // Create one RaceEthnicity
     * const RaceEthnicity = await prisma.raceEthnicity.create({
     *   data: {
     *     // ... data to create a RaceEthnicity
     *   }
     * })
     * 
     */
    create<T extends RaceEthnicityCreateArgs>(args: SelectSubset<T, RaceEthnicityCreateArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaceEthnicities.
     * @param {RaceEthnicityCreateManyArgs} args - Arguments to create many RaceEthnicities.
     * @example
     * // Create many RaceEthnicities
     * const raceEthnicity = await prisma.raceEthnicity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceEthnicityCreateManyArgs>(args?: SelectSubset<T, RaceEthnicityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaceEthnicities and returns the data saved in the database.
     * @param {RaceEthnicityCreateManyAndReturnArgs} args - Arguments to create many RaceEthnicities.
     * @example
     * // Create many RaceEthnicities
     * const raceEthnicity = await prisma.raceEthnicity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaceEthnicities and only return the `id`
     * const raceEthnicityWithIdOnly = await prisma.raceEthnicity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceEthnicityCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceEthnicityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaceEthnicity.
     * @param {RaceEthnicityDeleteArgs} args - Arguments to delete one RaceEthnicity.
     * @example
     * // Delete one RaceEthnicity
     * const RaceEthnicity = await prisma.raceEthnicity.delete({
     *   where: {
     *     // ... filter to delete one RaceEthnicity
     *   }
     * })
     * 
     */
    delete<T extends RaceEthnicityDeleteArgs>(args: SelectSubset<T, RaceEthnicityDeleteArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaceEthnicity.
     * @param {RaceEthnicityUpdateArgs} args - Arguments to update one RaceEthnicity.
     * @example
     * // Update one RaceEthnicity
     * const raceEthnicity = await prisma.raceEthnicity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceEthnicityUpdateArgs>(args: SelectSubset<T, RaceEthnicityUpdateArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaceEthnicities.
     * @param {RaceEthnicityDeleteManyArgs} args - Arguments to filter RaceEthnicities to delete.
     * @example
     * // Delete a few RaceEthnicities
     * const { count } = await prisma.raceEthnicity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceEthnicityDeleteManyArgs>(args?: SelectSubset<T, RaceEthnicityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceEthnicities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceEthnicityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaceEthnicities
     * const raceEthnicity = await prisma.raceEthnicity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceEthnicityUpdateManyArgs>(args: SelectSubset<T, RaceEthnicityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaceEthnicities and returns the data updated in the database.
     * @param {RaceEthnicityUpdateManyAndReturnArgs} args - Arguments to update many RaceEthnicities.
     * @example
     * // Update many RaceEthnicities
     * const raceEthnicity = await prisma.raceEthnicity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaceEthnicities and only return the `id`
     * const raceEthnicityWithIdOnly = await prisma.raceEthnicity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaceEthnicityUpdateManyAndReturnArgs>(args: SelectSubset<T, RaceEthnicityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaceEthnicity.
     * @param {RaceEthnicityUpsertArgs} args - Arguments to update or create a RaceEthnicity.
     * @example
     * // Update or create a RaceEthnicity
     * const raceEthnicity = await prisma.raceEthnicity.upsert({
     *   create: {
     *     // ... data to create a RaceEthnicity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaceEthnicity we want to update
     *   }
     * })
     */
    upsert<T extends RaceEthnicityUpsertArgs>(args: SelectSubset<T, RaceEthnicityUpsertArgs<ExtArgs>>): Prisma__RaceEthnicityClient<$Result.GetResult<Prisma.$RaceEthnicityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaceEthnicities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceEthnicityCountArgs} args - Arguments to filter RaceEthnicities to count.
     * @example
     * // Count the number of RaceEthnicities
     * const count = await prisma.raceEthnicity.count({
     *   where: {
     *     // ... the filter for the RaceEthnicities we want to count
     *   }
     * })
    **/
    count<T extends RaceEthnicityCountArgs>(
      args?: Subset<T, RaceEthnicityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceEthnicityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaceEthnicity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceEthnicityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceEthnicityAggregateArgs>(args: Subset<T, RaceEthnicityAggregateArgs>): Prisma.PrismaPromise<GetRaceEthnicityAggregateType<T>>

    /**
     * Group by RaceEthnicity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceEthnicityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceEthnicityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceEthnicityGroupByArgs['orderBy'] }
        : { orderBy?: RaceEthnicityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceEthnicityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceEthnicityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaceEthnicity model
   */
  readonly fields: RaceEthnicityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaceEthnicity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceEthnicityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaceEthnicity model
   */
  interface RaceEthnicityFieldRefs {
    readonly id: FieldRef<"RaceEthnicity", 'Int'>
    readonly white: FieldRef<"RaceEthnicity", 'Float'>
    readonly hispanic: FieldRef<"RaceEthnicity", 'Float'>
    readonly asian: FieldRef<"RaceEthnicity", 'Float'>
    readonly black: FieldRef<"RaceEthnicity", 'Float'>
    readonly other: FieldRef<"RaceEthnicity", 'Float'>
    readonly areaId: FieldRef<"RaceEthnicity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaceEthnicity findUnique
   */
  export type RaceEthnicityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * Filter, which RaceEthnicity to fetch.
     */
    where: RaceEthnicityWhereUniqueInput
  }

  /**
   * RaceEthnicity findUniqueOrThrow
   */
  export type RaceEthnicityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * Filter, which RaceEthnicity to fetch.
     */
    where: RaceEthnicityWhereUniqueInput
  }

  /**
   * RaceEthnicity findFirst
   */
  export type RaceEthnicityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * Filter, which RaceEthnicity to fetch.
     */
    where?: RaceEthnicityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceEthnicities to fetch.
     */
    orderBy?: RaceEthnicityOrderByWithRelationInput | RaceEthnicityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceEthnicities.
     */
    cursor?: RaceEthnicityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceEthnicities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceEthnicities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceEthnicities.
     */
    distinct?: RaceEthnicityScalarFieldEnum | RaceEthnicityScalarFieldEnum[]
  }

  /**
   * RaceEthnicity findFirstOrThrow
   */
  export type RaceEthnicityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * Filter, which RaceEthnicity to fetch.
     */
    where?: RaceEthnicityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceEthnicities to fetch.
     */
    orderBy?: RaceEthnicityOrderByWithRelationInput | RaceEthnicityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaceEthnicities.
     */
    cursor?: RaceEthnicityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceEthnicities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceEthnicities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaceEthnicities.
     */
    distinct?: RaceEthnicityScalarFieldEnum | RaceEthnicityScalarFieldEnum[]
  }

  /**
   * RaceEthnicity findMany
   */
  export type RaceEthnicityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * Filter, which RaceEthnicities to fetch.
     */
    where?: RaceEthnicityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaceEthnicities to fetch.
     */
    orderBy?: RaceEthnicityOrderByWithRelationInput | RaceEthnicityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaceEthnicities.
     */
    cursor?: RaceEthnicityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaceEthnicities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaceEthnicities.
     */
    skip?: number
    distinct?: RaceEthnicityScalarFieldEnum | RaceEthnicityScalarFieldEnum[]
  }

  /**
   * RaceEthnicity create
   */
  export type RaceEthnicityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * The data needed to create a RaceEthnicity.
     */
    data: XOR<RaceEthnicityCreateInput, RaceEthnicityUncheckedCreateInput>
  }

  /**
   * RaceEthnicity createMany
   */
  export type RaceEthnicityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaceEthnicities.
     */
    data: RaceEthnicityCreateManyInput | RaceEthnicityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaceEthnicity createManyAndReturn
   */
  export type RaceEthnicityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * The data used to create many RaceEthnicities.
     */
    data: RaceEthnicityCreateManyInput | RaceEthnicityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceEthnicity update
   */
  export type RaceEthnicityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * The data needed to update a RaceEthnicity.
     */
    data: XOR<RaceEthnicityUpdateInput, RaceEthnicityUncheckedUpdateInput>
    /**
     * Choose, which RaceEthnicity to update.
     */
    where: RaceEthnicityWhereUniqueInput
  }

  /**
   * RaceEthnicity updateMany
   */
  export type RaceEthnicityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaceEthnicities.
     */
    data: XOR<RaceEthnicityUpdateManyMutationInput, RaceEthnicityUncheckedUpdateManyInput>
    /**
     * Filter which RaceEthnicities to update
     */
    where?: RaceEthnicityWhereInput
    /**
     * Limit how many RaceEthnicities to update.
     */
    limit?: number
  }

  /**
   * RaceEthnicity updateManyAndReturn
   */
  export type RaceEthnicityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * The data used to update RaceEthnicities.
     */
    data: XOR<RaceEthnicityUpdateManyMutationInput, RaceEthnicityUncheckedUpdateManyInput>
    /**
     * Filter which RaceEthnicities to update
     */
    where?: RaceEthnicityWhereInput
    /**
     * Limit how many RaceEthnicities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaceEthnicity upsert
   */
  export type RaceEthnicityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * The filter to search for the RaceEthnicity to update in case it exists.
     */
    where: RaceEthnicityWhereUniqueInput
    /**
     * In case the RaceEthnicity found by the `where` argument doesn't exist, create a new RaceEthnicity with this data.
     */
    create: XOR<RaceEthnicityCreateInput, RaceEthnicityUncheckedCreateInput>
    /**
     * In case the RaceEthnicity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceEthnicityUpdateInput, RaceEthnicityUncheckedUpdateInput>
  }

  /**
   * RaceEthnicity delete
   */
  export type RaceEthnicityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
    /**
     * Filter which RaceEthnicity to delete.
     */
    where: RaceEthnicityWhereUniqueInput
  }

  /**
   * RaceEthnicity deleteMany
   */
  export type RaceEthnicityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaceEthnicities to delete
     */
    where?: RaceEthnicityWhereInput
    /**
     * Limit how many RaceEthnicities to delete.
     */
    limit?: number
  }

  /**
   * RaceEthnicity without action
   */
  export type RaceEthnicityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceEthnicity
     */
    select?: RaceEthnicitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaceEthnicity
     */
    omit?: RaceEthnicityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceEthnicityInclude<ExtArgs> | null
  }


  /**
   * Model IncomeLevels
   */

  export type AggregateIncomeLevels = {
    _count: IncomeLevelsCountAggregateOutputType | null
    _avg: IncomeLevelsAvgAggregateOutputType | null
    _sum: IncomeLevelsSumAggregateOutputType | null
    _min: IncomeLevelsMinAggregateOutputType | null
    _max: IncomeLevelsMaxAggregateOutputType | null
  }

  export type IncomeLevelsAvgAggregateOutputType = {
    id: number | null
    perCapitaIncome: number | null
    medianHouseholdIncome: number | null
    areaId: number | null
  }

  export type IncomeLevelsSumAggregateOutputType = {
    id: number | null
    perCapitaIncome: number | null
    medianHouseholdIncome: number | null
    areaId: number | null
  }

  export type IncomeLevelsMinAggregateOutputType = {
    id: number | null
    perCapitaIncome: number | null
    medianHouseholdIncome: number | null
    areaId: number | null
  }

  export type IncomeLevelsMaxAggregateOutputType = {
    id: number | null
    perCapitaIncome: number | null
    medianHouseholdIncome: number | null
    areaId: number | null
  }

  export type IncomeLevelsCountAggregateOutputType = {
    id: number
    perCapitaIncome: number
    medianHouseholdIncome: number
    areaId: number
    _all: number
  }


  export type IncomeLevelsAvgAggregateInputType = {
    id?: true
    perCapitaIncome?: true
    medianHouseholdIncome?: true
    areaId?: true
  }

  export type IncomeLevelsSumAggregateInputType = {
    id?: true
    perCapitaIncome?: true
    medianHouseholdIncome?: true
    areaId?: true
  }

  export type IncomeLevelsMinAggregateInputType = {
    id?: true
    perCapitaIncome?: true
    medianHouseholdIncome?: true
    areaId?: true
  }

  export type IncomeLevelsMaxAggregateInputType = {
    id?: true
    perCapitaIncome?: true
    medianHouseholdIncome?: true
    areaId?: true
  }

  export type IncomeLevelsCountAggregateInputType = {
    id?: true
    perCapitaIncome?: true
    medianHouseholdIncome?: true
    areaId?: true
    _all?: true
  }

  export type IncomeLevelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeLevels to aggregate.
     */
    where?: IncomeLevelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeLevels to fetch.
     */
    orderBy?: IncomeLevelsOrderByWithRelationInput | IncomeLevelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomeLevelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomeLevels
    **/
    _count?: true | IncomeLevelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomeLevelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomeLevelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeLevelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeLevelsMaxAggregateInputType
  }

  export type GetIncomeLevelsAggregateType<T extends IncomeLevelsAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomeLevels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomeLevels[P]>
      : GetScalarType<T[P], AggregateIncomeLevels[P]>
  }




  export type IncomeLevelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeLevelsWhereInput
    orderBy?: IncomeLevelsOrderByWithAggregationInput | IncomeLevelsOrderByWithAggregationInput[]
    by: IncomeLevelsScalarFieldEnum[] | IncomeLevelsScalarFieldEnum
    having?: IncomeLevelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeLevelsCountAggregateInputType | true
    _avg?: IncomeLevelsAvgAggregateInputType
    _sum?: IncomeLevelsSumAggregateInputType
    _min?: IncomeLevelsMinAggregateInputType
    _max?: IncomeLevelsMaxAggregateInputType
  }

  export type IncomeLevelsGroupByOutputType = {
    id: number
    perCapitaIncome: number
    medianHouseholdIncome: number
    areaId: number
    _count: IncomeLevelsCountAggregateOutputType | null
    _avg: IncomeLevelsAvgAggregateOutputType | null
    _sum: IncomeLevelsSumAggregateOutputType | null
    _min: IncomeLevelsMinAggregateOutputType | null
    _max: IncomeLevelsMaxAggregateOutputType | null
  }

  type GetIncomeLevelsGroupByPayload<T extends IncomeLevelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomeLevelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomeLevelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomeLevelsGroupByOutputType[P]>
            : GetScalarType<T[P], IncomeLevelsGroupByOutputType[P]>
        }
      >
    >


  export type IncomeLevelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    perCapitaIncome?: boolean
    medianHouseholdIncome?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomeLevels"]>

  export type IncomeLevelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    perCapitaIncome?: boolean
    medianHouseholdIncome?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomeLevels"]>

  export type IncomeLevelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    perCapitaIncome?: boolean
    medianHouseholdIncome?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomeLevels"]>

  export type IncomeLevelsSelectScalar = {
    id?: boolean
    perCapitaIncome?: boolean
    medianHouseholdIncome?: boolean
    areaId?: boolean
  }

  export type IncomeLevelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "perCapitaIncome" | "medianHouseholdIncome" | "areaId", ExtArgs["result"]["incomeLevels"]>
  export type IncomeLevelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type IncomeLevelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type IncomeLevelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $IncomeLevelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncomeLevels"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      perCapitaIncome: number
      medianHouseholdIncome: number
      areaId: number
    }, ExtArgs["result"]["incomeLevels"]>
    composites: {}
  }

  type IncomeLevelsGetPayload<S extends boolean | null | undefined | IncomeLevelsDefaultArgs> = $Result.GetResult<Prisma.$IncomeLevelsPayload, S>

  type IncomeLevelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncomeLevelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncomeLevelsCountAggregateInputType | true
    }

  export interface IncomeLevelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncomeLevels'], meta: { name: 'IncomeLevels' } }
    /**
     * Find zero or one IncomeLevels that matches the filter.
     * @param {IncomeLevelsFindUniqueArgs} args - Arguments to find a IncomeLevels
     * @example
     * // Get one IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomeLevelsFindUniqueArgs>(args: SelectSubset<T, IncomeLevelsFindUniqueArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IncomeLevels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncomeLevelsFindUniqueOrThrowArgs} args - Arguments to find a IncomeLevels
     * @example
     * // Get one IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomeLevelsFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomeLevelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncomeLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeLevelsFindFirstArgs} args - Arguments to find a IncomeLevels
     * @example
     * // Get one IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomeLevelsFindFirstArgs>(args?: SelectSubset<T, IncomeLevelsFindFirstArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncomeLevels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeLevelsFindFirstOrThrowArgs} args - Arguments to find a IncomeLevels
     * @example
     * // Get one IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomeLevelsFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomeLevelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IncomeLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeLevelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.findMany()
     * 
     * // Get first 10 IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeLevelsWithIdOnly = await prisma.incomeLevels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomeLevelsFindManyArgs>(args?: SelectSubset<T, IncomeLevelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IncomeLevels.
     * @param {IncomeLevelsCreateArgs} args - Arguments to create a IncomeLevels.
     * @example
     * // Create one IncomeLevels
     * const IncomeLevels = await prisma.incomeLevels.create({
     *   data: {
     *     // ... data to create a IncomeLevels
     *   }
     * })
     * 
     */
    create<T extends IncomeLevelsCreateArgs>(args: SelectSubset<T, IncomeLevelsCreateArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IncomeLevels.
     * @param {IncomeLevelsCreateManyArgs} args - Arguments to create many IncomeLevels.
     * @example
     * // Create many IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomeLevelsCreateManyArgs>(args?: SelectSubset<T, IncomeLevelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncomeLevels and returns the data saved in the database.
     * @param {IncomeLevelsCreateManyAndReturnArgs} args - Arguments to create many IncomeLevels.
     * @example
     * // Create many IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncomeLevels and only return the `id`
     * const incomeLevelsWithIdOnly = await prisma.incomeLevels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncomeLevelsCreateManyAndReturnArgs>(args?: SelectSubset<T, IncomeLevelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IncomeLevels.
     * @param {IncomeLevelsDeleteArgs} args - Arguments to delete one IncomeLevels.
     * @example
     * // Delete one IncomeLevels
     * const IncomeLevels = await prisma.incomeLevels.delete({
     *   where: {
     *     // ... filter to delete one IncomeLevels
     *   }
     * })
     * 
     */
    delete<T extends IncomeLevelsDeleteArgs>(args: SelectSubset<T, IncomeLevelsDeleteArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IncomeLevels.
     * @param {IncomeLevelsUpdateArgs} args - Arguments to update one IncomeLevels.
     * @example
     * // Update one IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomeLevelsUpdateArgs>(args: SelectSubset<T, IncomeLevelsUpdateArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IncomeLevels.
     * @param {IncomeLevelsDeleteManyArgs} args - Arguments to filter IncomeLevels to delete.
     * @example
     * // Delete a few IncomeLevels
     * const { count } = await prisma.incomeLevels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomeLevelsDeleteManyArgs>(args?: SelectSubset<T, IncomeLevelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomeLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeLevelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomeLevelsUpdateManyArgs>(args: SelectSubset<T, IncomeLevelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomeLevels and returns the data updated in the database.
     * @param {IncomeLevelsUpdateManyAndReturnArgs} args - Arguments to update many IncomeLevels.
     * @example
     * // Update many IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IncomeLevels and only return the `id`
     * const incomeLevelsWithIdOnly = await prisma.incomeLevels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncomeLevelsUpdateManyAndReturnArgs>(args: SelectSubset<T, IncomeLevelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IncomeLevels.
     * @param {IncomeLevelsUpsertArgs} args - Arguments to update or create a IncomeLevels.
     * @example
     * // Update or create a IncomeLevels
     * const incomeLevels = await prisma.incomeLevels.upsert({
     *   create: {
     *     // ... data to create a IncomeLevels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomeLevels we want to update
     *   }
     * })
     */
    upsert<T extends IncomeLevelsUpsertArgs>(args: SelectSubset<T, IncomeLevelsUpsertArgs<ExtArgs>>): Prisma__IncomeLevelsClient<$Result.GetResult<Prisma.$IncomeLevelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IncomeLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeLevelsCountArgs} args - Arguments to filter IncomeLevels to count.
     * @example
     * // Count the number of IncomeLevels
     * const count = await prisma.incomeLevels.count({
     *   where: {
     *     // ... the filter for the IncomeLevels we want to count
     *   }
     * })
    **/
    count<T extends IncomeLevelsCountArgs>(
      args?: Subset<T, IncomeLevelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeLevelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomeLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeLevelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeLevelsAggregateArgs>(args: Subset<T, IncomeLevelsAggregateArgs>): Prisma.PrismaPromise<GetIncomeLevelsAggregateType<T>>

    /**
     * Group by IncomeLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeLevelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeLevelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeLevelsGroupByArgs['orderBy'] }
        : { orderBy?: IncomeLevelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeLevelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeLevelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncomeLevels model
   */
  readonly fields: IncomeLevelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomeLevels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomeLevelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncomeLevels model
   */
  interface IncomeLevelsFieldRefs {
    readonly id: FieldRef<"IncomeLevels", 'Int'>
    readonly perCapitaIncome: FieldRef<"IncomeLevels", 'Float'>
    readonly medianHouseholdIncome: FieldRef<"IncomeLevels", 'Float'>
    readonly areaId: FieldRef<"IncomeLevels", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * IncomeLevels findUnique
   */
  export type IncomeLevelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeLevels to fetch.
     */
    where: IncomeLevelsWhereUniqueInput
  }

  /**
   * IncomeLevels findUniqueOrThrow
   */
  export type IncomeLevelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeLevels to fetch.
     */
    where: IncomeLevelsWhereUniqueInput
  }

  /**
   * IncomeLevels findFirst
   */
  export type IncomeLevelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeLevels to fetch.
     */
    where?: IncomeLevelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeLevels to fetch.
     */
    orderBy?: IncomeLevelsOrderByWithRelationInput | IncomeLevelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeLevels.
     */
    cursor?: IncomeLevelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeLevels.
     */
    distinct?: IncomeLevelsScalarFieldEnum | IncomeLevelsScalarFieldEnum[]
  }

  /**
   * IncomeLevels findFirstOrThrow
   */
  export type IncomeLevelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeLevels to fetch.
     */
    where?: IncomeLevelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeLevels to fetch.
     */
    orderBy?: IncomeLevelsOrderByWithRelationInput | IncomeLevelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeLevels.
     */
    cursor?: IncomeLevelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeLevels.
     */
    distinct?: IncomeLevelsScalarFieldEnum | IncomeLevelsScalarFieldEnum[]
  }

  /**
   * IncomeLevels findMany
   */
  export type IncomeLevelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * Filter, which IncomeLevels to fetch.
     */
    where?: IncomeLevelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeLevels to fetch.
     */
    orderBy?: IncomeLevelsOrderByWithRelationInput | IncomeLevelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomeLevels.
     */
    cursor?: IncomeLevelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeLevels.
     */
    skip?: number
    distinct?: IncomeLevelsScalarFieldEnum | IncomeLevelsScalarFieldEnum[]
  }

  /**
   * IncomeLevels create
   */
  export type IncomeLevelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * The data needed to create a IncomeLevels.
     */
    data: XOR<IncomeLevelsCreateInput, IncomeLevelsUncheckedCreateInput>
  }

  /**
   * IncomeLevels createMany
   */
  export type IncomeLevelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncomeLevels.
     */
    data: IncomeLevelsCreateManyInput | IncomeLevelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncomeLevels createManyAndReturn
   */
  export type IncomeLevelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * The data used to create many IncomeLevels.
     */
    data: IncomeLevelsCreateManyInput | IncomeLevelsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncomeLevels update
   */
  export type IncomeLevelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * The data needed to update a IncomeLevels.
     */
    data: XOR<IncomeLevelsUpdateInput, IncomeLevelsUncheckedUpdateInput>
    /**
     * Choose, which IncomeLevels to update.
     */
    where: IncomeLevelsWhereUniqueInput
  }

  /**
   * IncomeLevels updateMany
   */
  export type IncomeLevelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncomeLevels.
     */
    data: XOR<IncomeLevelsUpdateManyMutationInput, IncomeLevelsUncheckedUpdateManyInput>
    /**
     * Filter which IncomeLevels to update
     */
    where?: IncomeLevelsWhereInput
    /**
     * Limit how many IncomeLevels to update.
     */
    limit?: number
  }

  /**
   * IncomeLevels updateManyAndReturn
   */
  export type IncomeLevelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * The data used to update IncomeLevels.
     */
    data: XOR<IncomeLevelsUpdateManyMutationInput, IncomeLevelsUncheckedUpdateManyInput>
    /**
     * Filter which IncomeLevels to update
     */
    where?: IncomeLevelsWhereInput
    /**
     * Limit how many IncomeLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncomeLevels upsert
   */
  export type IncomeLevelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * The filter to search for the IncomeLevels to update in case it exists.
     */
    where: IncomeLevelsWhereUniqueInput
    /**
     * In case the IncomeLevels found by the `where` argument doesn't exist, create a new IncomeLevels with this data.
     */
    create: XOR<IncomeLevelsCreateInput, IncomeLevelsUncheckedCreateInput>
    /**
     * In case the IncomeLevels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomeLevelsUpdateInput, IncomeLevelsUncheckedUpdateInput>
  }

  /**
   * IncomeLevels delete
   */
  export type IncomeLevelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
    /**
     * Filter which IncomeLevels to delete.
     */
    where: IncomeLevelsWhereUniqueInput
  }

  /**
   * IncomeLevels deleteMany
   */
  export type IncomeLevelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeLevels to delete
     */
    where?: IncomeLevelsWhereInput
    /**
     * Limit how many IncomeLevels to delete.
     */
    limit?: number
  }

  /**
   * IncomeLevels without action
   */
  export type IncomeLevelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeLevels
     */
    select?: IncomeLevelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeLevels
     */
    omit?: IncomeLevelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomeLevelsInclude<ExtArgs> | null
  }


  /**
   * Model CrimeData
   */

  export type AggregateCrimeData = {
    _count: CrimeDataCountAggregateOutputType | null
    _avg: CrimeDataAvgAggregateOutputType | null
    _sum: CrimeDataSumAggregateOutputType | null
    _min: CrimeDataMinAggregateOutputType | null
    _max: CrimeDataMaxAggregateOutputType | null
  }

  export type CrimeDataAvgAggregateOutputType = {
    id: number | null
    violentCrimes: number | null
    propertyCrimes: number | null
    totalCrimes: number | null
    violentRate: number | null
    propertyRate: number | null
    totalRate: number | null
    areaId: number | null
  }

  export type CrimeDataSumAggregateOutputType = {
    id: number | null
    violentCrimes: number | null
    propertyCrimes: number | null
    totalCrimes: number | null
    violentRate: number | null
    propertyRate: number | null
    totalRate: number | null
    areaId: number | null
  }

  export type CrimeDataMinAggregateOutputType = {
    id: number | null
    violentCrimes: number | null
    propertyCrimes: number | null
    totalCrimes: number | null
    violentRate: number | null
    propertyRate: number | null
    totalRate: number | null
    areaId: number | null
  }

  export type CrimeDataMaxAggregateOutputType = {
    id: number | null
    violentCrimes: number | null
    propertyCrimes: number | null
    totalCrimes: number | null
    violentRate: number | null
    propertyRate: number | null
    totalRate: number | null
    areaId: number | null
  }

  export type CrimeDataCountAggregateOutputType = {
    id: number
    violentCrimes: number
    propertyCrimes: number
    totalCrimes: number
    violentRate: number
    propertyRate: number
    totalRate: number
    areaId: number
    _all: number
  }


  export type CrimeDataAvgAggregateInputType = {
    id?: true
    violentCrimes?: true
    propertyCrimes?: true
    totalCrimes?: true
    violentRate?: true
    propertyRate?: true
    totalRate?: true
    areaId?: true
  }

  export type CrimeDataSumAggregateInputType = {
    id?: true
    violentCrimes?: true
    propertyCrimes?: true
    totalCrimes?: true
    violentRate?: true
    propertyRate?: true
    totalRate?: true
    areaId?: true
  }

  export type CrimeDataMinAggregateInputType = {
    id?: true
    violentCrimes?: true
    propertyCrimes?: true
    totalCrimes?: true
    violentRate?: true
    propertyRate?: true
    totalRate?: true
    areaId?: true
  }

  export type CrimeDataMaxAggregateInputType = {
    id?: true
    violentCrimes?: true
    propertyCrimes?: true
    totalCrimes?: true
    violentRate?: true
    propertyRate?: true
    totalRate?: true
    areaId?: true
  }

  export type CrimeDataCountAggregateInputType = {
    id?: true
    violentCrimes?: true
    propertyCrimes?: true
    totalCrimes?: true
    violentRate?: true
    propertyRate?: true
    totalRate?: true
    areaId?: true
    _all?: true
  }

  export type CrimeDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrimeData to aggregate.
     */
    where?: CrimeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrimeData to fetch.
     */
    orderBy?: CrimeDataOrderByWithRelationInput | CrimeDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrimeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrimeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrimeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrimeData
    **/
    _count?: true | CrimeDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrimeDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrimeDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrimeDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrimeDataMaxAggregateInputType
  }

  export type GetCrimeDataAggregateType<T extends CrimeDataAggregateArgs> = {
        [P in keyof T & keyof AggregateCrimeData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrimeData[P]>
      : GetScalarType<T[P], AggregateCrimeData[P]>
  }




  export type CrimeDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrimeDataWhereInput
    orderBy?: CrimeDataOrderByWithAggregationInput | CrimeDataOrderByWithAggregationInput[]
    by: CrimeDataScalarFieldEnum[] | CrimeDataScalarFieldEnum
    having?: CrimeDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrimeDataCountAggregateInputType | true
    _avg?: CrimeDataAvgAggregateInputType
    _sum?: CrimeDataSumAggregateInputType
    _min?: CrimeDataMinAggregateInputType
    _max?: CrimeDataMaxAggregateInputType
  }

  export type CrimeDataGroupByOutputType = {
    id: number
    violentCrimes: number
    propertyCrimes: number
    totalCrimes: number
    violentRate: number
    propertyRate: number
    totalRate: number
    areaId: number
    _count: CrimeDataCountAggregateOutputType | null
    _avg: CrimeDataAvgAggregateOutputType | null
    _sum: CrimeDataSumAggregateOutputType | null
    _min: CrimeDataMinAggregateOutputType | null
    _max: CrimeDataMaxAggregateOutputType | null
  }

  type GetCrimeDataGroupByPayload<T extends CrimeDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrimeDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrimeDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrimeDataGroupByOutputType[P]>
            : GetScalarType<T[P], CrimeDataGroupByOutputType[P]>
        }
      >
    >


  export type CrimeDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    violentCrimes?: boolean
    propertyCrimes?: boolean
    totalCrimes?: boolean
    violentRate?: boolean
    propertyRate?: boolean
    totalRate?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crimeData"]>

  export type CrimeDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    violentCrimes?: boolean
    propertyCrimes?: boolean
    totalCrimes?: boolean
    violentRate?: boolean
    propertyRate?: boolean
    totalRate?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crimeData"]>

  export type CrimeDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    violentCrimes?: boolean
    propertyCrimes?: boolean
    totalCrimes?: boolean
    violentRate?: boolean
    propertyRate?: boolean
    totalRate?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crimeData"]>

  export type CrimeDataSelectScalar = {
    id?: boolean
    violentCrimes?: boolean
    propertyCrimes?: boolean
    totalCrimes?: boolean
    violentRate?: boolean
    propertyRate?: boolean
    totalRate?: boolean
    areaId?: boolean
  }

  export type CrimeDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "violentCrimes" | "propertyCrimes" | "totalCrimes" | "violentRate" | "propertyRate" | "totalRate" | "areaId", ExtArgs["result"]["crimeData"]>
  export type CrimeDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type CrimeDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type CrimeDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $CrimeDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrimeData"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      violentCrimes: number
      propertyCrimes: number
      totalCrimes: number
      violentRate: number
      propertyRate: number
      totalRate: number
      areaId: number
    }, ExtArgs["result"]["crimeData"]>
    composites: {}
  }

  type CrimeDataGetPayload<S extends boolean | null | undefined | CrimeDataDefaultArgs> = $Result.GetResult<Prisma.$CrimeDataPayload, S>

  type CrimeDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrimeDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrimeDataCountAggregateInputType | true
    }

  export interface CrimeDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrimeData'], meta: { name: 'CrimeData' } }
    /**
     * Find zero or one CrimeData that matches the filter.
     * @param {CrimeDataFindUniqueArgs} args - Arguments to find a CrimeData
     * @example
     * // Get one CrimeData
     * const crimeData = await prisma.crimeData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrimeDataFindUniqueArgs>(args: SelectSubset<T, CrimeDataFindUniqueArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrimeData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrimeDataFindUniqueOrThrowArgs} args - Arguments to find a CrimeData
     * @example
     * // Get one CrimeData
     * const crimeData = await prisma.crimeData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrimeDataFindUniqueOrThrowArgs>(args: SelectSubset<T, CrimeDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrimeData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrimeDataFindFirstArgs} args - Arguments to find a CrimeData
     * @example
     * // Get one CrimeData
     * const crimeData = await prisma.crimeData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrimeDataFindFirstArgs>(args?: SelectSubset<T, CrimeDataFindFirstArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrimeData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrimeDataFindFirstOrThrowArgs} args - Arguments to find a CrimeData
     * @example
     * // Get one CrimeData
     * const crimeData = await prisma.crimeData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrimeDataFindFirstOrThrowArgs>(args?: SelectSubset<T, CrimeDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrimeData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrimeDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrimeData
     * const crimeData = await prisma.crimeData.findMany()
     * 
     * // Get first 10 CrimeData
     * const crimeData = await prisma.crimeData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crimeDataWithIdOnly = await prisma.crimeData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrimeDataFindManyArgs>(args?: SelectSubset<T, CrimeDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrimeData.
     * @param {CrimeDataCreateArgs} args - Arguments to create a CrimeData.
     * @example
     * // Create one CrimeData
     * const CrimeData = await prisma.crimeData.create({
     *   data: {
     *     // ... data to create a CrimeData
     *   }
     * })
     * 
     */
    create<T extends CrimeDataCreateArgs>(args: SelectSubset<T, CrimeDataCreateArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrimeData.
     * @param {CrimeDataCreateManyArgs} args - Arguments to create many CrimeData.
     * @example
     * // Create many CrimeData
     * const crimeData = await prisma.crimeData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrimeDataCreateManyArgs>(args?: SelectSubset<T, CrimeDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrimeData and returns the data saved in the database.
     * @param {CrimeDataCreateManyAndReturnArgs} args - Arguments to create many CrimeData.
     * @example
     * // Create many CrimeData
     * const crimeData = await prisma.crimeData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrimeData and only return the `id`
     * const crimeDataWithIdOnly = await prisma.crimeData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrimeDataCreateManyAndReturnArgs>(args?: SelectSubset<T, CrimeDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrimeData.
     * @param {CrimeDataDeleteArgs} args - Arguments to delete one CrimeData.
     * @example
     * // Delete one CrimeData
     * const CrimeData = await prisma.crimeData.delete({
     *   where: {
     *     // ... filter to delete one CrimeData
     *   }
     * })
     * 
     */
    delete<T extends CrimeDataDeleteArgs>(args: SelectSubset<T, CrimeDataDeleteArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrimeData.
     * @param {CrimeDataUpdateArgs} args - Arguments to update one CrimeData.
     * @example
     * // Update one CrimeData
     * const crimeData = await prisma.crimeData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrimeDataUpdateArgs>(args: SelectSubset<T, CrimeDataUpdateArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrimeData.
     * @param {CrimeDataDeleteManyArgs} args - Arguments to filter CrimeData to delete.
     * @example
     * // Delete a few CrimeData
     * const { count } = await prisma.crimeData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrimeDataDeleteManyArgs>(args?: SelectSubset<T, CrimeDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrimeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrimeDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrimeData
     * const crimeData = await prisma.crimeData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrimeDataUpdateManyArgs>(args: SelectSubset<T, CrimeDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrimeData and returns the data updated in the database.
     * @param {CrimeDataUpdateManyAndReturnArgs} args - Arguments to update many CrimeData.
     * @example
     * // Update many CrimeData
     * const crimeData = await prisma.crimeData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrimeData and only return the `id`
     * const crimeDataWithIdOnly = await prisma.crimeData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrimeDataUpdateManyAndReturnArgs>(args: SelectSubset<T, CrimeDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrimeData.
     * @param {CrimeDataUpsertArgs} args - Arguments to update or create a CrimeData.
     * @example
     * // Update or create a CrimeData
     * const crimeData = await prisma.crimeData.upsert({
     *   create: {
     *     // ... data to create a CrimeData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrimeData we want to update
     *   }
     * })
     */
    upsert<T extends CrimeDataUpsertArgs>(args: SelectSubset<T, CrimeDataUpsertArgs<ExtArgs>>): Prisma__CrimeDataClient<$Result.GetResult<Prisma.$CrimeDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrimeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrimeDataCountArgs} args - Arguments to filter CrimeData to count.
     * @example
     * // Count the number of CrimeData
     * const count = await prisma.crimeData.count({
     *   where: {
     *     // ... the filter for the CrimeData we want to count
     *   }
     * })
    **/
    count<T extends CrimeDataCountArgs>(
      args?: Subset<T, CrimeDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrimeDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrimeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrimeDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrimeDataAggregateArgs>(args: Subset<T, CrimeDataAggregateArgs>): Prisma.PrismaPromise<GetCrimeDataAggregateType<T>>

    /**
     * Group by CrimeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrimeDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrimeDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrimeDataGroupByArgs['orderBy'] }
        : { orderBy?: CrimeDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrimeDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrimeDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrimeData model
   */
  readonly fields: CrimeDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrimeData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrimeDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrimeData model
   */
  interface CrimeDataFieldRefs {
    readonly id: FieldRef<"CrimeData", 'Int'>
    readonly violentCrimes: FieldRef<"CrimeData", 'Int'>
    readonly propertyCrimes: FieldRef<"CrimeData", 'Int'>
    readonly totalCrimes: FieldRef<"CrimeData", 'Int'>
    readonly violentRate: FieldRef<"CrimeData", 'Float'>
    readonly propertyRate: FieldRef<"CrimeData", 'Float'>
    readonly totalRate: FieldRef<"CrimeData", 'Float'>
    readonly areaId: FieldRef<"CrimeData", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CrimeData findUnique
   */
  export type CrimeDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * Filter, which CrimeData to fetch.
     */
    where: CrimeDataWhereUniqueInput
  }

  /**
   * CrimeData findUniqueOrThrow
   */
  export type CrimeDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * Filter, which CrimeData to fetch.
     */
    where: CrimeDataWhereUniqueInput
  }

  /**
   * CrimeData findFirst
   */
  export type CrimeDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * Filter, which CrimeData to fetch.
     */
    where?: CrimeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrimeData to fetch.
     */
    orderBy?: CrimeDataOrderByWithRelationInput | CrimeDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrimeData.
     */
    cursor?: CrimeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrimeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrimeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrimeData.
     */
    distinct?: CrimeDataScalarFieldEnum | CrimeDataScalarFieldEnum[]
  }

  /**
   * CrimeData findFirstOrThrow
   */
  export type CrimeDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * Filter, which CrimeData to fetch.
     */
    where?: CrimeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrimeData to fetch.
     */
    orderBy?: CrimeDataOrderByWithRelationInput | CrimeDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrimeData.
     */
    cursor?: CrimeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrimeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrimeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrimeData.
     */
    distinct?: CrimeDataScalarFieldEnum | CrimeDataScalarFieldEnum[]
  }

  /**
   * CrimeData findMany
   */
  export type CrimeDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * Filter, which CrimeData to fetch.
     */
    where?: CrimeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrimeData to fetch.
     */
    orderBy?: CrimeDataOrderByWithRelationInput | CrimeDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrimeData.
     */
    cursor?: CrimeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrimeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrimeData.
     */
    skip?: number
    distinct?: CrimeDataScalarFieldEnum | CrimeDataScalarFieldEnum[]
  }

  /**
   * CrimeData create
   */
  export type CrimeDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * The data needed to create a CrimeData.
     */
    data: XOR<CrimeDataCreateInput, CrimeDataUncheckedCreateInput>
  }

  /**
   * CrimeData createMany
   */
  export type CrimeDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrimeData.
     */
    data: CrimeDataCreateManyInput | CrimeDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrimeData createManyAndReturn
   */
  export type CrimeDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * The data used to create many CrimeData.
     */
    data: CrimeDataCreateManyInput | CrimeDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrimeData update
   */
  export type CrimeDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * The data needed to update a CrimeData.
     */
    data: XOR<CrimeDataUpdateInput, CrimeDataUncheckedUpdateInput>
    /**
     * Choose, which CrimeData to update.
     */
    where: CrimeDataWhereUniqueInput
  }

  /**
   * CrimeData updateMany
   */
  export type CrimeDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrimeData.
     */
    data: XOR<CrimeDataUpdateManyMutationInput, CrimeDataUncheckedUpdateManyInput>
    /**
     * Filter which CrimeData to update
     */
    where?: CrimeDataWhereInput
    /**
     * Limit how many CrimeData to update.
     */
    limit?: number
  }

  /**
   * CrimeData updateManyAndReturn
   */
  export type CrimeDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * The data used to update CrimeData.
     */
    data: XOR<CrimeDataUpdateManyMutationInput, CrimeDataUncheckedUpdateManyInput>
    /**
     * Filter which CrimeData to update
     */
    where?: CrimeDataWhereInput
    /**
     * Limit how many CrimeData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrimeData upsert
   */
  export type CrimeDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * The filter to search for the CrimeData to update in case it exists.
     */
    where: CrimeDataWhereUniqueInput
    /**
     * In case the CrimeData found by the `where` argument doesn't exist, create a new CrimeData with this data.
     */
    create: XOR<CrimeDataCreateInput, CrimeDataUncheckedCreateInput>
    /**
     * In case the CrimeData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrimeDataUpdateInput, CrimeDataUncheckedUpdateInput>
  }

  /**
   * CrimeData delete
   */
  export type CrimeDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
    /**
     * Filter which CrimeData to delete.
     */
    where: CrimeDataWhereUniqueInput
  }

  /**
   * CrimeData deleteMany
   */
  export type CrimeDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrimeData to delete
     */
    where?: CrimeDataWhereInput
    /**
     * Limit how many CrimeData to delete.
     */
    limit?: number
  }

  /**
   * CrimeData without action
   */
  export type CrimeDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrimeData
     */
    select?: CrimeDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrimeData
     */
    omit?: CrimeDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrimeDataInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type SchoolSumAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type SchoolMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fullDescription: number
    imageUrl: number
    website: number
    areaId: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type SchoolSumAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: number
    name: string
    description: string
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "fullDescription" | "imageUrl" | "website" | "areaId", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      fullDescription: string | null
      imageUrl: string | null
      website: string | null
      areaId: number
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'Int'>
    readonly name: FieldRef<"School", 'String'>
    readonly description: FieldRef<"School", 'String'>
    readonly fullDescription: FieldRef<"School", 'String'>
    readonly imageUrl: FieldRef<"School", 'String'>
    readonly website: FieldRef<"School", 'String'>
    readonly areaId: FieldRef<"School", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model SocialLife
   */

  export type AggregateSocialLife = {
    _count: SocialLifeCountAggregateOutputType | null
    _avg: SocialLifeAvgAggregateOutputType | null
    _sum: SocialLifeSumAggregateOutputType | null
    _min: SocialLifeMinAggregateOutputType | null
    _max: SocialLifeMaxAggregateOutputType | null
  }

  export type SocialLifeAvgAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type SocialLifeSumAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type SocialLifeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type SocialLifeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type SocialLifeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fullDescription: number
    imageUrl: number
    website: number
    areaId: number
    _all: number
  }


  export type SocialLifeAvgAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type SocialLifeSumAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type SocialLifeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type SocialLifeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type SocialLifeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
    _all?: true
  }

  export type SocialLifeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLife to aggregate.
     */
    where?: SocialLifeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLives to fetch.
     */
    orderBy?: SocialLifeOrderByWithRelationInput | SocialLifeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialLifeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialLives
    **/
    _count?: true | SocialLifeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialLifeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialLifeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLifeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLifeMaxAggregateInputType
  }

  export type GetSocialLifeAggregateType<T extends SocialLifeAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLife]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLife[P]>
      : GetScalarType<T[P], AggregateSocialLife[P]>
  }




  export type SocialLifeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLifeWhereInput
    orderBy?: SocialLifeOrderByWithAggregationInput | SocialLifeOrderByWithAggregationInput[]
    by: SocialLifeScalarFieldEnum[] | SocialLifeScalarFieldEnum
    having?: SocialLifeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLifeCountAggregateInputType | true
    _avg?: SocialLifeAvgAggregateInputType
    _sum?: SocialLifeSumAggregateInputType
    _min?: SocialLifeMinAggregateInputType
    _max?: SocialLifeMaxAggregateInputType
  }

  export type SocialLifeGroupByOutputType = {
    id: number
    name: string
    description: string
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number
    _count: SocialLifeCountAggregateOutputType | null
    _avg: SocialLifeAvgAggregateOutputType | null
    _sum: SocialLifeSumAggregateOutputType | null
    _min: SocialLifeMinAggregateOutputType | null
    _max: SocialLifeMaxAggregateOutputType | null
  }

  type GetSocialLifeGroupByPayload<T extends SocialLifeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialLifeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLifeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLifeGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLifeGroupByOutputType[P]>
        }
      >
    >


  export type SocialLifeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialLife"]>

  export type SocialLifeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialLife"]>

  export type SocialLifeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialLife"]>

  export type SocialLifeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
  }

  export type SocialLifeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "fullDescription" | "imageUrl" | "website" | "areaId", ExtArgs["result"]["socialLife"]>
  export type SocialLifeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type SocialLifeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type SocialLifeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $SocialLifePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialLife"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      fullDescription: string | null
      imageUrl: string | null
      website: string | null
      areaId: number
    }, ExtArgs["result"]["socialLife"]>
    composites: {}
  }

  type SocialLifeGetPayload<S extends boolean | null | undefined | SocialLifeDefaultArgs> = $Result.GetResult<Prisma.$SocialLifePayload, S>

  type SocialLifeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialLifeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialLifeCountAggregateInputType | true
    }

  export interface SocialLifeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialLife'], meta: { name: 'SocialLife' } }
    /**
     * Find zero or one SocialLife that matches the filter.
     * @param {SocialLifeFindUniqueArgs} args - Arguments to find a SocialLife
     * @example
     * // Get one SocialLife
     * const socialLife = await prisma.socialLife.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialLifeFindUniqueArgs>(args: SelectSubset<T, SocialLifeFindUniqueArgs<ExtArgs>>): Prisma__SocialLifeClient<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialLife that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialLifeFindUniqueOrThrowArgs} args - Arguments to find a SocialLife
     * @example
     * // Get one SocialLife
     * const socialLife = await prisma.socialLife.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialLifeFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialLifeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialLifeClient<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLife that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLifeFindFirstArgs} args - Arguments to find a SocialLife
     * @example
     * // Get one SocialLife
     * const socialLife = await prisma.socialLife.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialLifeFindFirstArgs>(args?: SelectSubset<T, SocialLifeFindFirstArgs<ExtArgs>>): Prisma__SocialLifeClient<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLife that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLifeFindFirstOrThrowArgs} args - Arguments to find a SocialLife
     * @example
     * // Get one SocialLife
     * const socialLife = await prisma.socialLife.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialLifeFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialLifeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialLifeClient<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialLives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLifeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLives
     * const socialLives = await prisma.socialLife.findMany()
     * 
     * // Get first 10 SocialLives
     * const socialLives = await prisma.socialLife.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialLifeWithIdOnly = await prisma.socialLife.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialLifeFindManyArgs>(args?: SelectSubset<T, SocialLifeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialLife.
     * @param {SocialLifeCreateArgs} args - Arguments to create a SocialLife.
     * @example
     * // Create one SocialLife
     * const SocialLife = await prisma.socialLife.create({
     *   data: {
     *     // ... data to create a SocialLife
     *   }
     * })
     * 
     */
    create<T extends SocialLifeCreateArgs>(args: SelectSubset<T, SocialLifeCreateArgs<ExtArgs>>): Prisma__SocialLifeClient<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialLives.
     * @param {SocialLifeCreateManyArgs} args - Arguments to create many SocialLives.
     * @example
     * // Create many SocialLives
     * const socialLife = await prisma.socialLife.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialLifeCreateManyArgs>(args?: SelectSubset<T, SocialLifeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialLives and returns the data saved in the database.
     * @param {SocialLifeCreateManyAndReturnArgs} args - Arguments to create many SocialLives.
     * @example
     * // Create many SocialLives
     * const socialLife = await prisma.socialLife.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialLives and only return the `id`
     * const socialLifeWithIdOnly = await prisma.socialLife.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialLifeCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialLifeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialLife.
     * @param {SocialLifeDeleteArgs} args - Arguments to delete one SocialLife.
     * @example
     * // Delete one SocialLife
     * const SocialLife = await prisma.socialLife.delete({
     *   where: {
     *     // ... filter to delete one SocialLife
     *   }
     * })
     * 
     */
    delete<T extends SocialLifeDeleteArgs>(args: SelectSubset<T, SocialLifeDeleteArgs<ExtArgs>>): Prisma__SocialLifeClient<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialLife.
     * @param {SocialLifeUpdateArgs} args - Arguments to update one SocialLife.
     * @example
     * // Update one SocialLife
     * const socialLife = await prisma.socialLife.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialLifeUpdateArgs>(args: SelectSubset<T, SocialLifeUpdateArgs<ExtArgs>>): Prisma__SocialLifeClient<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialLives.
     * @param {SocialLifeDeleteManyArgs} args - Arguments to filter SocialLives to delete.
     * @example
     * // Delete a few SocialLives
     * const { count } = await prisma.socialLife.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialLifeDeleteManyArgs>(args?: SelectSubset<T, SocialLifeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLifeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLives
     * const socialLife = await prisma.socialLife.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialLifeUpdateManyArgs>(args: SelectSubset<T, SocialLifeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLives and returns the data updated in the database.
     * @param {SocialLifeUpdateManyAndReturnArgs} args - Arguments to update many SocialLives.
     * @example
     * // Update many SocialLives
     * const socialLife = await prisma.socialLife.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialLives and only return the `id`
     * const socialLifeWithIdOnly = await prisma.socialLife.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialLifeUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialLifeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialLife.
     * @param {SocialLifeUpsertArgs} args - Arguments to update or create a SocialLife.
     * @example
     * // Update or create a SocialLife
     * const socialLife = await prisma.socialLife.upsert({
     *   create: {
     *     // ... data to create a SocialLife
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLife we want to update
     *   }
     * })
     */
    upsert<T extends SocialLifeUpsertArgs>(args: SelectSubset<T, SocialLifeUpsertArgs<ExtArgs>>): Prisma__SocialLifeClient<$Result.GetResult<Prisma.$SocialLifePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialLives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLifeCountArgs} args - Arguments to filter SocialLives to count.
     * @example
     * // Count the number of SocialLives
     * const count = await prisma.socialLife.count({
     *   where: {
     *     // ... the filter for the SocialLives we want to count
     *   }
     * })
    **/
    count<T extends SocialLifeCountArgs>(
      args?: Subset<T, SocialLifeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLifeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLife.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLifeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLifeAggregateArgs>(args: Subset<T, SocialLifeAggregateArgs>): Prisma.PrismaPromise<GetSocialLifeAggregateType<T>>

    /**
     * Group by SocialLife.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLifeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialLifeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialLifeGroupByArgs['orderBy'] }
        : { orderBy?: SocialLifeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialLifeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLifeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialLife model
   */
  readonly fields: SocialLifeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialLife.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialLifeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialLife model
   */
  interface SocialLifeFieldRefs {
    readonly id: FieldRef<"SocialLife", 'Int'>
    readonly name: FieldRef<"SocialLife", 'String'>
    readonly description: FieldRef<"SocialLife", 'String'>
    readonly fullDescription: FieldRef<"SocialLife", 'String'>
    readonly imageUrl: FieldRef<"SocialLife", 'String'>
    readonly website: FieldRef<"SocialLife", 'String'>
    readonly areaId: FieldRef<"SocialLife", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SocialLife findUnique
   */
  export type SocialLifeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * Filter, which SocialLife to fetch.
     */
    where: SocialLifeWhereUniqueInput
  }

  /**
   * SocialLife findUniqueOrThrow
   */
  export type SocialLifeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * Filter, which SocialLife to fetch.
     */
    where: SocialLifeWhereUniqueInput
  }

  /**
   * SocialLife findFirst
   */
  export type SocialLifeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * Filter, which SocialLife to fetch.
     */
    where?: SocialLifeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLives to fetch.
     */
    orderBy?: SocialLifeOrderByWithRelationInput | SocialLifeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLives.
     */
    cursor?: SocialLifeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLives.
     */
    distinct?: SocialLifeScalarFieldEnum | SocialLifeScalarFieldEnum[]
  }

  /**
   * SocialLife findFirstOrThrow
   */
  export type SocialLifeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * Filter, which SocialLife to fetch.
     */
    where?: SocialLifeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLives to fetch.
     */
    orderBy?: SocialLifeOrderByWithRelationInput | SocialLifeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLives.
     */
    cursor?: SocialLifeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLives.
     */
    distinct?: SocialLifeScalarFieldEnum | SocialLifeScalarFieldEnum[]
  }

  /**
   * SocialLife findMany
   */
  export type SocialLifeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * Filter, which SocialLives to fetch.
     */
    where?: SocialLifeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLives to fetch.
     */
    orderBy?: SocialLifeOrderByWithRelationInput | SocialLifeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialLives.
     */
    cursor?: SocialLifeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLives.
     */
    skip?: number
    distinct?: SocialLifeScalarFieldEnum | SocialLifeScalarFieldEnum[]
  }

  /**
   * SocialLife create
   */
  export type SocialLifeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialLife.
     */
    data: XOR<SocialLifeCreateInput, SocialLifeUncheckedCreateInput>
  }

  /**
   * SocialLife createMany
   */
  export type SocialLifeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialLives.
     */
    data: SocialLifeCreateManyInput | SocialLifeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialLife createManyAndReturn
   */
  export type SocialLifeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * The data used to create many SocialLives.
     */
    data: SocialLifeCreateManyInput | SocialLifeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialLife update
   */
  export type SocialLifeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialLife.
     */
    data: XOR<SocialLifeUpdateInput, SocialLifeUncheckedUpdateInput>
    /**
     * Choose, which SocialLife to update.
     */
    where: SocialLifeWhereUniqueInput
  }

  /**
   * SocialLife updateMany
   */
  export type SocialLifeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialLives.
     */
    data: XOR<SocialLifeUpdateManyMutationInput, SocialLifeUncheckedUpdateManyInput>
    /**
     * Filter which SocialLives to update
     */
    where?: SocialLifeWhereInput
    /**
     * Limit how many SocialLives to update.
     */
    limit?: number
  }

  /**
   * SocialLife updateManyAndReturn
   */
  export type SocialLifeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * The data used to update SocialLives.
     */
    data: XOR<SocialLifeUpdateManyMutationInput, SocialLifeUncheckedUpdateManyInput>
    /**
     * Filter which SocialLives to update
     */
    where?: SocialLifeWhereInput
    /**
     * Limit how many SocialLives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialLife upsert
   */
  export type SocialLifeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialLife to update in case it exists.
     */
    where: SocialLifeWhereUniqueInput
    /**
     * In case the SocialLife found by the `where` argument doesn't exist, create a new SocialLife with this data.
     */
    create: XOR<SocialLifeCreateInput, SocialLifeUncheckedCreateInput>
    /**
     * In case the SocialLife was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialLifeUpdateInput, SocialLifeUncheckedUpdateInput>
  }

  /**
   * SocialLife delete
   */
  export type SocialLifeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
    /**
     * Filter which SocialLife to delete.
     */
    where: SocialLifeWhereUniqueInput
  }

  /**
   * SocialLife deleteMany
   */
  export type SocialLifeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLives to delete
     */
    where?: SocialLifeWhereInput
    /**
     * Limit how many SocialLives to delete.
     */
    limit?: number
  }

  /**
   * SocialLife without action
   */
  export type SocialLifeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLife
     */
    select?: SocialLifeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLife
     */
    omit?: SocialLifeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLifeInclude<ExtArgs> | null
  }


  /**
   * Model Shopping
   */

  export type AggregateShopping = {
    _count: ShoppingCountAggregateOutputType | null
    _avg: ShoppingAvgAggregateOutputType | null
    _sum: ShoppingSumAggregateOutputType | null
    _min: ShoppingMinAggregateOutputType | null
    _max: ShoppingMaxAggregateOutputType | null
  }

  export type ShoppingAvgAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type ShoppingSumAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type ShoppingMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type ShoppingMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type ShoppingCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fullDescription: number
    imageUrl: number
    website: number
    areaId: number
    _all: number
  }


  export type ShoppingAvgAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type ShoppingSumAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type ShoppingMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type ShoppingMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type ShoppingCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
    _all?: true
  }

  export type ShoppingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shopping to aggregate.
     */
    where?: ShoppingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shoppings to fetch.
     */
    orderBy?: ShoppingOrderByWithRelationInput | ShoppingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShoppingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shoppings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shoppings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shoppings
    **/
    _count?: true | ShoppingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShoppingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShoppingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoppingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoppingMaxAggregateInputType
  }

  export type GetShoppingAggregateType<T extends ShoppingAggregateArgs> = {
        [P in keyof T & keyof AggregateShopping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopping[P]>
      : GetScalarType<T[P], AggregateShopping[P]>
  }




  export type ShoppingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingWhereInput
    orderBy?: ShoppingOrderByWithAggregationInput | ShoppingOrderByWithAggregationInput[]
    by: ShoppingScalarFieldEnum[] | ShoppingScalarFieldEnum
    having?: ShoppingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoppingCountAggregateInputType | true
    _avg?: ShoppingAvgAggregateInputType
    _sum?: ShoppingSumAggregateInputType
    _min?: ShoppingMinAggregateInputType
    _max?: ShoppingMaxAggregateInputType
  }

  export type ShoppingGroupByOutputType = {
    id: number
    name: string
    description: string
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number
    _count: ShoppingCountAggregateOutputType | null
    _avg: ShoppingAvgAggregateOutputType | null
    _sum: ShoppingSumAggregateOutputType | null
    _min: ShoppingMinAggregateOutputType | null
    _max: ShoppingMaxAggregateOutputType | null
  }

  type GetShoppingGroupByPayload<T extends ShoppingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShoppingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoppingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoppingGroupByOutputType[P]>
            : GetScalarType<T[P], ShoppingGroupByOutputType[P]>
        }
      >
    >


  export type ShoppingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopping"]>

  export type ShoppingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopping"]>

  export type ShoppingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopping"]>

  export type ShoppingSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
  }

  export type ShoppingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "fullDescription" | "imageUrl" | "website" | "areaId", ExtArgs["result"]["shopping"]>
  export type ShoppingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type ShoppingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type ShoppingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $ShoppingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shopping"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      fullDescription: string | null
      imageUrl: string | null
      website: string | null
      areaId: number
    }, ExtArgs["result"]["shopping"]>
    composites: {}
  }

  type ShoppingGetPayload<S extends boolean | null | undefined | ShoppingDefaultArgs> = $Result.GetResult<Prisma.$ShoppingPayload, S>

  type ShoppingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShoppingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShoppingCountAggregateInputType | true
    }

  export interface ShoppingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shopping'], meta: { name: 'Shopping' } }
    /**
     * Find zero or one Shopping that matches the filter.
     * @param {ShoppingFindUniqueArgs} args - Arguments to find a Shopping
     * @example
     * // Get one Shopping
     * const shopping = await prisma.shopping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShoppingFindUniqueArgs>(args: SelectSubset<T, ShoppingFindUniqueArgs<ExtArgs>>): Prisma__ShoppingClient<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shopping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShoppingFindUniqueOrThrowArgs} args - Arguments to find a Shopping
     * @example
     * // Get one Shopping
     * const shopping = await prisma.shopping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShoppingFindUniqueOrThrowArgs>(args: SelectSubset<T, ShoppingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShoppingClient<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shopping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingFindFirstArgs} args - Arguments to find a Shopping
     * @example
     * // Get one Shopping
     * const shopping = await prisma.shopping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShoppingFindFirstArgs>(args?: SelectSubset<T, ShoppingFindFirstArgs<ExtArgs>>): Prisma__ShoppingClient<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shopping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingFindFirstOrThrowArgs} args - Arguments to find a Shopping
     * @example
     * // Get one Shopping
     * const shopping = await prisma.shopping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShoppingFindFirstOrThrowArgs>(args?: SelectSubset<T, ShoppingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShoppingClient<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shoppings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shoppings
     * const shoppings = await prisma.shopping.findMany()
     * 
     * // Get first 10 Shoppings
     * const shoppings = await prisma.shopping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shoppingWithIdOnly = await prisma.shopping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShoppingFindManyArgs>(args?: SelectSubset<T, ShoppingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shopping.
     * @param {ShoppingCreateArgs} args - Arguments to create a Shopping.
     * @example
     * // Create one Shopping
     * const Shopping = await prisma.shopping.create({
     *   data: {
     *     // ... data to create a Shopping
     *   }
     * })
     * 
     */
    create<T extends ShoppingCreateArgs>(args: SelectSubset<T, ShoppingCreateArgs<ExtArgs>>): Prisma__ShoppingClient<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shoppings.
     * @param {ShoppingCreateManyArgs} args - Arguments to create many Shoppings.
     * @example
     * // Create many Shoppings
     * const shopping = await prisma.shopping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShoppingCreateManyArgs>(args?: SelectSubset<T, ShoppingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shoppings and returns the data saved in the database.
     * @param {ShoppingCreateManyAndReturnArgs} args - Arguments to create many Shoppings.
     * @example
     * // Create many Shoppings
     * const shopping = await prisma.shopping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shoppings and only return the `id`
     * const shoppingWithIdOnly = await prisma.shopping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShoppingCreateManyAndReturnArgs>(args?: SelectSubset<T, ShoppingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shopping.
     * @param {ShoppingDeleteArgs} args - Arguments to delete one Shopping.
     * @example
     * // Delete one Shopping
     * const Shopping = await prisma.shopping.delete({
     *   where: {
     *     // ... filter to delete one Shopping
     *   }
     * })
     * 
     */
    delete<T extends ShoppingDeleteArgs>(args: SelectSubset<T, ShoppingDeleteArgs<ExtArgs>>): Prisma__ShoppingClient<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shopping.
     * @param {ShoppingUpdateArgs} args - Arguments to update one Shopping.
     * @example
     * // Update one Shopping
     * const shopping = await prisma.shopping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShoppingUpdateArgs>(args: SelectSubset<T, ShoppingUpdateArgs<ExtArgs>>): Prisma__ShoppingClient<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shoppings.
     * @param {ShoppingDeleteManyArgs} args - Arguments to filter Shoppings to delete.
     * @example
     * // Delete a few Shoppings
     * const { count } = await prisma.shopping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShoppingDeleteManyArgs>(args?: SelectSubset<T, ShoppingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shoppings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shoppings
     * const shopping = await prisma.shopping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShoppingUpdateManyArgs>(args: SelectSubset<T, ShoppingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shoppings and returns the data updated in the database.
     * @param {ShoppingUpdateManyAndReturnArgs} args - Arguments to update many Shoppings.
     * @example
     * // Update many Shoppings
     * const shopping = await prisma.shopping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shoppings and only return the `id`
     * const shoppingWithIdOnly = await prisma.shopping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShoppingUpdateManyAndReturnArgs>(args: SelectSubset<T, ShoppingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shopping.
     * @param {ShoppingUpsertArgs} args - Arguments to update or create a Shopping.
     * @example
     * // Update or create a Shopping
     * const shopping = await prisma.shopping.upsert({
     *   create: {
     *     // ... data to create a Shopping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shopping we want to update
     *   }
     * })
     */
    upsert<T extends ShoppingUpsertArgs>(args: SelectSubset<T, ShoppingUpsertArgs<ExtArgs>>): Prisma__ShoppingClient<$Result.GetResult<Prisma.$ShoppingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shoppings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCountArgs} args - Arguments to filter Shoppings to count.
     * @example
     * // Count the number of Shoppings
     * const count = await prisma.shopping.count({
     *   where: {
     *     // ... the filter for the Shoppings we want to count
     *   }
     * })
    **/
    count<T extends ShoppingCountArgs>(
      args?: Subset<T, ShoppingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoppingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shopping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoppingAggregateArgs>(args: Subset<T, ShoppingAggregateArgs>): Prisma.PrismaPromise<GetShoppingAggregateType<T>>

    /**
     * Group by Shopping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoppingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoppingGroupByArgs['orderBy'] }
        : { orderBy?: ShoppingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoppingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoppingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shopping model
   */
  readonly fields: ShoppingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shopping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShoppingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shopping model
   */
  interface ShoppingFieldRefs {
    readonly id: FieldRef<"Shopping", 'Int'>
    readonly name: FieldRef<"Shopping", 'String'>
    readonly description: FieldRef<"Shopping", 'String'>
    readonly fullDescription: FieldRef<"Shopping", 'String'>
    readonly imageUrl: FieldRef<"Shopping", 'String'>
    readonly website: FieldRef<"Shopping", 'String'>
    readonly areaId: FieldRef<"Shopping", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Shopping findUnique
   */
  export type ShoppingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * Filter, which Shopping to fetch.
     */
    where: ShoppingWhereUniqueInput
  }

  /**
   * Shopping findUniqueOrThrow
   */
  export type ShoppingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * Filter, which Shopping to fetch.
     */
    where: ShoppingWhereUniqueInput
  }

  /**
   * Shopping findFirst
   */
  export type ShoppingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * Filter, which Shopping to fetch.
     */
    where?: ShoppingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shoppings to fetch.
     */
    orderBy?: ShoppingOrderByWithRelationInput | ShoppingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shoppings.
     */
    cursor?: ShoppingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shoppings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shoppings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shoppings.
     */
    distinct?: ShoppingScalarFieldEnum | ShoppingScalarFieldEnum[]
  }

  /**
   * Shopping findFirstOrThrow
   */
  export type ShoppingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * Filter, which Shopping to fetch.
     */
    where?: ShoppingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shoppings to fetch.
     */
    orderBy?: ShoppingOrderByWithRelationInput | ShoppingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shoppings.
     */
    cursor?: ShoppingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shoppings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shoppings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shoppings.
     */
    distinct?: ShoppingScalarFieldEnum | ShoppingScalarFieldEnum[]
  }

  /**
   * Shopping findMany
   */
  export type ShoppingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * Filter, which Shoppings to fetch.
     */
    where?: ShoppingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shoppings to fetch.
     */
    orderBy?: ShoppingOrderByWithRelationInput | ShoppingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shoppings.
     */
    cursor?: ShoppingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shoppings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shoppings.
     */
    skip?: number
    distinct?: ShoppingScalarFieldEnum | ShoppingScalarFieldEnum[]
  }

  /**
   * Shopping create
   */
  export type ShoppingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * The data needed to create a Shopping.
     */
    data: XOR<ShoppingCreateInput, ShoppingUncheckedCreateInput>
  }

  /**
   * Shopping createMany
   */
  export type ShoppingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shoppings.
     */
    data: ShoppingCreateManyInput | ShoppingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shopping createManyAndReturn
   */
  export type ShoppingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * The data used to create many Shoppings.
     */
    data: ShoppingCreateManyInput | ShoppingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shopping update
   */
  export type ShoppingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * The data needed to update a Shopping.
     */
    data: XOR<ShoppingUpdateInput, ShoppingUncheckedUpdateInput>
    /**
     * Choose, which Shopping to update.
     */
    where: ShoppingWhereUniqueInput
  }

  /**
   * Shopping updateMany
   */
  export type ShoppingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shoppings.
     */
    data: XOR<ShoppingUpdateManyMutationInput, ShoppingUncheckedUpdateManyInput>
    /**
     * Filter which Shoppings to update
     */
    where?: ShoppingWhereInput
    /**
     * Limit how many Shoppings to update.
     */
    limit?: number
  }

  /**
   * Shopping updateManyAndReturn
   */
  export type ShoppingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * The data used to update Shoppings.
     */
    data: XOR<ShoppingUpdateManyMutationInput, ShoppingUncheckedUpdateManyInput>
    /**
     * Filter which Shoppings to update
     */
    where?: ShoppingWhereInput
    /**
     * Limit how many Shoppings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shopping upsert
   */
  export type ShoppingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * The filter to search for the Shopping to update in case it exists.
     */
    where: ShoppingWhereUniqueInput
    /**
     * In case the Shopping found by the `where` argument doesn't exist, create a new Shopping with this data.
     */
    create: XOR<ShoppingCreateInput, ShoppingUncheckedCreateInput>
    /**
     * In case the Shopping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShoppingUpdateInput, ShoppingUncheckedUpdateInput>
  }

  /**
   * Shopping delete
   */
  export type ShoppingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
    /**
     * Filter which Shopping to delete.
     */
    where: ShoppingWhereUniqueInput
  }

  /**
   * Shopping deleteMany
   */
  export type ShoppingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shoppings to delete
     */
    where?: ShoppingWhereInput
    /**
     * Limit how many Shoppings to delete.
     */
    limit?: number
  }

  /**
   * Shopping without action
   */
  export type ShoppingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shopping
     */
    select?: ShoppingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shopping
     */
    omit?: ShoppingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingInclude<ExtArgs> | null
  }


  /**
   * Model GreenSpace
   */

  export type AggregateGreenSpace = {
    _count: GreenSpaceCountAggregateOutputType | null
    _avg: GreenSpaceAvgAggregateOutputType | null
    _sum: GreenSpaceSumAggregateOutputType | null
    _min: GreenSpaceMinAggregateOutputType | null
    _max: GreenSpaceMaxAggregateOutputType | null
  }

  export type GreenSpaceAvgAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type GreenSpaceSumAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type GreenSpaceMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type GreenSpaceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type GreenSpaceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fullDescription: number
    imageUrl: number
    website: number
    areaId: number
    _all: number
  }


  export type GreenSpaceAvgAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type GreenSpaceSumAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type GreenSpaceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type GreenSpaceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type GreenSpaceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
    _all?: true
  }

  export type GreenSpaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GreenSpace to aggregate.
     */
    where?: GreenSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GreenSpaces to fetch.
     */
    orderBy?: GreenSpaceOrderByWithRelationInput | GreenSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GreenSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GreenSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GreenSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GreenSpaces
    **/
    _count?: true | GreenSpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GreenSpaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GreenSpaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GreenSpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GreenSpaceMaxAggregateInputType
  }

  export type GetGreenSpaceAggregateType<T extends GreenSpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateGreenSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGreenSpace[P]>
      : GetScalarType<T[P], AggregateGreenSpace[P]>
  }




  export type GreenSpaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GreenSpaceWhereInput
    orderBy?: GreenSpaceOrderByWithAggregationInput | GreenSpaceOrderByWithAggregationInput[]
    by: GreenSpaceScalarFieldEnum[] | GreenSpaceScalarFieldEnum
    having?: GreenSpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GreenSpaceCountAggregateInputType | true
    _avg?: GreenSpaceAvgAggregateInputType
    _sum?: GreenSpaceSumAggregateInputType
    _min?: GreenSpaceMinAggregateInputType
    _max?: GreenSpaceMaxAggregateInputType
  }

  export type GreenSpaceGroupByOutputType = {
    id: number
    name: string
    description: string
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number
    _count: GreenSpaceCountAggregateOutputType | null
    _avg: GreenSpaceAvgAggregateOutputType | null
    _sum: GreenSpaceSumAggregateOutputType | null
    _min: GreenSpaceMinAggregateOutputType | null
    _max: GreenSpaceMaxAggregateOutputType | null
  }

  type GetGreenSpaceGroupByPayload<T extends GreenSpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GreenSpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GreenSpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GreenSpaceGroupByOutputType[P]>
            : GetScalarType<T[P], GreenSpaceGroupByOutputType[P]>
        }
      >
    >


  export type GreenSpaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["greenSpace"]>

  export type GreenSpaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["greenSpace"]>

  export type GreenSpaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["greenSpace"]>

  export type GreenSpaceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
  }

  export type GreenSpaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "fullDescription" | "imageUrl" | "website" | "areaId", ExtArgs["result"]["greenSpace"]>
  export type GreenSpaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type GreenSpaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type GreenSpaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $GreenSpacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GreenSpace"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      fullDescription: string | null
      imageUrl: string | null
      website: string | null
      areaId: number
    }, ExtArgs["result"]["greenSpace"]>
    composites: {}
  }

  type GreenSpaceGetPayload<S extends boolean | null | undefined | GreenSpaceDefaultArgs> = $Result.GetResult<Prisma.$GreenSpacePayload, S>

  type GreenSpaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GreenSpaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GreenSpaceCountAggregateInputType | true
    }

  export interface GreenSpaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GreenSpace'], meta: { name: 'GreenSpace' } }
    /**
     * Find zero or one GreenSpace that matches the filter.
     * @param {GreenSpaceFindUniqueArgs} args - Arguments to find a GreenSpace
     * @example
     * // Get one GreenSpace
     * const greenSpace = await prisma.greenSpace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GreenSpaceFindUniqueArgs>(args: SelectSubset<T, GreenSpaceFindUniqueArgs<ExtArgs>>): Prisma__GreenSpaceClient<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GreenSpace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GreenSpaceFindUniqueOrThrowArgs} args - Arguments to find a GreenSpace
     * @example
     * // Get one GreenSpace
     * const greenSpace = await prisma.greenSpace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GreenSpaceFindUniqueOrThrowArgs>(args: SelectSubset<T, GreenSpaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GreenSpaceClient<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GreenSpace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GreenSpaceFindFirstArgs} args - Arguments to find a GreenSpace
     * @example
     * // Get one GreenSpace
     * const greenSpace = await prisma.greenSpace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GreenSpaceFindFirstArgs>(args?: SelectSubset<T, GreenSpaceFindFirstArgs<ExtArgs>>): Prisma__GreenSpaceClient<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GreenSpace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GreenSpaceFindFirstOrThrowArgs} args - Arguments to find a GreenSpace
     * @example
     * // Get one GreenSpace
     * const greenSpace = await prisma.greenSpace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GreenSpaceFindFirstOrThrowArgs>(args?: SelectSubset<T, GreenSpaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__GreenSpaceClient<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GreenSpaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GreenSpaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GreenSpaces
     * const greenSpaces = await prisma.greenSpace.findMany()
     * 
     * // Get first 10 GreenSpaces
     * const greenSpaces = await prisma.greenSpace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const greenSpaceWithIdOnly = await prisma.greenSpace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GreenSpaceFindManyArgs>(args?: SelectSubset<T, GreenSpaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GreenSpace.
     * @param {GreenSpaceCreateArgs} args - Arguments to create a GreenSpace.
     * @example
     * // Create one GreenSpace
     * const GreenSpace = await prisma.greenSpace.create({
     *   data: {
     *     // ... data to create a GreenSpace
     *   }
     * })
     * 
     */
    create<T extends GreenSpaceCreateArgs>(args: SelectSubset<T, GreenSpaceCreateArgs<ExtArgs>>): Prisma__GreenSpaceClient<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GreenSpaces.
     * @param {GreenSpaceCreateManyArgs} args - Arguments to create many GreenSpaces.
     * @example
     * // Create many GreenSpaces
     * const greenSpace = await prisma.greenSpace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GreenSpaceCreateManyArgs>(args?: SelectSubset<T, GreenSpaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GreenSpaces and returns the data saved in the database.
     * @param {GreenSpaceCreateManyAndReturnArgs} args - Arguments to create many GreenSpaces.
     * @example
     * // Create many GreenSpaces
     * const greenSpace = await prisma.greenSpace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GreenSpaces and only return the `id`
     * const greenSpaceWithIdOnly = await prisma.greenSpace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GreenSpaceCreateManyAndReturnArgs>(args?: SelectSubset<T, GreenSpaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GreenSpace.
     * @param {GreenSpaceDeleteArgs} args - Arguments to delete one GreenSpace.
     * @example
     * // Delete one GreenSpace
     * const GreenSpace = await prisma.greenSpace.delete({
     *   where: {
     *     // ... filter to delete one GreenSpace
     *   }
     * })
     * 
     */
    delete<T extends GreenSpaceDeleteArgs>(args: SelectSubset<T, GreenSpaceDeleteArgs<ExtArgs>>): Prisma__GreenSpaceClient<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GreenSpace.
     * @param {GreenSpaceUpdateArgs} args - Arguments to update one GreenSpace.
     * @example
     * // Update one GreenSpace
     * const greenSpace = await prisma.greenSpace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GreenSpaceUpdateArgs>(args: SelectSubset<T, GreenSpaceUpdateArgs<ExtArgs>>): Prisma__GreenSpaceClient<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GreenSpaces.
     * @param {GreenSpaceDeleteManyArgs} args - Arguments to filter GreenSpaces to delete.
     * @example
     * // Delete a few GreenSpaces
     * const { count } = await prisma.greenSpace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GreenSpaceDeleteManyArgs>(args?: SelectSubset<T, GreenSpaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GreenSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GreenSpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GreenSpaces
     * const greenSpace = await prisma.greenSpace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GreenSpaceUpdateManyArgs>(args: SelectSubset<T, GreenSpaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GreenSpaces and returns the data updated in the database.
     * @param {GreenSpaceUpdateManyAndReturnArgs} args - Arguments to update many GreenSpaces.
     * @example
     * // Update many GreenSpaces
     * const greenSpace = await prisma.greenSpace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GreenSpaces and only return the `id`
     * const greenSpaceWithIdOnly = await prisma.greenSpace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GreenSpaceUpdateManyAndReturnArgs>(args: SelectSubset<T, GreenSpaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GreenSpace.
     * @param {GreenSpaceUpsertArgs} args - Arguments to update or create a GreenSpace.
     * @example
     * // Update or create a GreenSpace
     * const greenSpace = await prisma.greenSpace.upsert({
     *   create: {
     *     // ... data to create a GreenSpace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GreenSpace we want to update
     *   }
     * })
     */
    upsert<T extends GreenSpaceUpsertArgs>(args: SelectSubset<T, GreenSpaceUpsertArgs<ExtArgs>>): Prisma__GreenSpaceClient<$Result.GetResult<Prisma.$GreenSpacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GreenSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GreenSpaceCountArgs} args - Arguments to filter GreenSpaces to count.
     * @example
     * // Count the number of GreenSpaces
     * const count = await prisma.greenSpace.count({
     *   where: {
     *     // ... the filter for the GreenSpaces we want to count
     *   }
     * })
    **/
    count<T extends GreenSpaceCountArgs>(
      args?: Subset<T, GreenSpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GreenSpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GreenSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GreenSpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GreenSpaceAggregateArgs>(args: Subset<T, GreenSpaceAggregateArgs>): Prisma.PrismaPromise<GetGreenSpaceAggregateType<T>>

    /**
     * Group by GreenSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GreenSpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GreenSpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GreenSpaceGroupByArgs['orderBy'] }
        : { orderBy?: GreenSpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GreenSpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGreenSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GreenSpace model
   */
  readonly fields: GreenSpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GreenSpace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GreenSpaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GreenSpace model
   */
  interface GreenSpaceFieldRefs {
    readonly id: FieldRef<"GreenSpace", 'Int'>
    readonly name: FieldRef<"GreenSpace", 'String'>
    readonly description: FieldRef<"GreenSpace", 'String'>
    readonly fullDescription: FieldRef<"GreenSpace", 'String'>
    readonly imageUrl: FieldRef<"GreenSpace", 'String'>
    readonly website: FieldRef<"GreenSpace", 'String'>
    readonly areaId: FieldRef<"GreenSpace", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GreenSpace findUnique
   */
  export type GreenSpaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * Filter, which GreenSpace to fetch.
     */
    where: GreenSpaceWhereUniqueInput
  }

  /**
   * GreenSpace findUniqueOrThrow
   */
  export type GreenSpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * Filter, which GreenSpace to fetch.
     */
    where: GreenSpaceWhereUniqueInput
  }

  /**
   * GreenSpace findFirst
   */
  export type GreenSpaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * Filter, which GreenSpace to fetch.
     */
    where?: GreenSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GreenSpaces to fetch.
     */
    orderBy?: GreenSpaceOrderByWithRelationInput | GreenSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GreenSpaces.
     */
    cursor?: GreenSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GreenSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GreenSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GreenSpaces.
     */
    distinct?: GreenSpaceScalarFieldEnum | GreenSpaceScalarFieldEnum[]
  }

  /**
   * GreenSpace findFirstOrThrow
   */
  export type GreenSpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * Filter, which GreenSpace to fetch.
     */
    where?: GreenSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GreenSpaces to fetch.
     */
    orderBy?: GreenSpaceOrderByWithRelationInput | GreenSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GreenSpaces.
     */
    cursor?: GreenSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GreenSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GreenSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GreenSpaces.
     */
    distinct?: GreenSpaceScalarFieldEnum | GreenSpaceScalarFieldEnum[]
  }

  /**
   * GreenSpace findMany
   */
  export type GreenSpaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * Filter, which GreenSpaces to fetch.
     */
    where?: GreenSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GreenSpaces to fetch.
     */
    orderBy?: GreenSpaceOrderByWithRelationInput | GreenSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GreenSpaces.
     */
    cursor?: GreenSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GreenSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GreenSpaces.
     */
    skip?: number
    distinct?: GreenSpaceScalarFieldEnum | GreenSpaceScalarFieldEnum[]
  }

  /**
   * GreenSpace create
   */
  export type GreenSpaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * The data needed to create a GreenSpace.
     */
    data: XOR<GreenSpaceCreateInput, GreenSpaceUncheckedCreateInput>
  }

  /**
   * GreenSpace createMany
   */
  export type GreenSpaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GreenSpaces.
     */
    data: GreenSpaceCreateManyInput | GreenSpaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GreenSpace createManyAndReturn
   */
  export type GreenSpaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * The data used to create many GreenSpaces.
     */
    data: GreenSpaceCreateManyInput | GreenSpaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GreenSpace update
   */
  export type GreenSpaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * The data needed to update a GreenSpace.
     */
    data: XOR<GreenSpaceUpdateInput, GreenSpaceUncheckedUpdateInput>
    /**
     * Choose, which GreenSpace to update.
     */
    where: GreenSpaceWhereUniqueInput
  }

  /**
   * GreenSpace updateMany
   */
  export type GreenSpaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GreenSpaces.
     */
    data: XOR<GreenSpaceUpdateManyMutationInput, GreenSpaceUncheckedUpdateManyInput>
    /**
     * Filter which GreenSpaces to update
     */
    where?: GreenSpaceWhereInput
    /**
     * Limit how many GreenSpaces to update.
     */
    limit?: number
  }

  /**
   * GreenSpace updateManyAndReturn
   */
  export type GreenSpaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * The data used to update GreenSpaces.
     */
    data: XOR<GreenSpaceUpdateManyMutationInput, GreenSpaceUncheckedUpdateManyInput>
    /**
     * Filter which GreenSpaces to update
     */
    where?: GreenSpaceWhereInput
    /**
     * Limit how many GreenSpaces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GreenSpace upsert
   */
  export type GreenSpaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * The filter to search for the GreenSpace to update in case it exists.
     */
    where: GreenSpaceWhereUniqueInput
    /**
     * In case the GreenSpace found by the `where` argument doesn't exist, create a new GreenSpace with this data.
     */
    create: XOR<GreenSpaceCreateInput, GreenSpaceUncheckedCreateInput>
    /**
     * In case the GreenSpace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GreenSpaceUpdateInput, GreenSpaceUncheckedUpdateInput>
  }

  /**
   * GreenSpace delete
   */
  export type GreenSpaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
    /**
     * Filter which GreenSpace to delete.
     */
    where: GreenSpaceWhereUniqueInput
  }

  /**
   * GreenSpace deleteMany
   */
  export type GreenSpaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GreenSpaces to delete
     */
    where?: GreenSpaceWhereInput
    /**
     * Limit how many GreenSpaces to delete.
     */
    limit?: number
  }

  /**
   * GreenSpace without action
   */
  export type GreenSpaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GreenSpace
     */
    select?: GreenSpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GreenSpace
     */
    omit?: GreenSpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GreenSpaceInclude<ExtArgs> | null
  }


  /**
   * Model Sport
   */

  export type AggregateSport = {
    _count: SportCountAggregateOutputType | null
    _avg: SportAvgAggregateOutputType | null
    _sum: SportSumAggregateOutputType | null
    _min: SportMinAggregateOutputType | null
    _max: SportMaxAggregateOutputType | null
  }

  export type SportAvgAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type SportSumAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type SportMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type SportMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number | null
  }

  export type SportCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fullDescription: number
    imageUrl: number
    website: number
    areaId: number
    _all: number
  }


  export type SportAvgAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type SportSumAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type SportMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type SportMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
  }

  export type SportCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    imageUrl?: true
    website?: true
    areaId?: true
    _all?: true
  }

  export type SportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sport to aggregate.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sports
    **/
    _count?: true | SportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportMaxAggregateInputType
  }

  export type GetSportAggregateType<T extends SportAggregateArgs> = {
        [P in keyof T & keyof AggregateSport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSport[P]>
      : GetScalarType<T[P], AggregateSport[P]>
  }




  export type SportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportWhereInput
    orderBy?: SportOrderByWithAggregationInput | SportOrderByWithAggregationInput[]
    by: SportScalarFieldEnum[] | SportScalarFieldEnum
    having?: SportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportCountAggregateInputType | true
    _avg?: SportAvgAggregateInputType
    _sum?: SportSumAggregateInputType
    _min?: SportMinAggregateInputType
    _max?: SportMaxAggregateInputType
  }

  export type SportGroupByOutputType = {
    id: number
    name: string
    description: string
    fullDescription: string | null
    imageUrl: string | null
    website: string | null
    areaId: number
    _count: SportCountAggregateOutputType | null
    _avg: SportAvgAggregateOutputType | null
    _sum: SportSumAggregateOutputType | null
    _min: SportMinAggregateOutputType | null
    _max: SportMaxAggregateOutputType | null
  }

  type GetSportGroupByPayload<T extends SportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportGroupByOutputType[P]>
            : GetScalarType<T[P], SportGroupByOutputType[P]>
        }
      >
    >


  export type SportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sport"]>

  export type SportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sport"]>

  export type SportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sport"]>

  export type SportSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrl?: boolean
    website?: boolean
    areaId?: boolean
  }

  export type SportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "fullDescription" | "imageUrl" | "website" | "areaId", ExtArgs["result"]["sport"]>
  export type SportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type SportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type SportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $SportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sport"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      fullDescription: string | null
      imageUrl: string | null
      website: string | null
      areaId: number
    }, ExtArgs["result"]["sport"]>
    composites: {}
  }

  type SportGetPayload<S extends boolean | null | undefined | SportDefaultArgs> = $Result.GetResult<Prisma.$SportPayload, S>

  type SportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportCountAggregateInputType | true
    }

  export interface SportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sport'], meta: { name: 'Sport' } }
    /**
     * Find zero or one Sport that matches the filter.
     * @param {SportFindUniqueArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportFindUniqueArgs>(args: SelectSubset<T, SportFindUniqueArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportFindUniqueOrThrowArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportFindUniqueOrThrowArgs>(args: SelectSubset<T, SportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindFirstArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportFindFirstArgs>(args?: SelectSubset<T, SportFindFirstArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindFirstOrThrowArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportFindFirstOrThrowArgs>(args?: SelectSubset<T, SportFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sports
     * const sports = await prisma.sport.findMany()
     * 
     * // Get first 10 Sports
     * const sports = await prisma.sport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportWithIdOnly = await prisma.sport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportFindManyArgs>(args?: SelectSubset<T, SportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sport.
     * @param {SportCreateArgs} args - Arguments to create a Sport.
     * @example
     * // Create one Sport
     * const Sport = await prisma.sport.create({
     *   data: {
     *     // ... data to create a Sport
     *   }
     * })
     * 
     */
    create<T extends SportCreateArgs>(args: SelectSubset<T, SportCreateArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sports.
     * @param {SportCreateManyArgs} args - Arguments to create many Sports.
     * @example
     * // Create many Sports
     * const sport = await prisma.sport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportCreateManyArgs>(args?: SelectSubset<T, SportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sports and returns the data saved in the database.
     * @param {SportCreateManyAndReturnArgs} args - Arguments to create many Sports.
     * @example
     * // Create many Sports
     * const sport = await prisma.sport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sports and only return the `id`
     * const sportWithIdOnly = await prisma.sport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportCreateManyAndReturnArgs>(args?: SelectSubset<T, SportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sport.
     * @param {SportDeleteArgs} args - Arguments to delete one Sport.
     * @example
     * // Delete one Sport
     * const Sport = await prisma.sport.delete({
     *   where: {
     *     // ... filter to delete one Sport
     *   }
     * })
     * 
     */
    delete<T extends SportDeleteArgs>(args: SelectSubset<T, SportDeleteArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sport.
     * @param {SportUpdateArgs} args - Arguments to update one Sport.
     * @example
     * // Update one Sport
     * const sport = await prisma.sport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportUpdateArgs>(args: SelectSubset<T, SportUpdateArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sports.
     * @param {SportDeleteManyArgs} args - Arguments to filter Sports to delete.
     * @example
     * // Delete a few Sports
     * const { count } = await prisma.sport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportDeleteManyArgs>(args?: SelectSubset<T, SportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sports
     * const sport = await prisma.sport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportUpdateManyArgs>(args: SelectSubset<T, SportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sports and returns the data updated in the database.
     * @param {SportUpdateManyAndReturnArgs} args - Arguments to update many Sports.
     * @example
     * // Update many Sports
     * const sport = await prisma.sport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sports and only return the `id`
     * const sportWithIdOnly = await prisma.sport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportUpdateManyAndReturnArgs>(args: SelectSubset<T, SportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sport.
     * @param {SportUpsertArgs} args - Arguments to update or create a Sport.
     * @example
     * // Update or create a Sport
     * const sport = await prisma.sport.upsert({
     *   create: {
     *     // ... data to create a Sport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sport we want to update
     *   }
     * })
     */
    upsert<T extends SportUpsertArgs>(args: SelectSubset<T, SportUpsertArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCountArgs} args - Arguments to filter Sports to count.
     * @example
     * // Count the number of Sports
     * const count = await prisma.sport.count({
     *   where: {
     *     // ... the filter for the Sports we want to count
     *   }
     * })
    **/
    count<T extends SportCountArgs>(
      args?: Subset<T, SportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportAggregateArgs>(args: Subset<T, SportAggregateArgs>): Prisma.PrismaPromise<GetSportAggregateType<T>>

    /**
     * Group by Sport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportGroupByArgs['orderBy'] }
        : { orderBy?: SportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sport model
   */
  readonly fields: SportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sport model
   */
  interface SportFieldRefs {
    readonly id: FieldRef<"Sport", 'Int'>
    readonly name: FieldRef<"Sport", 'String'>
    readonly description: FieldRef<"Sport", 'String'>
    readonly fullDescription: FieldRef<"Sport", 'String'>
    readonly imageUrl: FieldRef<"Sport", 'String'>
    readonly website: FieldRef<"Sport", 'String'>
    readonly areaId: FieldRef<"Sport", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Sport findUnique
   */
  export type SportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport findUniqueOrThrow
   */
  export type SportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport findFirst
   */
  export type SportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sports.
     */
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport findFirstOrThrow
   */
  export type SportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sports.
     */
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport findMany
   */
  export type SportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sports to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport create
   */
  export type SportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The data needed to create a Sport.
     */
    data: XOR<SportCreateInput, SportUncheckedCreateInput>
  }

  /**
   * Sport createMany
   */
  export type SportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sports.
     */
    data: SportCreateManyInput | SportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sport createManyAndReturn
   */
  export type SportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * The data used to create many Sports.
     */
    data: SportCreateManyInput | SportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sport update
   */
  export type SportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The data needed to update a Sport.
     */
    data: XOR<SportUpdateInput, SportUncheckedUpdateInput>
    /**
     * Choose, which Sport to update.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport updateMany
   */
  export type SportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sports.
     */
    data: XOR<SportUpdateManyMutationInput, SportUncheckedUpdateManyInput>
    /**
     * Filter which Sports to update
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to update.
     */
    limit?: number
  }

  /**
   * Sport updateManyAndReturn
   */
  export type SportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * The data used to update Sports.
     */
    data: XOR<SportUpdateManyMutationInput, SportUncheckedUpdateManyInput>
    /**
     * Filter which Sports to update
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sport upsert
   */
  export type SportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The filter to search for the Sport to update in case it exists.
     */
    where: SportWhereUniqueInput
    /**
     * In case the Sport found by the `where` argument doesn't exist, create a new Sport with this data.
     */
    create: XOR<SportCreateInput, SportUncheckedCreateInput>
    /**
     * In case the Sport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportUpdateInput, SportUncheckedUpdateInput>
  }

  /**
   * Sport delete
   */
  export type SportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter which Sport to delete.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport deleteMany
   */
  export type SportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sports to delete
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to delete.
     */
    limit?: number
  }

  /**
   * Sport without action
   */
  export type SportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    id: number | null
    builtYear: number | null
    lotSizeSqFt: number | null
    parkingSpaces: number | null
    areaId: number | null
  }

  export type PropertySumAggregateOutputType = {
    id: number | null
    builtYear: number | null
    lotSizeSqFt: number | null
    parkingSpaces: number | null
    areaId: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: number | null
    address: string | null
    price: string | null
    description: string | null
    fullDescription: string | null
    type: string | null
    builtYear: number | null
    lotSizeSqFt: number | null
    parkingSpaces: number | null
    inUnitLaundry: boolean | null
    district: string | null
    areaId: number | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: number | null
    address: string | null
    price: string | null
    description: string | null
    fullDescription: string | null
    type: string | null
    builtYear: number | null
    lotSizeSqFt: number | null
    parkingSpaces: number | null
    inUnitLaundry: boolean | null
    district: string | null
    areaId: number | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    address: number
    price: number
    description: number
    fullDescription: number
    imageUrls: number
    type: number
    builtYear: number
    lotSizeSqFt: number
    parkingSpaces: number
    inUnitLaundry: number
    district: number
    areaId: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    id?: true
    builtYear?: true
    lotSizeSqFt?: true
    parkingSpaces?: true
    areaId?: true
  }

  export type PropertySumAggregateInputType = {
    id?: true
    builtYear?: true
    lotSizeSqFt?: true
    parkingSpaces?: true
    areaId?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    address?: true
    price?: true
    description?: true
    fullDescription?: true
    type?: true
    builtYear?: true
    lotSizeSqFt?: true
    parkingSpaces?: true
    inUnitLaundry?: true
    district?: true
    areaId?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    address?: true
    price?: true
    description?: true
    fullDescription?: true
    type?: true
    builtYear?: true
    lotSizeSqFt?: true
    parkingSpaces?: true
    inUnitLaundry?: true
    district?: true
    areaId?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    address?: true
    price?: true
    description?: true
    fullDescription?: true
    imageUrls?: true
    type?: true
    builtYear?: true
    lotSizeSqFt?: true
    parkingSpaces?: true
    inUnitLaundry?: true
    district?: true
    areaId?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: number
    address: string
    price: string
    description: string
    fullDescription: string | null
    imageUrls: string[]
    type: string
    builtYear: number
    lotSizeSqFt: number
    parkingSpaces: number
    inUnitLaundry: boolean
    district: string
    areaId: number
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    price?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrls?: boolean
    type?: boolean
    builtYear?: boolean
    lotSizeSqFt?: boolean
    parkingSpaces?: boolean
    inUnitLaundry?: boolean
    district?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    price?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrls?: boolean
    type?: boolean
    builtYear?: boolean
    lotSizeSqFt?: boolean
    parkingSpaces?: boolean
    inUnitLaundry?: boolean
    district?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    price?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrls?: boolean
    type?: boolean
    builtYear?: boolean
    lotSizeSqFt?: boolean
    parkingSpaces?: boolean
    inUnitLaundry?: boolean
    district?: boolean
    areaId?: boolean
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    address?: boolean
    price?: boolean
    description?: boolean
    fullDescription?: boolean
    imageUrls?: boolean
    type?: boolean
    builtYear?: boolean
    lotSizeSqFt?: boolean
    parkingSpaces?: boolean
    inUnitLaundry?: boolean
    district?: boolean
    areaId?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "price" | "description" | "fullDescription" | "imageUrls" | "type" | "builtYear" | "lotSizeSqFt" | "parkingSpaces" | "inUnitLaundry" | "district" | "areaId", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | RecommendedAreaDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      area: Prisma.$RecommendedAreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      address: string
      price: string
      description: string
      fullDescription: string | null
      imageUrls: string[]
      type: string
      builtYear: number
      lotSizeSqFt: number
      parkingSpaces: number
      inUnitLaundry: boolean
      district: string
      areaId: number
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends RecommendedAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendedAreaDefaultArgs<ExtArgs>>): Prisma__RecommendedAreaClient<$Result.GetResult<Prisma.$RecommendedAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'Int'>
    readonly address: FieldRef<"Property", 'String'>
    readonly price: FieldRef<"Property", 'String'>
    readonly description: FieldRef<"Property", 'String'>
    readonly fullDescription: FieldRef<"Property", 'String'>
    readonly imageUrls: FieldRef<"Property", 'String[]'>
    readonly type: FieldRef<"Property", 'String'>
    readonly builtYear: FieldRef<"Property", 'Int'>
    readonly lotSizeSqFt: FieldRef<"Property", 'Int'>
    readonly parkingSpaces: FieldRef<"Property", 'Int'>
    readonly inUnitLaundry: FieldRef<"Property", 'Boolean'>
    readonly district: FieldRef<"Property", 'String'>
    readonly areaId: FieldRef<"Property", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model PropertySuggestion
   */

  export type AggregatePropertySuggestion = {
    _count: PropertySuggestionCountAggregateOutputType | null
    _avg: PropertySuggestionAvgAggregateOutputType | null
    _sum: PropertySuggestionSumAggregateOutputType | null
    _min: PropertySuggestionMinAggregateOutputType | null
    _max: PropertySuggestionMaxAggregateOutputType | null
  }

  export type PropertySuggestionAvgAggregateOutputType = {
    id: number | null
    recommendationId: number | null
  }

  export type PropertySuggestionSumAggregateOutputType = {
    id: number | null
    recommendationId: number | null
  }

  export type PropertySuggestionMinAggregateOutputType = {
    id: number | null
    type: string | null
    idealFor: string | null
    priceRange: string | null
    fullDescription: string | null
    recommendationId: number | null
  }

  export type PropertySuggestionMaxAggregateOutputType = {
    id: number | null
    type: string | null
    idealFor: string | null
    priceRange: string | null
    fullDescription: string | null
    recommendationId: number | null
  }

  export type PropertySuggestionCountAggregateOutputType = {
    id: number
    type: number
    idealFor: number
    priceRange: number
    fullDescription: number
    recommendationId: number
    _all: number
  }


  export type PropertySuggestionAvgAggregateInputType = {
    id?: true
    recommendationId?: true
  }

  export type PropertySuggestionSumAggregateInputType = {
    id?: true
    recommendationId?: true
  }

  export type PropertySuggestionMinAggregateInputType = {
    id?: true
    type?: true
    idealFor?: true
    priceRange?: true
    fullDescription?: true
    recommendationId?: true
  }

  export type PropertySuggestionMaxAggregateInputType = {
    id?: true
    type?: true
    idealFor?: true
    priceRange?: true
    fullDescription?: true
    recommendationId?: true
  }

  export type PropertySuggestionCountAggregateInputType = {
    id?: true
    type?: true
    idealFor?: true
    priceRange?: true
    fullDescription?: true
    recommendationId?: true
    _all?: true
  }

  export type PropertySuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySuggestion to aggregate.
     */
    where?: PropertySuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySuggestions to fetch.
     */
    orderBy?: PropertySuggestionOrderByWithRelationInput | PropertySuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertySuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertySuggestions
    **/
    _count?: true | PropertySuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertySuggestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySuggestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertySuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertySuggestionMaxAggregateInputType
  }

  export type GetPropertySuggestionAggregateType<T extends PropertySuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertySuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertySuggestion[P]>
      : GetScalarType<T[P], AggregatePropertySuggestion[P]>
  }




  export type PropertySuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySuggestionWhereInput
    orderBy?: PropertySuggestionOrderByWithAggregationInput | PropertySuggestionOrderByWithAggregationInput[]
    by: PropertySuggestionScalarFieldEnum[] | PropertySuggestionScalarFieldEnum
    having?: PropertySuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertySuggestionCountAggregateInputType | true
    _avg?: PropertySuggestionAvgAggregateInputType
    _sum?: PropertySuggestionSumAggregateInputType
    _min?: PropertySuggestionMinAggregateInputType
    _max?: PropertySuggestionMaxAggregateInputType
  }

  export type PropertySuggestionGroupByOutputType = {
    id: number
    type: string
    idealFor: string
    priceRange: string
    fullDescription: string | null
    recommendationId: number
    _count: PropertySuggestionCountAggregateOutputType | null
    _avg: PropertySuggestionAvgAggregateOutputType | null
    _sum: PropertySuggestionSumAggregateOutputType | null
    _min: PropertySuggestionMinAggregateOutputType | null
    _max: PropertySuggestionMaxAggregateOutputType | null
  }

  type GetPropertySuggestionGroupByPayload<T extends PropertySuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertySuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertySuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertySuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], PropertySuggestionGroupByOutputType[P]>
        }
      >
    >


  export type PropertySuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    idealFor?: boolean
    priceRange?: boolean
    fullDescription?: boolean
    recommendationId?: boolean
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySuggestion"]>

  export type PropertySuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    idealFor?: boolean
    priceRange?: boolean
    fullDescription?: boolean
    recommendationId?: boolean
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySuggestion"]>

  export type PropertySuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    idealFor?: boolean
    priceRange?: boolean
    fullDescription?: boolean
    recommendationId?: boolean
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertySuggestion"]>

  export type PropertySuggestionSelectScalar = {
    id?: boolean
    type?: boolean
    idealFor?: boolean
    priceRange?: boolean
    fullDescription?: boolean
    recommendationId?: boolean
  }

  export type PropertySuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "idealFor" | "priceRange" | "fullDescription" | "recommendationId", ExtArgs["result"]["propertySuggestion"]>
  export type PropertySuggestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }
  export type PropertySuggestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }
  export type PropertySuggestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recommendation?: boolean | RecommendationDefaultArgs<ExtArgs>
  }

  export type $PropertySuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertySuggestion"
    objects: {
      recommendation: Prisma.$RecommendationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      idealFor: string
      priceRange: string
      fullDescription: string | null
      recommendationId: number
    }, ExtArgs["result"]["propertySuggestion"]>
    composites: {}
  }

  type PropertySuggestionGetPayload<S extends boolean | null | undefined | PropertySuggestionDefaultArgs> = $Result.GetResult<Prisma.$PropertySuggestionPayload, S>

  type PropertySuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertySuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertySuggestionCountAggregateInputType | true
    }

  export interface PropertySuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertySuggestion'], meta: { name: 'PropertySuggestion' } }
    /**
     * Find zero or one PropertySuggestion that matches the filter.
     * @param {PropertySuggestionFindUniqueArgs} args - Arguments to find a PropertySuggestion
     * @example
     * // Get one PropertySuggestion
     * const propertySuggestion = await prisma.propertySuggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertySuggestionFindUniqueArgs>(args: SelectSubset<T, PropertySuggestionFindUniqueArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertySuggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertySuggestionFindUniqueOrThrowArgs} args - Arguments to find a PropertySuggestion
     * @example
     * // Get one PropertySuggestion
     * const propertySuggestion = await prisma.propertySuggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertySuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertySuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySuggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySuggestionFindFirstArgs} args - Arguments to find a PropertySuggestion
     * @example
     * // Get one PropertySuggestion
     * const propertySuggestion = await prisma.propertySuggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertySuggestionFindFirstArgs>(args?: SelectSubset<T, PropertySuggestionFindFirstArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySuggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySuggestionFindFirstOrThrowArgs} args - Arguments to find a PropertySuggestion
     * @example
     * // Get one PropertySuggestion
     * const propertySuggestion = await prisma.propertySuggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertySuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertySuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertySuggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertySuggestions
     * const propertySuggestions = await prisma.propertySuggestion.findMany()
     * 
     * // Get first 10 PropertySuggestions
     * const propertySuggestions = await prisma.propertySuggestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertySuggestionWithIdOnly = await prisma.propertySuggestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertySuggestionFindManyArgs>(args?: SelectSubset<T, PropertySuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertySuggestion.
     * @param {PropertySuggestionCreateArgs} args - Arguments to create a PropertySuggestion.
     * @example
     * // Create one PropertySuggestion
     * const PropertySuggestion = await prisma.propertySuggestion.create({
     *   data: {
     *     // ... data to create a PropertySuggestion
     *   }
     * })
     * 
     */
    create<T extends PropertySuggestionCreateArgs>(args: SelectSubset<T, PropertySuggestionCreateArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertySuggestions.
     * @param {PropertySuggestionCreateManyArgs} args - Arguments to create many PropertySuggestions.
     * @example
     * // Create many PropertySuggestions
     * const propertySuggestion = await prisma.propertySuggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertySuggestionCreateManyArgs>(args?: SelectSubset<T, PropertySuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertySuggestions and returns the data saved in the database.
     * @param {PropertySuggestionCreateManyAndReturnArgs} args - Arguments to create many PropertySuggestions.
     * @example
     * // Create many PropertySuggestions
     * const propertySuggestion = await prisma.propertySuggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertySuggestions and only return the `id`
     * const propertySuggestionWithIdOnly = await prisma.propertySuggestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertySuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertySuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertySuggestion.
     * @param {PropertySuggestionDeleteArgs} args - Arguments to delete one PropertySuggestion.
     * @example
     * // Delete one PropertySuggestion
     * const PropertySuggestion = await prisma.propertySuggestion.delete({
     *   where: {
     *     // ... filter to delete one PropertySuggestion
     *   }
     * })
     * 
     */
    delete<T extends PropertySuggestionDeleteArgs>(args: SelectSubset<T, PropertySuggestionDeleteArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertySuggestion.
     * @param {PropertySuggestionUpdateArgs} args - Arguments to update one PropertySuggestion.
     * @example
     * // Update one PropertySuggestion
     * const propertySuggestion = await prisma.propertySuggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertySuggestionUpdateArgs>(args: SelectSubset<T, PropertySuggestionUpdateArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertySuggestions.
     * @param {PropertySuggestionDeleteManyArgs} args - Arguments to filter PropertySuggestions to delete.
     * @example
     * // Delete a few PropertySuggestions
     * const { count } = await prisma.propertySuggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertySuggestionDeleteManyArgs>(args?: SelectSubset<T, PropertySuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertySuggestions
     * const propertySuggestion = await prisma.propertySuggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertySuggestionUpdateManyArgs>(args: SelectSubset<T, PropertySuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySuggestions and returns the data updated in the database.
     * @param {PropertySuggestionUpdateManyAndReturnArgs} args - Arguments to update many PropertySuggestions.
     * @example
     * // Update many PropertySuggestions
     * const propertySuggestion = await prisma.propertySuggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertySuggestions and only return the `id`
     * const propertySuggestionWithIdOnly = await prisma.propertySuggestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertySuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertySuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertySuggestion.
     * @param {PropertySuggestionUpsertArgs} args - Arguments to update or create a PropertySuggestion.
     * @example
     * // Update or create a PropertySuggestion
     * const propertySuggestion = await prisma.propertySuggestion.upsert({
     *   create: {
     *     // ... data to create a PropertySuggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertySuggestion we want to update
     *   }
     * })
     */
    upsert<T extends PropertySuggestionUpsertArgs>(args: SelectSubset<T, PropertySuggestionUpsertArgs<ExtArgs>>): Prisma__PropertySuggestionClient<$Result.GetResult<Prisma.$PropertySuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertySuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySuggestionCountArgs} args - Arguments to filter PropertySuggestions to count.
     * @example
     * // Count the number of PropertySuggestions
     * const count = await prisma.propertySuggestion.count({
     *   where: {
     *     // ... the filter for the PropertySuggestions we want to count
     *   }
     * })
    **/
    count<T extends PropertySuggestionCountArgs>(
      args?: Subset<T, PropertySuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertySuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertySuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertySuggestionAggregateArgs>(args: Subset<T, PropertySuggestionAggregateArgs>): Prisma.PrismaPromise<GetPropertySuggestionAggregateType<T>>

    /**
     * Group by PropertySuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertySuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertySuggestionGroupByArgs['orderBy'] }
        : { orderBy?: PropertySuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertySuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertySuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertySuggestion model
   */
  readonly fields: PropertySuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertySuggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertySuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recommendation<T extends RecommendationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecommendationDefaultArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertySuggestion model
   */
  interface PropertySuggestionFieldRefs {
    readonly id: FieldRef<"PropertySuggestion", 'Int'>
    readonly type: FieldRef<"PropertySuggestion", 'String'>
    readonly idealFor: FieldRef<"PropertySuggestion", 'String'>
    readonly priceRange: FieldRef<"PropertySuggestion", 'String'>
    readonly fullDescription: FieldRef<"PropertySuggestion", 'String'>
    readonly recommendationId: FieldRef<"PropertySuggestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PropertySuggestion findUnique
   */
  export type PropertySuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * Filter, which PropertySuggestion to fetch.
     */
    where: PropertySuggestionWhereUniqueInput
  }

  /**
   * PropertySuggestion findUniqueOrThrow
   */
  export type PropertySuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * Filter, which PropertySuggestion to fetch.
     */
    where: PropertySuggestionWhereUniqueInput
  }

  /**
   * PropertySuggestion findFirst
   */
  export type PropertySuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * Filter, which PropertySuggestion to fetch.
     */
    where?: PropertySuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySuggestions to fetch.
     */
    orderBy?: PropertySuggestionOrderByWithRelationInput | PropertySuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySuggestions.
     */
    cursor?: PropertySuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySuggestions.
     */
    distinct?: PropertySuggestionScalarFieldEnum | PropertySuggestionScalarFieldEnum[]
  }

  /**
   * PropertySuggestion findFirstOrThrow
   */
  export type PropertySuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * Filter, which PropertySuggestion to fetch.
     */
    where?: PropertySuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySuggestions to fetch.
     */
    orderBy?: PropertySuggestionOrderByWithRelationInput | PropertySuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySuggestions.
     */
    cursor?: PropertySuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySuggestions.
     */
    distinct?: PropertySuggestionScalarFieldEnum | PropertySuggestionScalarFieldEnum[]
  }

  /**
   * PropertySuggestion findMany
   */
  export type PropertySuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * Filter, which PropertySuggestions to fetch.
     */
    where?: PropertySuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySuggestions to fetch.
     */
    orderBy?: PropertySuggestionOrderByWithRelationInput | PropertySuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertySuggestions.
     */
    cursor?: PropertySuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySuggestions.
     */
    skip?: number
    distinct?: PropertySuggestionScalarFieldEnum | PropertySuggestionScalarFieldEnum[]
  }

  /**
   * PropertySuggestion create
   */
  export type PropertySuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertySuggestion.
     */
    data: XOR<PropertySuggestionCreateInput, PropertySuggestionUncheckedCreateInput>
  }

  /**
   * PropertySuggestion createMany
   */
  export type PropertySuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertySuggestions.
     */
    data: PropertySuggestionCreateManyInput | PropertySuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertySuggestion createManyAndReturn
   */
  export type PropertySuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many PropertySuggestions.
     */
    data: PropertySuggestionCreateManyInput | PropertySuggestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySuggestion update
   */
  export type PropertySuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertySuggestion.
     */
    data: XOR<PropertySuggestionUpdateInput, PropertySuggestionUncheckedUpdateInput>
    /**
     * Choose, which PropertySuggestion to update.
     */
    where: PropertySuggestionWhereUniqueInput
  }

  /**
   * PropertySuggestion updateMany
   */
  export type PropertySuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertySuggestions.
     */
    data: XOR<PropertySuggestionUpdateManyMutationInput, PropertySuggestionUncheckedUpdateManyInput>
    /**
     * Filter which PropertySuggestions to update
     */
    where?: PropertySuggestionWhereInput
    /**
     * Limit how many PropertySuggestions to update.
     */
    limit?: number
  }

  /**
   * PropertySuggestion updateManyAndReturn
   */
  export type PropertySuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * The data used to update PropertySuggestions.
     */
    data: XOR<PropertySuggestionUpdateManyMutationInput, PropertySuggestionUncheckedUpdateManyInput>
    /**
     * Filter which PropertySuggestions to update
     */
    where?: PropertySuggestionWhereInput
    /**
     * Limit how many PropertySuggestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertySuggestion upsert
   */
  export type PropertySuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertySuggestion to update in case it exists.
     */
    where: PropertySuggestionWhereUniqueInput
    /**
     * In case the PropertySuggestion found by the `where` argument doesn't exist, create a new PropertySuggestion with this data.
     */
    create: XOR<PropertySuggestionCreateInput, PropertySuggestionUncheckedCreateInput>
    /**
     * In case the PropertySuggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertySuggestionUpdateInput, PropertySuggestionUncheckedUpdateInput>
  }

  /**
   * PropertySuggestion delete
   */
  export type PropertySuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
    /**
     * Filter which PropertySuggestion to delete.
     */
    where: PropertySuggestionWhereUniqueInput
  }

  /**
   * PropertySuggestion deleteMany
   */
  export type PropertySuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySuggestions to delete
     */
    where?: PropertySuggestionWhereInput
    /**
     * Limit how many PropertySuggestions to delete.
     */
    limit?: number
  }

  /**
   * PropertySuggestion without action
   */
  export type PropertySuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySuggestion
     */
    select?: PropertySuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySuggestion
     */
    omit?: PropertySuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertySuggestionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    createdAt: 'createdAt',
    countryCode: 'countryCode',
    name: 'name',
    state: 'state',
    city: 'city',
    environment: 'environment',
    education1: 'education1',
    education2: 'education2',
    family: 'family',
    employment1: 'employment1',
    employment2: 'employment2',
    socialLife: 'socialLife',
    hobbies: 'hobbies',
    transportation: 'transportation',
    pets: 'pets',
    greenSpace: 'greenSpace',
    shopping: 'shopping',
    restaurants: 'restaurants',
    occupancy: 'occupancy',
    property: 'property',
    timeframe: 'timeframe',
    priceRange: 'priceRange',
    downPayment: 'downPayment',
    employmentStatus: 'employmentStatus',
    grossAnnual: 'grossAnnual',
    credit: 'credit'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OtpCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    phone: 'phone',
    email: 'email',
    countryCode: 'countryCode',
    expiresAt: 'expiresAt',
    userId: 'userId',
    createdAt: 'createdAt',
    attempts: 'attempts'
  };

  export type OtpCodeScalarFieldEnum = (typeof OtpCodeScalarFieldEnum)[keyof typeof OtpCodeScalarFieldEnum]


  export const JourneyScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    completedAt: 'completedAt',
    status: 'status',
    label: 'label',
    selectedState: 'selectedState',
    selectedCities: 'selectedCities',
    inputs: 'inputs',
    index: 'index',
    userId: 'userId'
  };

  export type JourneyScalarFieldEnum = (typeof JourneyScalarFieldEnum)[keyof typeof JourneyScalarFieldEnum]


  export const RecommendationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    journeyId: 'journeyId'
  };

  export type RecommendationScalarFieldEnum = (typeof RecommendationScalarFieldEnum)[keyof typeof RecommendationScalarFieldEnum]


  export const RecommendedAreaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    state: 'state',
    reason: 'reason',
    imageUrl: 'imageUrl',
    fullDescription: 'fullDescription',
    recommendationId: 'recommendationId',
    placesOfInterest: 'placesOfInterest',
    lifestyleTags: 'lifestyleTags'
  };

  export type RecommendedAreaScalarFieldEnum = (typeof RecommendedAreaScalarFieldEnum)[keyof typeof RecommendedAreaScalarFieldEnum]


  export const RaceEthnicityScalarFieldEnum: {
    id: 'id',
    white: 'white',
    hispanic: 'hispanic',
    asian: 'asian',
    black: 'black',
    other: 'other',
    areaId: 'areaId'
  };

  export type RaceEthnicityScalarFieldEnum = (typeof RaceEthnicityScalarFieldEnum)[keyof typeof RaceEthnicityScalarFieldEnum]


  export const IncomeLevelsScalarFieldEnum: {
    id: 'id',
    perCapitaIncome: 'perCapitaIncome',
    medianHouseholdIncome: 'medianHouseholdIncome',
    areaId: 'areaId'
  };

  export type IncomeLevelsScalarFieldEnum = (typeof IncomeLevelsScalarFieldEnum)[keyof typeof IncomeLevelsScalarFieldEnum]


  export const CrimeDataScalarFieldEnum: {
    id: 'id',
    violentCrimes: 'violentCrimes',
    propertyCrimes: 'propertyCrimes',
    totalCrimes: 'totalCrimes',
    violentRate: 'violentRate',
    propertyRate: 'propertyRate',
    totalRate: 'totalRate',
    areaId: 'areaId'
  };

  export type CrimeDataScalarFieldEnum = (typeof CrimeDataScalarFieldEnum)[keyof typeof CrimeDataScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fullDescription: 'fullDescription',
    imageUrl: 'imageUrl',
    website: 'website',
    areaId: 'areaId'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const SocialLifeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fullDescription: 'fullDescription',
    imageUrl: 'imageUrl',
    website: 'website',
    areaId: 'areaId'
  };

  export type SocialLifeScalarFieldEnum = (typeof SocialLifeScalarFieldEnum)[keyof typeof SocialLifeScalarFieldEnum]


  export const ShoppingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fullDescription: 'fullDescription',
    imageUrl: 'imageUrl',
    website: 'website',
    areaId: 'areaId'
  };

  export type ShoppingScalarFieldEnum = (typeof ShoppingScalarFieldEnum)[keyof typeof ShoppingScalarFieldEnum]


  export const GreenSpaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fullDescription: 'fullDescription',
    imageUrl: 'imageUrl',
    website: 'website',
    areaId: 'areaId'
  };

  export type GreenSpaceScalarFieldEnum = (typeof GreenSpaceScalarFieldEnum)[keyof typeof GreenSpaceScalarFieldEnum]


  export const SportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fullDescription: 'fullDescription',
    imageUrl: 'imageUrl',
    website: 'website',
    areaId: 'areaId'
  };

  export type SportScalarFieldEnum = (typeof SportScalarFieldEnum)[keyof typeof SportScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    address: 'address',
    price: 'price',
    description: 'description',
    fullDescription: 'fullDescription',
    imageUrls: 'imageUrls',
    type: 'type',
    builtYear: 'builtYear',
    lotSizeSqFt: 'lotSizeSqFt',
    parkingSpaces: 'parkingSpaces',
    inUnitLaundry: 'inUnitLaundry',
    district: 'district',
    areaId: 'areaId'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const PropertySuggestionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    idealFor: 'idealFor',
    priceRange: 'priceRange',
    fullDescription: 'fullDescription',
    recommendationId: 'recommendationId'
  };

  export type PropertySuggestionScalarFieldEnum = (typeof PropertySuggestionScalarFieldEnum)[keyof typeof PropertySuggestionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'JourneyStatus'
   */
  export type EnumJourneyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JourneyStatus'>
    


  /**
   * Reference to a field of type 'JourneyStatus[]'
   */
  export type ListEnumJourneyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JourneyStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    countryCode?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    city?: StringNullableListFilter<"User">
    environment?: StringNullableFilter<"User"> | string | null
    education1?: StringNullableListFilter<"User">
    education2?: StringNullableListFilter<"User">
    family?: StringNullableListFilter<"User">
    employment1?: StringNullableListFilter<"User">
    employment2?: StringNullableListFilter<"User">
    socialLife?: StringNullableListFilter<"User">
    hobbies?: StringNullableListFilter<"User">
    transportation?: StringNullableListFilter<"User">
    pets?: StringNullableListFilter<"User">
    greenSpace?: StringNullableListFilter<"User">
    shopping?: StringNullableListFilter<"User">
    restaurants?: StringNullableListFilter<"User">
    occupancy?: StringNullableFilter<"User"> | string | null
    property?: StringNullableFilter<"User"> | string | null
    timeframe?: StringNullableFilter<"User"> | string | null
    priceRange?: StringNullableFilter<"User"> | string | null
    downPayment?: StringNullableFilter<"User"> | string | null
    employmentStatus?: StringNullableFilter<"User"> | string | null
    grossAnnual?: IntNullableFilter<"User"> | number | null
    credit?: StringNullableFilter<"User"> | string | null
    otpCodes?: OtpCodeListRelationFilter
    Recommendation?: RecommendationListRelationFilter
    journeys?: JourneyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    countryCode?: SortOrder
    name?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrder
    environment?: SortOrderInput | SortOrder
    education1?: SortOrder
    education2?: SortOrder
    family?: SortOrder
    employment1?: SortOrder
    employment2?: SortOrder
    socialLife?: SortOrder
    hobbies?: SortOrder
    transportation?: SortOrder
    pets?: SortOrder
    greenSpace?: SortOrder
    shopping?: SortOrder
    restaurants?: SortOrder
    occupancy?: SortOrderInput | SortOrder
    property?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    priceRange?: SortOrderInput | SortOrder
    downPayment?: SortOrderInput | SortOrder
    employmentStatus?: SortOrderInput | SortOrder
    grossAnnual?: SortOrderInput | SortOrder
    credit?: SortOrderInput | SortOrder
    otpCodes?: OtpCodeOrderByRelationAggregateInput
    Recommendation?: RecommendationOrderByRelationAggregateInput
    journeys?: JourneyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    phone?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    countryCode?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    city?: StringNullableListFilter<"User">
    environment?: StringNullableFilter<"User"> | string | null
    education1?: StringNullableListFilter<"User">
    education2?: StringNullableListFilter<"User">
    family?: StringNullableListFilter<"User">
    employment1?: StringNullableListFilter<"User">
    employment2?: StringNullableListFilter<"User">
    socialLife?: StringNullableListFilter<"User">
    hobbies?: StringNullableListFilter<"User">
    transportation?: StringNullableListFilter<"User">
    pets?: StringNullableListFilter<"User">
    greenSpace?: StringNullableListFilter<"User">
    shopping?: StringNullableListFilter<"User">
    restaurants?: StringNullableListFilter<"User">
    occupancy?: StringNullableFilter<"User"> | string | null
    property?: StringNullableFilter<"User"> | string | null
    timeframe?: StringNullableFilter<"User"> | string | null
    priceRange?: StringNullableFilter<"User"> | string | null
    downPayment?: StringNullableFilter<"User"> | string | null
    employmentStatus?: StringNullableFilter<"User"> | string | null
    grossAnnual?: IntNullableFilter<"User"> | number | null
    credit?: StringNullableFilter<"User"> | string | null
    otpCodes?: OtpCodeListRelationFilter
    Recommendation?: RecommendationListRelationFilter
    journeys?: JourneyListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    countryCode?: SortOrder
    name?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrder
    environment?: SortOrderInput | SortOrder
    education1?: SortOrder
    education2?: SortOrder
    family?: SortOrder
    employment1?: SortOrder
    employment2?: SortOrder
    socialLife?: SortOrder
    hobbies?: SortOrder
    transportation?: SortOrder
    pets?: SortOrder
    greenSpace?: SortOrder
    shopping?: SortOrder
    restaurants?: SortOrder
    occupancy?: SortOrderInput | SortOrder
    property?: SortOrderInput | SortOrder
    timeframe?: SortOrderInput | SortOrder
    priceRange?: SortOrderInput | SortOrder
    downPayment?: SortOrderInput | SortOrder
    employmentStatus?: SortOrderInput | SortOrder
    grossAnnual?: SortOrderInput | SortOrder
    credit?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    countryCode?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableListFilter<"User">
    environment?: StringNullableWithAggregatesFilter<"User"> | string | null
    education1?: StringNullableListFilter<"User">
    education2?: StringNullableListFilter<"User">
    family?: StringNullableListFilter<"User">
    employment1?: StringNullableListFilter<"User">
    employment2?: StringNullableListFilter<"User">
    socialLife?: StringNullableListFilter<"User">
    hobbies?: StringNullableListFilter<"User">
    transportation?: StringNullableListFilter<"User">
    pets?: StringNullableListFilter<"User">
    greenSpace?: StringNullableListFilter<"User">
    shopping?: StringNullableListFilter<"User">
    restaurants?: StringNullableListFilter<"User">
    occupancy?: StringNullableWithAggregatesFilter<"User"> | string | null
    property?: StringNullableWithAggregatesFilter<"User"> | string | null
    timeframe?: StringNullableWithAggregatesFilter<"User"> | string | null
    priceRange?: StringNullableWithAggregatesFilter<"User"> | string | null
    downPayment?: StringNullableWithAggregatesFilter<"User"> | string | null
    employmentStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    grossAnnual?: IntNullableWithAggregatesFilter<"User"> | number | null
    credit?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type OtpCodeWhereInput = {
    AND?: OtpCodeWhereInput | OtpCodeWhereInput[]
    OR?: OtpCodeWhereInput[]
    NOT?: OtpCodeWhereInput | OtpCodeWhereInput[]
    id?: IntFilter<"OtpCode"> | number
    code?: StringFilter<"OtpCode"> | string
    phone?: StringFilter<"OtpCode"> | string
    email?: StringFilter<"OtpCode"> | string
    countryCode?: StringFilter<"OtpCode"> | string
    expiresAt?: DateTimeFilter<"OtpCode"> | Date | string
    userId?: IntNullableFilter<"OtpCode"> | number | null
    createdAt?: DateTimeFilter<"OtpCode"> | Date | string
    attempts?: IntFilter<"OtpCode"> | number
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type OtpCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    countryCode?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OtpCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OtpCodeWhereInput | OtpCodeWhereInput[]
    OR?: OtpCodeWhereInput[]
    NOT?: OtpCodeWhereInput | OtpCodeWhereInput[]
    code?: StringFilter<"OtpCode"> | string
    phone?: StringFilter<"OtpCode"> | string
    email?: StringFilter<"OtpCode"> | string
    countryCode?: StringFilter<"OtpCode"> | string
    expiresAt?: DateTimeFilter<"OtpCode"> | Date | string
    userId?: IntNullableFilter<"OtpCode"> | number | null
    createdAt?: DateTimeFilter<"OtpCode"> | Date | string
    attempts?: IntFilter<"OtpCode"> | number
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type OtpCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    countryCode?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
    _count?: OtpCodeCountOrderByAggregateInput
    _avg?: OtpCodeAvgOrderByAggregateInput
    _max?: OtpCodeMaxOrderByAggregateInput
    _min?: OtpCodeMinOrderByAggregateInput
    _sum?: OtpCodeSumOrderByAggregateInput
  }

  export type OtpCodeScalarWhereWithAggregatesInput = {
    AND?: OtpCodeScalarWhereWithAggregatesInput | OtpCodeScalarWhereWithAggregatesInput[]
    OR?: OtpCodeScalarWhereWithAggregatesInput[]
    NOT?: OtpCodeScalarWhereWithAggregatesInput | OtpCodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OtpCode"> | number
    code?: StringWithAggregatesFilter<"OtpCode"> | string
    phone?: StringWithAggregatesFilter<"OtpCode"> | string
    email?: StringWithAggregatesFilter<"OtpCode"> | string
    countryCode?: StringWithAggregatesFilter<"OtpCode"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"OtpCode"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"OtpCode"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"OtpCode"> | Date | string
    attempts?: IntWithAggregatesFilter<"OtpCode"> | number
  }

  export type JourneyWhereInput = {
    AND?: JourneyWhereInput | JourneyWhereInput[]
    OR?: JourneyWhereInput[]
    NOT?: JourneyWhereInput | JourneyWhereInput[]
    id?: IntFilter<"Journey"> | number
    createdAt?: DateTimeFilter<"Journey"> | Date | string
    completedAt?: DateTimeNullableFilter<"Journey"> | Date | string | null
    status?: EnumJourneyStatusFilter<"Journey"> | $Enums.JourneyStatus
    label?: StringNullableFilter<"Journey"> | string | null
    selectedState?: StringNullableFilter<"Journey"> | string | null
    selectedCities?: StringNullableListFilter<"Journey">
    inputs?: JsonNullableFilter<"Journey">
    index?: IntFilter<"Journey"> | number
    userId?: IntFilter<"Journey"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    recommendation?: XOR<RecommendationNullableScalarRelationFilter, RecommendationWhereInput> | null
  }

  export type JourneyOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrderInput | SortOrder
    selectedState?: SortOrderInput | SortOrder
    selectedCities?: SortOrder
    inputs?: SortOrderInput | SortOrder
    index?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    recommendation?: RecommendationOrderByWithRelationInput
  }

  export type JourneyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JourneyWhereInput | JourneyWhereInput[]
    OR?: JourneyWhereInput[]
    NOT?: JourneyWhereInput | JourneyWhereInput[]
    createdAt?: DateTimeFilter<"Journey"> | Date | string
    completedAt?: DateTimeNullableFilter<"Journey"> | Date | string | null
    status?: EnumJourneyStatusFilter<"Journey"> | $Enums.JourneyStatus
    label?: StringNullableFilter<"Journey"> | string | null
    selectedState?: StringNullableFilter<"Journey"> | string | null
    selectedCities?: StringNullableListFilter<"Journey">
    inputs?: JsonNullableFilter<"Journey">
    index?: IntFilter<"Journey"> | number
    userId?: IntFilter<"Journey"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    recommendation?: XOR<RecommendationNullableScalarRelationFilter, RecommendationWhereInput> | null
  }, "id">

  export type JourneyOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    label?: SortOrderInput | SortOrder
    selectedState?: SortOrderInput | SortOrder
    selectedCities?: SortOrder
    inputs?: SortOrderInput | SortOrder
    index?: SortOrder
    userId?: SortOrder
    _count?: JourneyCountOrderByAggregateInput
    _avg?: JourneyAvgOrderByAggregateInput
    _max?: JourneyMaxOrderByAggregateInput
    _min?: JourneyMinOrderByAggregateInput
    _sum?: JourneySumOrderByAggregateInput
  }

  export type JourneyScalarWhereWithAggregatesInput = {
    AND?: JourneyScalarWhereWithAggregatesInput | JourneyScalarWhereWithAggregatesInput[]
    OR?: JourneyScalarWhereWithAggregatesInput[]
    NOT?: JourneyScalarWhereWithAggregatesInput | JourneyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Journey"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Journey"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Journey"> | Date | string | null
    status?: EnumJourneyStatusWithAggregatesFilter<"Journey"> | $Enums.JourneyStatus
    label?: StringNullableWithAggregatesFilter<"Journey"> | string | null
    selectedState?: StringNullableWithAggregatesFilter<"Journey"> | string | null
    selectedCities?: StringNullableListFilter<"Journey">
    inputs?: JsonNullableWithAggregatesFilter<"Journey">
    index?: IntWithAggregatesFilter<"Journey"> | number
    userId?: IntWithAggregatesFilter<"Journey"> | number
  }

  export type RecommendationWhereInput = {
    AND?: RecommendationWhereInput | RecommendationWhereInput[]
    OR?: RecommendationWhereInput[]
    NOT?: RecommendationWhereInput | RecommendationWhereInput[]
    id?: IntFilter<"Recommendation"> | number
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    userId?: IntFilter<"Recommendation"> | number
    journeyId?: IntNullableFilter<"Recommendation"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    journey?: XOR<JourneyNullableScalarRelationFilter, JourneyWhereInput> | null
    propertySuggestion?: XOR<PropertySuggestionNullableScalarRelationFilter, PropertySuggestionWhereInput> | null
    areas?: RecommendedAreaListRelationFilter
  }

  export type RecommendationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    journey?: JourneyOrderByWithRelationInput
    propertySuggestion?: PropertySuggestionOrderByWithRelationInput
    areas?: RecommendedAreaOrderByRelationAggregateInput
  }

  export type RecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    journeyId?: number
    AND?: RecommendationWhereInput | RecommendationWhereInput[]
    OR?: RecommendationWhereInput[]
    NOT?: RecommendationWhereInput | RecommendationWhereInput[]
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    userId?: IntFilter<"Recommendation"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    journey?: XOR<JourneyNullableScalarRelationFilter, JourneyWhereInput> | null
    propertySuggestion?: XOR<PropertySuggestionNullableScalarRelationFilter, PropertySuggestionWhereInput> | null
    areas?: RecommendedAreaListRelationFilter
  }, "id" | "journeyId">

  export type RecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyId?: SortOrderInput | SortOrder
    _count?: RecommendationCountOrderByAggregateInput
    _avg?: RecommendationAvgOrderByAggregateInput
    _max?: RecommendationMaxOrderByAggregateInput
    _min?: RecommendationMinOrderByAggregateInput
    _sum?: RecommendationSumOrderByAggregateInput
  }

  export type RecommendationScalarWhereWithAggregatesInput = {
    AND?: RecommendationScalarWhereWithAggregatesInput | RecommendationScalarWhereWithAggregatesInput[]
    OR?: RecommendationScalarWhereWithAggregatesInput[]
    NOT?: RecommendationScalarWhereWithAggregatesInput | RecommendationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Recommendation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Recommendation"> | Date | string
    userId?: IntWithAggregatesFilter<"Recommendation"> | number
    journeyId?: IntNullableWithAggregatesFilter<"Recommendation"> | number | null
  }

  export type RecommendedAreaWhereInput = {
    AND?: RecommendedAreaWhereInput | RecommendedAreaWhereInput[]
    OR?: RecommendedAreaWhereInput[]
    NOT?: RecommendedAreaWhereInput | RecommendedAreaWhereInput[]
    id?: IntFilter<"RecommendedArea"> | number
    name?: StringFilter<"RecommendedArea"> | string
    state?: StringFilter<"RecommendedArea"> | string
    reason?: StringFilter<"RecommendedArea"> | string
    imageUrl?: StringNullableFilter<"RecommendedArea"> | string | null
    fullDescription?: StringNullableFilter<"RecommendedArea"> | string | null
    recommendationId?: IntFilter<"RecommendedArea"> | number
    placesOfInterest?: StringNullableListFilter<"RecommendedArea">
    lifestyleTags?: StringNullableListFilter<"RecommendedArea">
    recommendation?: XOR<RecommendationScalarRelationFilter, RecommendationWhereInput>
    raceEthnicity?: XOR<RaceEthnicityNullableScalarRelationFilter, RaceEthnicityWhereInput> | null
    incomeLevels?: XOR<IncomeLevelsNullableScalarRelationFilter, IncomeLevelsWhereInput> | null
    crimeData?: XOR<CrimeDataNullableScalarRelationFilter, CrimeDataWhereInput> | null
    schools?: SchoolListRelationFilter
    socialLife?: SocialLifeListRelationFilter
    shopping?: ShoppingListRelationFilter
    greenSpaces?: GreenSpaceListRelationFilter
    sports?: SportListRelationFilter
    properties?: PropertyListRelationFilter
  }

  export type RecommendedAreaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    reason?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    fullDescription?: SortOrderInput | SortOrder
    recommendationId?: SortOrder
    placesOfInterest?: SortOrder
    lifestyleTags?: SortOrder
    recommendation?: RecommendationOrderByWithRelationInput
    raceEthnicity?: RaceEthnicityOrderByWithRelationInput
    incomeLevels?: IncomeLevelsOrderByWithRelationInput
    crimeData?: CrimeDataOrderByWithRelationInput
    schools?: SchoolOrderByRelationAggregateInput
    socialLife?: SocialLifeOrderByRelationAggregateInput
    shopping?: ShoppingOrderByRelationAggregateInput
    greenSpaces?: GreenSpaceOrderByRelationAggregateInput
    sports?: SportOrderByRelationAggregateInput
    properties?: PropertyOrderByRelationAggregateInput
  }

  export type RecommendedAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecommendedAreaWhereInput | RecommendedAreaWhereInput[]
    OR?: RecommendedAreaWhereInput[]
    NOT?: RecommendedAreaWhereInput | RecommendedAreaWhereInput[]
    name?: StringFilter<"RecommendedArea"> | string
    state?: StringFilter<"RecommendedArea"> | string
    reason?: StringFilter<"RecommendedArea"> | string
    imageUrl?: StringNullableFilter<"RecommendedArea"> | string | null
    fullDescription?: StringNullableFilter<"RecommendedArea"> | string | null
    recommendationId?: IntFilter<"RecommendedArea"> | number
    placesOfInterest?: StringNullableListFilter<"RecommendedArea">
    lifestyleTags?: StringNullableListFilter<"RecommendedArea">
    recommendation?: XOR<RecommendationScalarRelationFilter, RecommendationWhereInput>
    raceEthnicity?: XOR<RaceEthnicityNullableScalarRelationFilter, RaceEthnicityWhereInput> | null
    incomeLevels?: XOR<IncomeLevelsNullableScalarRelationFilter, IncomeLevelsWhereInput> | null
    crimeData?: XOR<CrimeDataNullableScalarRelationFilter, CrimeDataWhereInput> | null
    schools?: SchoolListRelationFilter
    socialLife?: SocialLifeListRelationFilter
    shopping?: ShoppingListRelationFilter
    greenSpaces?: GreenSpaceListRelationFilter
    sports?: SportListRelationFilter
    properties?: PropertyListRelationFilter
  }, "id">

  export type RecommendedAreaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    reason?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    fullDescription?: SortOrderInput | SortOrder
    recommendationId?: SortOrder
    placesOfInterest?: SortOrder
    lifestyleTags?: SortOrder
    _count?: RecommendedAreaCountOrderByAggregateInput
    _avg?: RecommendedAreaAvgOrderByAggregateInput
    _max?: RecommendedAreaMaxOrderByAggregateInput
    _min?: RecommendedAreaMinOrderByAggregateInput
    _sum?: RecommendedAreaSumOrderByAggregateInput
  }

  export type RecommendedAreaScalarWhereWithAggregatesInput = {
    AND?: RecommendedAreaScalarWhereWithAggregatesInput | RecommendedAreaScalarWhereWithAggregatesInput[]
    OR?: RecommendedAreaScalarWhereWithAggregatesInput[]
    NOT?: RecommendedAreaScalarWhereWithAggregatesInput | RecommendedAreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecommendedArea"> | number
    name?: StringWithAggregatesFilter<"RecommendedArea"> | string
    state?: StringWithAggregatesFilter<"RecommendedArea"> | string
    reason?: StringWithAggregatesFilter<"RecommendedArea"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"RecommendedArea"> | string | null
    fullDescription?: StringNullableWithAggregatesFilter<"RecommendedArea"> | string | null
    recommendationId?: IntWithAggregatesFilter<"RecommendedArea"> | number
    placesOfInterest?: StringNullableListFilter<"RecommendedArea">
    lifestyleTags?: StringNullableListFilter<"RecommendedArea">
  }

  export type RaceEthnicityWhereInput = {
    AND?: RaceEthnicityWhereInput | RaceEthnicityWhereInput[]
    OR?: RaceEthnicityWhereInput[]
    NOT?: RaceEthnicityWhereInput | RaceEthnicityWhereInput[]
    id?: IntFilter<"RaceEthnicity"> | number
    white?: FloatFilter<"RaceEthnicity"> | number
    hispanic?: FloatFilter<"RaceEthnicity"> | number
    asian?: FloatFilter<"RaceEthnicity"> | number
    black?: FloatFilter<"RaceEthnicity"> | number
    other?: FloatFilter<"RaceEthnicity"> | number
    areaId?: IntFilter<"RaceEthnicity"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type RaceEthnicityOrderByWithRelationInput = {
    id?: SortOrder
    white?: SortOrder
    hispanic?: SortOrder
    asian?: SortOrder
    black?: SortOrder
    other?: SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type RaceEthnicityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    areaId?: number
    AND?: RaceEthnicityWhereInput | RaceEthnicityWhereInput[]
    OR?: RaceEthnicityWhereInput[]
    NOT?: RaceEthnicityWhereInput | RaceEthnicityWhereInput[]
    white?: FloatFilter<"RaceEthnicity"> | number
    hispanic?: FloatFilter<"RaceEthnicity"> | number
    asian?: FloatFilter<"RaceEthnicity"> | number
    black?: FloatFilter<"RaceEthnicity"> | number
    other?: FloatFilter<"RaceEthnicity"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id" | "areaId">

  export type RaceEthnicityOrderByWithAggregationInput = {
    id?: SortOrder
    white?: SortOrder
    hispanic?: SortOrder
    asian?: SortOrder
    black?: SortOrder
    other?: SortOrder
    areaId?: SortOrder
    _count?: RaceEthnicityCountOrderByAggregateInput
    _avg?: RaceEthnicityAvgOrderByAggregateInput
    _max?: RaceEthnicityMaxOrderByAggregateInput
    _min?: RaceEthnicityMinOrderByAggregateInput
    _sum?: RaceEthnicitySumOrderByAggregateInput
  }

  export type RaceEthnicityScalarWhereWithAggregatesInput = {
    AND?: RaceEthnicityScalarWhereWithAggregatesInput | RaceEthnicityScalarWhereWithAggregatesInput[]
    OR?: RaceEthnicityScalarWhereWithAggregatesInput[]
    NOT?: RaceEthnicityScalarWhereWithAggregatesInput | RaceEthnicityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RaceEthnicity"> | number
    white?: FloatWithAggregatesFilter<"RaceEthnicity"> | number
    hispanic?: FloatWithAggregatesFilter<"RaceEthnicity"> | number
    asian?: FloatWithAggregatesFilter<"RaceEthnicity"> | number
    black?: FloatWithAggregatesFilter<"RaceEthnicity"> | number
    other?: FloatWithAggregatesFilter<"RaceEthnicity"> | number
    areaId?: IntWithAggregatesFilter<"RaceEthnicity"> | number
  }

  export type IncomeLevelsWhereInput = {
    AND?: IncomeLevelsWhereInput | IncomeLevelsWhereInput[]
    OR?: IncomeLevelsWhereInput[]
    NOT?: IncomeLevelsWhereInput | IncomeLevelsWhereInput[]
    id?: IntFilter<"IncomeLevels"> | number
    perCapitaIncome?: FloatFilter<"IncomeLevels"> | number
    medianHouseholdIncome?: FloatFilter<"IncomeLevels"> | number
    areaId?: IntFilter<"IncomeLevels"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type IncomeLevelsOrderByWithRelationInput = {
    id?: SortOrder
    perCapitaIncome?: SortOrder
    medianHouseholdIncome?: SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type IncomeLevelsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    areaId?: number
    AND?: IncomeLevelsWhereInput | IncomeLevelsWhereInput[]
    OR?: IncomeLevelsWhereInput[]
    NOT?: IncomeLevelsWhereInput | IncomeLevelsWhereInput[]
    perCapitaIncome?: FloatFilter<"IncomeLevels"> | number
    medianHouseholdIncome?: FloatFilter<"IncomeLevels"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id" | "areaId">

  export type IncomeLevelsOrderByWithAggregationInput = {
    id?: SortOrder
    perCapitaIncome?: SortOrder
    medianHouseholdIncome?: SortOrder
    areaId?: SortOrder
    _count?: IncomeLevelsCountOrderByAggregateInput
    _avg?: IncomeLevelsAvgOrderByAggregateInput
    _max?: IncomeLevelsMaxOrderByAggregateInput
    _min?: IncomeLevelsMinOrderByAggregateInput
    _sum?: IncomeLevelsSumOrderByAggregateInput
  }

  export type IncomeLevelsScalarWhereWithAggregatesInput = {
    AND?: IncomeLevelsScalarWhereWithAggregatesInput | IncomeLevelsScalarWhereWithAggregatesInput[]
    OR?: IncomeLevelsScalarWhereWithAggregatesInput[]
    NOT?: IncomeLevelsScalarWhereWithAggregatesInput | IncomeLevelsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IncomeLevels"> | number
    perCapitaIncome?: FloatWithAggregatesFilter<"IncomeLevels"> | number
    medianHouseholdIncome?: FloatWithAggregatesFilter<"IncomeLevels"> | number
    areaId?: IntWithAggregatesFilter<"IncomeLevels"> | number
  }

  export type CrimeDataWhereInput = {
    AND?: CrimeDataWhereInput | CrimeDataWhereInput[]
    OR?: CrimeDataWhereInput[]
    NOT?: CrimeDataWhereInput | CrimeDataWhereInput[]
    id?: IntFilter<"CrimeData"> | number
    violentCrimes?: IntFilter<"CrimeData"> | number
    propertyCrimes?: IntFilter<"CrimeData"> | number
    totalCrimes?: IntFilter<"CrimeData"> | number
    violentRate?: FloatFilter<"CrimeData"> | number
    propertyRate?: FloatFilter<"CrimeData"> | number
    totalRate?: FloatFilter<"CrimeData"> | number
    areaId?: IntFilter<"CrimeData"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type CrimeDataOrderByWithRelationInput = {
    id?: SortOrder
    violentCrimes?: SortOrder
    propertyCrimes?: SortOrder
    totalCrimes?: SortOrder
    violentRate?: SortOrder
    propertyRate?: SortOrder
    totalRate?: SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type CrimeDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    areaId?: number
    AND?: CrimeDataWhereInput | CrimeDataWhereInput[]
    OR?: CrimeDataWhereInput[]
    NOT?: CrimeDataWhereInput | CrimeDataWhereInput[]
    violentCrimes?: IntFilter<"CrimeData"> | number
    propertyCrimes?: IntFilter<"CrimeData"> | number
    totalCrimes?: IntFilter<"CrimeData"> | number
    violentRate?: FloatFilter<"CrimeData"> | number
    propertyRate?: FloatFilter<"CrimeData"> | number
    totalRate?: FloatFilter<"CrimeData"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id" | "areaId">

  export type CrimeDataOrderByWithAggregationInput = {
    id?: SortOrder
    violentCrimes?: SortOrder
    propertyCrimes?: SortOrder
    totalCrimes?: SortOrder
    violentRate?: SortOrder
    propertyRate?: SortOrder
    totalRate?: SortOrder
    areaId?: SortOrder
    _count?: CrimeDataCountOrderByAggregateInput
    _avg?: CrimeDataAvgOrderByAggregateInput
    _max?: CrimeDataMaxOrderByAggregateInput
    _min?: CrimeDataMinOrderByAggregateInput
    _sum?: CrimeDataSumOrderByAggregateInput
  }

  export type CrimeDataScalarWhereWithAggregatesInput = {
    AND?: CrimeDataScalarWhereWithAggregatesInput | CrimeDataScalarWhereWithAggregatesInput[]
    OR?: CrimeDataScalarWhereWithAggregatesInput[]
    NOT?: CrimeDataScalarWhereWithAggregatesInput | CrimeDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CrimeData"> | number
    violentCrimes?: IntWithAggregatesFilter<"CrimeData"> | number
    propertyCrimes?: IntWithAggregatesFilter<"CrimeData"> | number
    totalCrimes?: IntWithAggregatesFilter<"CrimeData"> | number
    violentRate?: FloatWithAggregatesFilter<"CrimeData"> | number
    propertyRate?: FloatWithAggregatesFilter<"CrimeData"> | number
    totalRate?: FloatWithAggregatesFilter<"CrimeData"> | number
    areaId?: IntWithAggregatesFilter<"CrimeData"> | number
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: IntFilter<"School"> | number
    name?: StringFilter<"School"> | string
    description?: StringFilter<"School"> | string
    fullDescription?: StringNullableFilter<"School"> | string | null
    imageUrl?: StringNullableFilter<"School"> | string | null
    website?: StringNullableFilter<"School"> | string | null
    areaId?: IntFilter<"School"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    description?: StringFilter<"School"> | string
    fullDescription?: StringNullableFilter<"School"> | string | null
    imageUrl?: StringNullableFilter<"School"> | string | null
    website?: StringNullableFilter<"School"> | string | null
    areaId?: IntFilter<"School"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"School"> | number
    name?: StringWithAggregatesFilter<"School"> | string
    description?: StringWithAggregatesFilter<"School"> | string
    fullDescription?: StringNullableWithAggregatesFilter<"School"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"School"> | string | null
    website?: StringNullableWithAggregatesFilter<"School"> | string | null
    areaId?: IntWithAggregatesFilter<"School"> | number
  }

  export type SocialLifeWhereInput = {
    AND?: SocialLifeWhereInput | SocialLifeWhereInput[]
    OR?: SocialLifeWhereInput[]
    NOT?: SocialLifeWhereInput | SocialLifeWhereInput[]
    id?: IntFilter<"SocialLife"> | number
    name?: StringFilter<"SocialLife"> | string
    description?: StringFilter<"SocialLife"> | string
    fullDescription?: StringNullableFilter<"SocialLife"> | string | null
    imageUrl?: StringNullableFilter<"SocialLife"> | string | null
    website?: StringNullableFilter<"SocialLife"> | string | null
    areaId?: IntFilter<"SocialLife"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type SocialLifeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type SocialLifeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SocialLifeWhereInput | SocialLifeWhereInput[]
    OR?: SocialLifeWhereInput[]
    NOT?: SocialLifeWhereInput | SocialLifeWhereInput[]
    name?: StringFilter<"SocialLife"> | string
    description?: StringFilter<"SocialLife"> | string
    fullDescription?: StringNullableFilter<"SocialLife"> | string | null
    imageUrl?: StringNullableFilter<"SocialLife"> | string | null
    website?: StringNullableFilter<"SocialLife"> | string | null
    areaId?: IntFilter<"SocialLife"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id">

  export type SocialLifeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    _count?: SocialLifeCountOrderByAggregateInput
    _avg?: SocialLifeAvgOrderByAggregateInput
    _max?: SocialLifeMaxOrderByAggregateInput
    _min?: SocialLifeMinOrderByAggregateInput
    _sum?: SocialLifeSumOrderByAggregateInput
  }

  export type SocialLifeScalarWhereWithAggregatesInput = {
    AND?: SocialLifeScalarWhereWithAggregatesInput | SocialLifeScalarWhereWithAggregatesInput[]
    OR?: SocialLifeScalarWhereWithAggregatesInput[]
    NOT?: SocialLifeScalarWhereWithAggregatesInput | SocialLifeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SocialLife"> | number
    name?: StringWithAggregatesFilter<"SocialLife"> | string
    description?: StringWithAggregatesFilter<"SocialLife"> | string
    fullDescription?: StringNullableWithAggregatesFilter<"SocialLife"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"SocialLife"> | string | null
    website?: StringNullableWithAggregatesFilter<"SocialLife"> | string | null
    areaId?: IntWithAggregatesFilter<"SocialLife"> | number
  }

  export type ShoppingWhereInput = {
    AND?: ShoppingWhereInput | ShoppingWhereInput[]
    OR?: ShoppingWhereInput[]
    NOT?: ShoppingWhereInput | ShoppingWhereInput[]
    id?: IntFilter<"Shopping"> | number
    name?: StringFilter<"Shopping"> | string
    description?: StringFilter<"Shopping"> | string
    fullDescription?: StringNullableFilter<"Shopping"> | string | null
    imageUrl?: StringNullableFilter<"Shopping"> | string | null
    website?: StringNullableFilter<"Shopping"> | string | null
    areaId?: IntFilter<"Shopping"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type ShoppingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type ShoppingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShoppingWhereInput | ShoppingWhereInput[]
    OR?: ShoppingWhereInput[]
    NOT?: ShoppingWhereInput | ShoppingWhereInput[]
    name?: StringFilter<"Shopping"> | string
    description?: StringFilter<"Shopping"> | string
    fullDescription?: StringNullableFilter<"Shopping"> | string | null
    imageUrl?: StringNullableFilter<"Shopping"> | string | null
    website?: StringNullableFilter<"Shopping"> | string | null
    areaId?: IntFilter<"Shopping"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id">

  export type ShoppingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    _count?: ShoppingCountOrderByAggregateInput
    _avg?: ShoppingAvgOrderByAggregateInput
    _max?: ShoppingMaxOrderByAggregateInput
    _min?: ShoppingMinOrderByAggregateInput
    _sum?: ShoppingSumOrderByAggregateInput
  }

  export type ShoppingScalarWhereWithAggregatesInput = {
    AND?: ShoppingScalarWhereWithAggregatesInput | ShoppingScalarWhereWithAggregatesInput[]
    OR?: ShoppingScalarWhereWithAggregatesInput[]
    NOT?: ShoppingScalarWhereWithAggregatesInput | ShoppingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shopping"> | number
    name?: StringWithAggregatesFilter<"Shopping"> | string
    description?: StringWithAggregatesFilter<"Shopping"> | string
    fullDescription?: StringNullableWithAggregatesFilter<"Shopping"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Shopping"> | string | null
    website?: StringNullableWithAggregatesFilter<"Shopping"> | string | null
    areaId?: IntWithAggregatesFilter<"Shopping"> | number
  }

  export type GreenSpaceWhereInput = {
    AND?: GreenSpaceWhereInput | GreenSpaceWhereInput[]
    OR?: GreenSpaceWhereInput[]
    NOT?: GreenSpaceWhereInput | GreenSpaceWhereInput[]
    id?: IntFilter<"GreenSpace"> | number
    name?: StringFilter<"GreenSpace"> | string
    description?: StringFilter<"GreenSpace"> | string
    fullDescription?: StringNullableFilter<"GreenSpace"> | string | null
    imageUrl?: StringNullableFilter<"GreenSpace"> | string | null
    website?: StringNullableFilter<"GreenSpace"> | string | null
    areaId?: IntFilter<"GreenSpace"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type GreenSpaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type GreenSpaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GreenSpaceWhereInput | GreenSpaceWhereInput[]
    OR?: GreenSpaceWhereInput[]
    NOT?: GreenSpaceWhereInput | GreenSpaceWhereInput[]
    name?: StringFilter<"GreenSpace"> | string
    description?: StringFilter<"GreenSpace"> | string
    fullDescription?: StringNullableFilter<"GreenSpace"> | string | null
    imageUrl?: StringNullableFilter<"GreenSpace"> | string | null
    website?: StringNullableFilter<"GreenSpace"> | string | null
    areaId?: IntFilter<"GreenSpace"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id">

  export type GreenSpaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    _count?: GreenSpaceCountOrderByAggregateInput
    _avg?: GreenSpaceAvgOrderByAggregateInput
    _max?: GreenSpaceMaxOrderByAggregateInput
    _min?: GreenSpaceMinOrderByAggregateInput
    _sum?: GreenSpaceSumOrderByAggregateInput
  }

  export type GreenSpaceScalarWhereWithAggregatesInput = {
    AND?: GreenSpaceScalarWhereWithAggregatesInput | GreenSpaceScalarWhereWithAggregatesInput[]
    OR?: GreenSpaceScalarWhereWithAggregatesInput[]
    NOT?: GreenSpaceScalarWhereWithAggregatesInput | GreenSpaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GreenSpace"> | number
    name?: StringWithAggregatesFilter<"GreenSpace"> | string
    description?: StringWithAggregatesFilter<"GreenSpace"> | string
    fullDescription?: StringNullableWithAggregatesFilter<"GreenSpace"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"GreenSpace"> | string | null
    website?: StringNullableWithAggregatesFilter<"GreenSpace"> | string | null
    areaId?: IntWithAggregatesFilter<"GreenSpace"> | number
  }

  export type SportWhereInput = {
    AND?: SportWhereInput | SportWhereInput[]
    OR?: SportWhereInput[]
    NOT?: SportWhereInput | SportWhereInput[]
    id?: IntFilter<"Sport"> | number
    name?: StringFilter<"Sport"> | string
    description?: StringFilter<"Sport"> | string
    fullDescription?: StringNullableFilter<"Sport"> | string | null
    imageUrl?: StringNullableFilter<"Sport"> | string | null
    website?: StringNullableFilter<"Sport"> | string | null
    areaId?: IntFilter<"Sport"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type SportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type SportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SportWhereInput | SportWhereInput[]
    OR?: SportWhereInput[]
    NOT?: SportWhereInput | SportWhereInput[]
    name?: StringFilter<"Sport"> | string
    description?: StringFilter<"Sport"> | string
    fullDescription?: StringNullableFilter<"Sport"> | string | null
    imageUrl?: StringNullableFilter<"Sport"> | string | null
    website?: StringNullableFilter<"Sport"> | string | null
    areaId?: IntFilter<"Sport"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id">

  export type SportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    areaId?: SortOrder
    _count?: SportCountOrderByAggregateInput
    _avg?: SportAvgOrderByAggregateInput
    _max?: SportMaxOrderByAggregateInput
    _min?: SportMinOrderByAggregateInput
    _sum?: SportSumOrderByAggregateInput
  }

  export type SportScalarWhereWithAggregatesInput = {
    AND?: SportScalarWhereWithAggregatesInput | SportScalarWhereWithAggregatesInput[]
    OR?: SportScalarWhereWithAggregatesInput[]
    NOT?: SportScalarWhereWithAggregatesInput | SportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sport"> | number
    name?: StringWithAggregatesFilter<"Sport"> | string
    description?: StringWithAggregatesFilter<"Sport"> | string
    fullDescription?: StringNullableWithAggregatesFilter<"Sport"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Sport"> | string | null
    website?: StringNullableWithAggregatesFilter<"Sport"> | string | null
    areaId?: IntWithAggregatesFilter<"Sport"> | number
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: IntFilter<"Property"> | number
    address?: StringFilter<"Property"> | string
    price?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    fullDescription?: StringNullableFilter<"Property"> | string | null
    imageUrls?: StringNullableListFilter<"Property">
    type?: StringFilter<"Property"> | string
    builtYear?: IntFilter<"Property"> | number
    lotSizeSqFt?: IntFilter<"Property"> | number
    parkingSpaces?: IntFilter<"Property"> | number
    inUnitLaundry?: BoolFilter<"Property"> | boolean
    district?: StringFilter<"Property"> | string
    areaId?: IntFilter<"Property"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    price?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrls?: SortOrder
    type?: SortOrder
    builtYear?: SortOrder
    lotSizeSqFt?: SortOrder
    parkingSpaces?: SortOrder
    inUnitLaundry?: SortOrder
    district?: SortOrder
    areaId?: SortOrder
    area?: RecommendedAreaOrderByWithRelationInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    address?: StringFilter<"Property"> | string
    price?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    fullDescription?: StringNullableFilter<"Property"> | string | null
    imageUrls?: StringNullableListFilter<"Property">
    type?: StringFilter<"Property"> | string
    builtYear?: IntFilter<"Property"> | number
    lotSizeSqFt?: IntFilter<"Property"> | number
    parkingSpaces?: IntFilter<"Property"> | number
    inUnitLaundry?: BoolFilter<"Property"> | boolean
    district?: StringFilter<"Property"> | string
    areaId?: IntFilter<"Property"> | number
    area?: XOR<RecommendedAreaScalarRelationFilter, RecommendedAreaWhereInput>
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    price?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    imageUrls?: SortOrder
    type?: SortOrder
    builtYear?: SortOrder
    lotSizeSqFt?: SortOrder
    parkingSpaces?: SortOrder
    inUnitLaundry?: SortOrder
    district?: SortOrder
    areaId?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Property"> | number
    address?: StringWithAggregatesFilter<"Property"> | string
    price?: StringWithAggregatesFilter<"Property"> | string
    description?: StringWithAggregatesFilter<"Property"> | string
    fullDescription?: StringNullableWithAggregatesFilter<"Property"> | string | null
    imageUrls?: StringNullableListFilter<"Property">
    type?: StringWithAggregatesFilter<"Property"> | string
    builtYear?: IntWithAggregatesFilter<"Property"> | number
    lotSizeSqFt?: IntWithAggregatesFilter<"Property"> | number
    parkingSpaces?: IntWithAggregatesFilter<"Property"> | number
    inUnitLaundry?: BoolWithAggregatesFilter<"Property"> | boolean
    district?: StringWithAggregatesFilter<"Property"> | string
    areaId?: IntWithAggregatesFilter<"Property"> | number
  }

  export type PropertySuggestionWhereInput = {
    AND?: PropertySuggestionWhereInput | PropertySuggestionWhereInput[]
    OR?: PropertySuggestionWhereInput[]
    NOT?: PropertySuggestionWhereInput | PropertySuggestionWhereInput[]
    id?: IntFilter<"PropertySuggestion"> | number
    type?: StringFilter<"PropertySuggestion"> | string
    idealFor?: StringFilter<"PropertySuggestion"> | string
    priceRange?: StringFilter<"PropertySuggestion"> | string
    fullDescription?: StringNullableFilter<"PropertySuggestion"> | string | null
    recommendationId?: IntFilter<"PropertySuggestion"> | number
    recommendation?: XOR<RecommendationScalarRelationFilter, RecommendationWhereInput>
  }

  export type PropertySuggestionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    idealFor?: SortOrder
    priceRange?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    recommendationId?: SortOrder
    recommendation?: RecommendationOrderByWithRelationInput
  }

  export type PropertySuggestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    recommendationId?: number
    AND?: PropertySuggestionWhereInput | PropertySuggestionWhereInput[]
    OR?: PropertySuggestionWhereInput[]
    NOT?: PropertySuggestionWhereInput | PropertySuggestionWhereInput[]
    type?: StringFilter<"PropertySuggestion"> | string
    idealFor?: StringFilter<"PropertySuggestion"> | string
    priceRange?: StringFilter<"PropertySuggestion"> | string
    fullDescription?: StringNullableFilter<"PropertySuggestion"> | string | null
    recommendation?: XOR<RecommendationScalarRelationFilter, RecommendationWhereInput>
  }, "id" | "recommendationId">

  export type PropertySuggestionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    idealFor?: SortOrder
    priceRange?: SortOrder
    fullDescription?: SortOrderInput | SortOrder
    recommendationId?: SortOrder
    _count?: PropertySuggestionCountOrderByAggregateInput
    _avg?: PropertySuggestionAvgOrderByAggregateInput
    _max?: PropertySuggestionMaxOrderByAggregateInput
    _min?: PropertySuggestionMinOrderByAggregateInput
    _sum?: PropertySuggestionSumOrderByAggregateInput
  }

  export type PropertySuggestionScalarWhereWithAggregatesInput = {
    AND?: PropertySuggestionScalarWhereWithAggregatesInput | PropertySuggestionScalarWhereWithAggregatesInput[]
    OR?: PropertySuggestionScalarWhereWithAggregatesInput[]
    NOT?: PropertySuggestionScalarWhereWithAggregatesInput | PropertySuggestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PropertySuggestion"> | number
    type?: StringWithAggregatesFilter<"PropertySuggestion"> | string
    idealFor?: StringWithAggregatesFilter<"PropertySuggestion"> | string
    priceRange?: StringWithAggregatesFilter<"PropertySuggestion"> | string
    fullDescription?: StringNullableWithAggregatesFilter<"PropertySuggestion"> | string | null
    recommendationId?: IntWithAggregatesFilter<"PropertySuggestion"> | number
  }

  export type UserCreateInput = {
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
    otpCodes?: OtpCodeCreateNestedManyWithoutUserInput
    Recommendation?: RecommendationCreateNestedManyWithoutUserInput
    journeys?: JourneyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
    otpCodes?: OtpCodeUncheckedCreateNestedManyWithoutUserInput
    Recommendation?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    otpCodes?: OtpCodeUpdateManyWithoutUserNestedInput
    Recommendation?: RecommendationUpdateManyWithoutUserNestedInput
    journeys?: JourneyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    otpCodes?: OtpCodeUncheckedUpdateManyWithoutUserNestedInput
    Recommendation?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtpCodeCreateInput = {
    code: string
    phone: string
    email: string
    countryCode: string
    expiresAt: Date | string
    createdAt?: Date | string
    attempts?: number
    user?: UserCreateNestedOneWithoutOtpCodesInput
  }

  export type OtpCodeUncheckedCreateInput = {
    id?: number
    code: string
    phone: string
    email: string
    countryCode: string
    expiresAt: Date | string
    userId?: number | null
    createdAt?: Date | string
    attempts?: number
  }

  export type OtpCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutOtpCodesNestedInput
  }

  export type OtpCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type OtpCodeCreateManyInput = {
    id?: number
    code: string
    phone: string
    email: string
    countryCode: string
    expiresAt: Date | string
    userId?: number | null
    createdAt?: Date | string
    attempts?: number
  }

  export type OtpCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type OtpCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type JourneyCreateInput = {
    createdAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.JourneyStatus
    label?: string | null
    selectedState?: string | null
    selectedCities?: JourneyCreateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: number
    user: UserCreateNestedOneWithoutJourneysInput
    recommendation?: RecommendationCreateNestedOneWithoutJourneyInput
  }

  export type JourneyUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.JourneyStatus
    label?: string | null
    selectedState?: string | null
    selectedCities?: JourneyCreateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: number
    userId: number
    recommendation?: RecommendationUncheckedCreateNestedOneWithoutJourneyInput
  }

  export type JourneyUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutJourneysNestedInput
    recommendation?: RecommendationUpdateOneWithoutJourneyNestedInput
  }

  export type JourneyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    recommendation?: RecommendationUncheckedUpdateOneWithoutJourneyNestedInput
  }

  export type JourneyCreateManyInput = {
    id?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.JourneyStatus
    label?: string | null
    selectedState?: string | null
    selectedCities?: JourneyCreateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: number
    userId: number
  }

  export type JourneyUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
  }

  export type JourneyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type RecommendationCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRecommendationInput
    journey?: JourneyCreateNestedOneWithoutRecommendationInput
    propertySuggestion?: PropertySuggestionCreateNestedOneWithoutRecommendationInput
    areas?: RecommendedAreaCreateNestedManyWithoutRecommendationInput
  }

  export type RecommendationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    userId: number
    journeyId?: number | null
    propertySuggestion?: PropertySuggestionUncheckedCreateNestedOneWithoutRecommendationInput
    areas?: RecommendedAreaUncheckedCreateNestedManyWithoutRecommendationInput
  }

  export type RecommendationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecommendationNestedInput
    journey?: JourneyUpdateOneWithoutRecommendationNestedInput
    propertySuggestion?: PropertySuggestionUpdateOneWithoutRecommendationNestedInput
    areas?: RecommendedAreaUpdateManyWithoutRecommendationNestedInput
  }

  export type RecommendationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyId?: NullableIntFieldUpdateOperationsInput | number | null
    propertySuggestion?: PropertySuggestionUncheckedUpdateOneWithoutRecommendationNestedInput
    areas?: RecommendedAreaUncheckedUpdateManyWithoutRecommendationNestedInput
  }

  export type RecommendationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    userId: number
    journeyId?: number | null
  }

  export type RecommendationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecommendedAreaCreateInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateManyInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
  }

  export type RecommendedAreaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
  }

  export type RecommendedAreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
  }

  export type RaceEthnicityCreateInput = {
    white: number
    hispanic: number
    asian: number
    black: number
    other: number
    area: RecommendedAreaCreateNestedOneWithoutRaceEthnicityInput
  }

  export type RaceEthnicityUncheckedCreateInput = {
    id?: number
    white: number
    hispanic: number
    asian: number
    black: number
    other: number
    areaId: number
  }

  export type RaceEthnicityUpdateInput = {
    white?: FloatFieldUpdateOperationsInput | number
    hispanic?: FloatFieldUpdateOperationsInput | number
    asian?: FloatFieldUpdateOperationsInput | number
    black?: FloatFieldUpdateOperationsInput | number
    other?: FloatFieldUpdateOperationsInput | number
    area?: RecommendedAreaUpdateOneRequiredWithoutRaceEthnicityNestedInput
  }

  export type RaceEthnicityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    white?: FloatFieldUpdateOperationsInput | number
    hispanic?: FloatFieldUpdateOperationsInput | number
    asian?: FloatFieldUpdateOperationsInput | number
    black?: FloatFieldUpdateOperationsInput | number
    other?: FloatFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type RaceEthnicityCreateManyInput = {
    id?: number
    white: number
    hispanic: number
    asian: number
    black: number
    other: number
    areaId: number
  }

  export type RaceEthnicityUpdateManyMutationInput = {
    white?: FloatFieldUpdateOperationsInput | number
    hispanic?: FloatFieldUpdateOperationsInput | number
    asian?: FloatFieldUpdateOperationsInput | number
    black?: FloatFieldUpdateOperationsInput | number
    other?: FloatFieldUpdateOperationsInput | number
  }

  export type RaceEthnicityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    white?: FloatFieldUpdateOperationsInput | number
    hispanic?: FloatFieldUpdateOperationsInput | number
    asian?: FloatFieldUpdateOperationsInput | number
    black?: FloatFieldUpdateOperationsInput | number
    other?: FloatFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomeLevelsCreateInput = {
    perCapitaIncome: number
    medianHouseholdIncome: number
    area: RecommendedAreaCreateNestedOneWithoutIncomeLevelsInput
  }

  export type IncomeLevelsUncheckedCreateInput = {
    id?: number
    perCapitaIncome: number
    medianHouseholdIncome: number
    areaId: number
  }

  export type IncomeLevelsUpdateInput = {
    perCapitaIncome?: FloatFieldUpdateOperationsInput | number
    medianHouseholdIncome?: FloatFieldUpdateOperationsInput | number
    area?: RecommendedAreaUpdateOneRequiredWithoutIncomeLevelsNestedInput
  }

  export type IncomeLevelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    perCapitaIncome?: FloatFieldUpdateOperationsInput | number
    medianHouseholdIncome?: FloatFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type IncomeLevelsCreateManyInput = {
    id?: number
    perCapitaIncome: number
    medianHouseholdIncome: number
    areaId: number
  }

  export type IncomeLevelsUpdateManyMutationInput = {
    perCapitaIncome?: FloatFieldUpdateOperationsInput | number
    medianHouseholdIncome?: FloatFieldUpdateOperationsInput | number
  }

  export type IncomeLevelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    perCapitaIncome?: FloatFieldUpdateOperationsInput | number
    medianHouseholdIncome?: FloatFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type CrimeDataCreateInput = {
    violentCrimes: number
    propertyCrimes: number
    totalCrimes: number
    violentRate: number
    propertyRate: number
    totalRate: number
    area: RecommendedAreaCreateNestedOneWithoutCrimeDataInput
  }

  export type CrimeDataUncheckedCreateInput = {
    id?: number
    violentCrimes: number
    propertyCrimes: number
    totalCrimes: number
    violentRate: number
    propertyRate: number
    totalRate: number
    areaId: number
  }

  export type CrimeDataUpdateInput = {
    violentCrimes?: IntFieldUpdateOperationsInput | number
    propertyCrimes?: IntFieldUpdateOperationsInput | number
    totalCrimes?: IntFieldUpdateOperationsInput | number
    violentRate?: FloatFieldUpdateOperationsInput | number
    propertyRate?: FloatFieldUpdateOperationsInput | number
    totalRate?: FloatFieldUpdateOperationsInput | number
    area?: RecommendedAreaUpdateOneRequiredWithoutCrimeDataNestedInput
  }

  export type CrimeDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    violentCrimes?: IntFieldUpdateOperationsInput | number
    propertyCrimes?: IntFieldUpdateOperationsInput | number
    totalCrimes?: IntFieldUpdateOperationsInput | number
    violentRate?: FloatFieldUpdateOperationsInput | number
    propertyRate?: FloatFieldUpdateOperationsInput | number
    totalRate?: FloatFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type CrimeDataCreateManyInput = {
    id?: number
    violentCrimes: number
    propertyCrimes: number
    totalCrimes: number
    violentRate: number
    propertyRate: number
    totalRate: number
    areaId: number
  }

  export type CrimeDataUpdateManyMutationInput = {
    violentCrimes?: IntFieldUpdateOperationsInput | number
    propertyCrimes?: IntFieldUpdateOperationsInput | number
    totalCrimes?: IntFieldUpdateOperationsInput | number
    violentRate?: FloatFieldUpdateOperationsInput | number
    propertyRate?: FloatFieldUpdateOperationsInput | number
    totalRate?: FloatFieldUpdateOperationsInput | number
  }

  export type CrimeDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    violentCrimes?: IntFieldUpdateOperationsInput | number
    propertyCrimes?: IntFieldUpdateOperationsInput | number
    totalCrimes?: IntFieldUpdateOperationsInput | number
    violentRate?: FloatFieldUpdateOperationsInput | number
    propertyRate?: FloatFieldUpdateOperationsInput | number
    totalRate?: FloatFieldUpdateOperationsInput | number
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type SchoolCreateInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    area: RecommendedAreaCreateNestedOneWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type SchoolUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    area?: RecommendedAreaUpdateOneRequiredWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type SchoolCreateManyInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type SchoolUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type SocialLifeCreateInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    area: RecommendedAreaCreateNestedOneWithoutSocialLifeInput
  }

  export type SocialLifeUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type SocialLifeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    area?: RecommendedAreaUpdateOneRequiredWithoutSocialLifeNestedInput
  }

  export type SocialLifeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type SocialLifeCreateManyInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type SocialLifeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLifeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type ShoppingCreateInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    area: RecommendedAreaCreateNestedOneWithoutShoppingInput
  }

  export type ShoppingUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type ShoppingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    area?: RecommendedAreaUpdateOneRequiredWithoutShoppingNestedInput
  }

  export type ShoppingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type ShoppingCreateManyInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type ShoppingUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoppingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type GreenSpaceCreateInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    area: RecommendedAreaCreateNestedOneWithoutGreenSpacesInput
  }

  export type GreenSpaceUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type GreenSpaceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    area?: RecommendedAreaUpdateOneRequiredWithoutGreenSpacesNestedInput
  }

  export type GreenSpaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type GreenSpaceCreateManyInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type GreenSpaceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GreenSpaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type SportCreateInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    area: RecommendedAreaCreateNestedOneWithoutSportsInput
  }

  export type SportUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type SportUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    area?: RecommendedAreaUpdateOneRequiredWithoutSportsNestedInput
  }

  export type SportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type SportCreateManyInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
    areaId: number
  }

  export type SportUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type PropertyCreateInput = {
    address: string
    price: string
    description: string
    fullDescription?: string | null
    imageUrls?: PropertyCreateimageUrlsInput | string[]
    type: string
    builtYear: number
    lotSizeSqFt: number
    parkingSpaces: number
    inUnitLaundry: boolean
    district: string
    area: RecommendedAreaCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: number
    address: string
    price: string
    description: string
    fullDescription?: string | null
    imageUrls?: PropertyCreateimageUrlsInput | string[]
    type: string
    builtYear: number
    lotSizeSqFt: number
    parkingSpaces: number
    inUnitLaundry: boolean
    district: string
    areaId: number
  }

  export type PropertyUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: PropertyUpdateimageUrlsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    builtYear?: IntFieldUpdateOperationsInput | number
    lotSizeSqFt?: IntFieldUpdateOperationsInput | number
    parkingSpaces?: IntFieldUpdateOperationsInput | number
    inUnitLaundry?: BoolFieldUpdateOperationsInput | boolean
    district?: StringFieldUpdateOperationsInput | string
    area?: RecommendedAreaUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: PropertyUpdateimageUrlsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    builtYear?: IntFieldUpdateOperationsInput | number
    lotSizeSqFt?: IntFieldUpdateOperationsInput | number
    parkingSpaces?: IntFieldUpdateOperationsInput | number
    inUnitLaundry?: BoolFieldUpdateOperationsInput | boolean
    district?: StringFieldUpdateOperationsInput | string
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type PropertyCreateManyInput = {
    id?: number
    address: string
    price: string
    description: string
    fullDescription?: string | null
    imageUrls?: PropertyCreateimageUrlsInput | string[]
    type: string
    builtYear: number
    lotSizeSqFt: number
    parkingSpaces: number
    inUnitLaundry: boolean
    district: string
    areaId: number
  }

  export type PropertyUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: PropertyUpdateimageUrlsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    builtYear?: IntFieldUpdateOperationsInput | number
    lotSizeSqFt?: IntFieldUpdateOperationsInput | number
    parkingSpaces?: IntFieldUpdateOperationsInput | number
    inUnitLaundry?: BoolFieldUpdateOperationsInput | boolean
    district?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: PropertyUpdateimageUrlsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    builtYear?: IntFieldUpdateOperationsInput | number
    lotSizeSqFt?: IntFieldUpdateOperationsInput | number
    parkingSpaces?: IntFieldUpdateOperationsInput | number
    inUnitLaundry?: BoolFieldUpdateOperationsInput | boolean
    district?: StringFieldUpdateOperationsInput | string
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type PropertySuggestionCreateInput = {
    type: string
    idealFor: string
    priceRange: string
    fullDescription?: string | null
    recommendation: RecommendationCreateNestedOneWithoutPropertySuggestionInput
  }

  export type PropertySuggestionUncheckedCreateInput = {
    id?: number
    type: string
    idealFor: string
    priceRange: string
    fullDescription?: string | null
    recommendationId: number
  }

  export type PropertySuggestionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    idealFor?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: RecommendationUpdateOneRequiredWithoutPropertySuggestionNestedInput
  }

  export type PropertySuggestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    idealFor?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
  }

  export type PropertySuggestionCreateManyInput = {
    id?: number
    type: string
    idealFor: string
    priceRange: string
    fullDescription?: string | null
    recommendationId: number
  }

  export type PropertySuggestionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    idealFor?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertySuggestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    idealFor?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OtpCodeListRelationFilter = {
    every?: OtpCodeWhereInput
    some?: OtpCodeWhereInput
    none?: OtpCodeWhereInput
  }

  export type RecommendationListRelationFilter = {
    every?: RecommendationWhereInput
    some?: RecommendationWhereInput
    none?: RecommendationWhereInput
  }

  export type JourneyListRelationFilter = {
    every?: JourneyWhereInput
    some?: JourneyWhereInput
    none?: JourneyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OtpCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JourneyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    state?: SortOrder
    city?: SortOrder
    environment?: SortOrder
    education1?: SortOrder
    education2?: SortOrder
    family?: SortOrder
    employment1?: SortOrder
    employment2?: SortOrder
    socialLife?: SortOrder
    hobbies?: SortOrder
    transportation?: SortOrder
    pets?: SortOrder
    greenSpace?: SortOrder
    shopping?: SortOrder
    restaurants?: SortOrder
    occupancy?: SortOrder
    property?: SortOrder
    timeframe?: SortOrder
    priceRange?: SortOrder
    downPayment?: SortOrder
    employmentStatus?: SortOrder
    grossAnnual?: SortOrder
    credit?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    grossAnnual?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    state?: SortOrder
    environment?: SortOrder
    occupancy?: SortOrder
    property?: SortOrder
    timeframe?: SortOrder
    priceRange?: SortOrder
    downPayment?: SortOrder
    employmentStatus?: SortOrder
    grossAnnual?: SortOrder
    credit?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    state?: SortOrder
    environment?: SortOrder
    occupancy?: SortOrder
    property?: SortOrder
    timeframe?: SortOrder
    priceRange?: SortOrder
    downPayment?: SortOrder
    employmentStatus?: SortOrder
    grossAnnual?: SortOrder
    credit?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    grossAnnual?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type OtpCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    countryCode?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type OtpCodeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    attempts?: SortOrder
  }

  export type OtpCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    countryCode?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type OtpCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    countryCode?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    attempts?: SortOrder
  }

  export type OtpCodeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    attempts?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumJourneyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JourneyStatus | EnumJourneyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJourneyStatusFilter<$PrismaModel> | $Enums.JourneyStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RecommendationNullableScalarRelationFilter = {
    is?: RecommendationWhereInput | null
    isNot?: RecommendationWhereInput | null
  }

  export type JourneyCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    label?: SortOrder
    selectedState?: SortOrder
    selectedCities?: SortOrder
    inputs?: SortOrder
    index?: SortOrder
    userId?: SortOrder
  }

  export type JourneyAvgOrderByAggregateInput = {
    id?: SortOrder
    index?: SortOrder
    userId?: SortOrder
  }

  export type JourneyMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    label?: SortOrder
    selectedState?: SortOrder
    index?: SortOrder
    userId?: SortOrder
  }

  export type JourneyMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    label?: SortOrder
    selectedState?: SortOrder
    index?: SortOrder
    userId?: SortOrder
  }

  export type JourneySumOrderByAggregateInput = {
    id?: SortOrder
    index?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumJourneyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JourneyStatus | EnumJourneyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJourneyStatusWithAggregatesFilter<$PrismaModel> | $Enums.JourneyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJourneyStatusFilter<$PrismaModel>
    _max?: NestedEnumJourneyStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type JourneyNullableScalarRelationFilter = {
    is?: JourneyWhereInput | null
    isNot?: JourneyWhereInput | null
  }

  export type PropertySuggestionNullableScalarRelationFilter = {
    is?: PropertySuggestionWhereInput | null
    isNot?: PropertySuggestionWhereInput | null
  }

  export type RecommendedAreaListRelationFilter = {
    every?: RecommendedAreaWhereInput
    some?: RecommendedAreaWhereInput
    none?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyId?: SortOrder
  }

  export type RecommendationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    journeyId?: SortOrder
  }

  export type RecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyId?: SortOrder
  }

  export type RecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyId?: SortOrder
  }

  export type RecommendationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    journeyId?: SortOrder
  }

  export type RecommendationScalarRelationFilter = {
    is?: RecommendationWhereInput
    isNot?: RecommendationWhereInput
  }

  export type RaceEthnicityNullableScalarRelationFilter = {
    is?: RaceEthnicityWhereInput | null
    isNot?: RaceEthnicityWhereInput | null
  }

  export type IncomeLevelsNullableScalarRelationFilter = {
    is?: IncomeLevelsWhereInput | null
    isNot?: IncomeLevelsWhereInput | null
  }

  export type CrimeDataNullableScalarRelationFilter = {
    is?: CrimeDataWhereInput | null
    isNot?: CrimeDataWhereInput | null
  }

  export type SchoolListRelationFilter = {
    every?: SchoolWhereInput
    some?: SchoolWhereInput
    none?: SchoolWhereInput
  }

  export type SocialLifeListRelationFilter = {
    every?: SocialLifeWhereInput
    some?: SocialLifeWhereInput
    none?: SocialLifeWhereInput
  }

  export type ShoppingListRelationFilter = {
    every?: ShoppingWhereInput
    some?: ShoppingWhereInput
    none?: ShoppingWhereInput
  }

  export type GreenSpaceListRelationFilter = {
    every?: GreenSpaceWhereInput
    some?: GreenSpaceWhereInput
    none?: GreenSpaceWhereInput
  }

  export type SportListRelationFilter = {
    every?: SportWhereInput
    some?: SportWhereInput
    none?: SportWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type SchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialLifeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoppingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GreenSpaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecommendedAreaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    reason?: SortOrder
    imageUrl?: SortOrder
    fullDescription?: SortOrder
    recommendationId?: SortOrder
    placesOfInterest?: SortOrder
    lifestyleTags?: SortOrder
  }

  export type RecommendedAreaAvgOrderByAggregateInput = {
    id?: SortOrder
    recommendationId?: SortOrder
  }

  export type RecommendedAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    reason?: SortOrder
    imageUrl?: SortOrder
    fullDescription?: SortOrder
    recommendationId?: SortOrder
  }

  export type RecommendedAreaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    reason?: SortOrder
    imageUrl?: SortOrder
    fullDescription?: SortOrder
    recommendationId?: SortOrder
  }

  export type RecommendedAreaSumOrderByAggregateInput = {
    id?: SortOrder
    recommendationId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RecommendedAreaScalarRelationFilter = {
    is?: RecommendedAreaWhereInput
    isNot?: RecommendedAreaWhereInput
  }

  export type RaceEthnicityCountOrderByAggregateInput = {
    id?: SortOrder
    white?: SortOrder
    hispanic?: SortOrder
    asian?: SortOrder
    black?: SortOrder
    other?: SortOrder
    areaId?: SortOrder
  }

  export type RaceEthnicityAvgOrderByAggregateInput = {
    id?: SortOrder
    white?: SortOrder
    hispanic?: SortOrder
    asian?: SortOrder
    black?: SortOrder
    other?: SortOrder
    areaId?: SortOrder
  }

  export type RaceEthnicityMaxOrderByAggregateInput = {
    id?: SortOrder
    white?: SortOrder
    hispanic?: SortOrder
    asian?: SortOrder
    black?: SortOrder
    other?: SortOrder
    areaId?: SortOrder
  }

  export type RaceEthnicityMinOrderByAggregateInput = {
    id?: SortOrder
    white?: SortOrder
    hispanic?: SortOrder
    asian?: SortOrder
    black?: SortOrder
    other?: SortOrder
    areaId?: SortOrder
  }

  export type RaceEthnicitySumOrderByAggregateInput = {
    id?: SortOrder
    white?: SortOrder
    hispanic?: SortOrder
    asian?: SortOrder
    black?: SortOrder
    other?: SortOrder
    areaId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IncomeLevelsCountOrderByAggregateInput = {
    id?: SortOrder
    perCapitaIncome?: SortOrder
    medianHouseholdIncome?: SortOrder
    areaId?: SortOrder
  }

  export type IncomeLevelsAvgOrderByAggregateInput = {
    id?: SortOrder
    perCapitaIncome?: SortOrder
    medianHouseholdIncome?: SortOrder
    areaId?: SortOrder
  }

  export type IncomeLevelsMaxOrderByAggregateInput = {
    id?: SortOrder
    perCapitaIncome?: SortOrder
    medianHouseholdIncome?: SortOrder
    areaId?: SortOrder
  }

  export type IncomeLevelsMinOrderByAggregateInput = {
    id?: SortOrder
    perCapitaIncome?: SortOrder
    medianHouseholdIncome?: SortOrder
    areaId?: SortOrder
  }

  export type IncomeLevelsSumOrderByAggregateInput = {
    id?: SortOrder
    perCapitaIncome?: SortOrder
    medianHouseholdIncome?: SortOrder
    areaId?: SortOrder
  }

  export type CrimeDataCountOrderByAggregateInput = {
    id?: SortOrder
    violentCrimes?: SortOrder
    propertyCrimes?: SortOrder
    totalCrimes?: SortOrder
    violentRate?: SortOrder
    propertyRate?: SortOrder
    totalRate?: SortOrder
    areaId?: SortOrder
  }

  export type CrimeDataAvgOrderByAggregateInput = {
    id?: SortOrder
    violentCrimes?: SortOrder
    propertyCrimes?: SortOrder
    totalCrimes?: SortOrder
    violentRate?: SortOrder
    propertyRate?: SortOrder
    totalRate?: SortOrder
    areaId?: SortOrder
  }

  export type CrimeDataMaxOrderByAggregateInput = {
    id?: SortOrder
    violentCrimes?: SortOrder
    propertyCrimes?: SortOrder
    totalCrimes?: SortOrder
    violentRate?: SortOrder
    propertyRate?: SortOrder
    totalRate?: SortOrder
    areaId?: SortOrder
  }

  export type CrimeDataMinOrderByAggregateInput = {
    id?: SortOrder
    violentCrimes?: SortOrder
    propertyCrimes?: SortOrder
    totalCrimes?: SortOrder
    violentRate?: SortOrder
    propertyRate?: SortOrder
    totalRate?: SortOrder
    areaId?: SortOrder
  }

  export type CrimeDataSumOrderByAggregateInput = {
    id?: SortOrder
    violentCrimes?: SortOrder
    propertyCrimes?: SortOrder
    totalCrimes?: SortOrder
    violentRate?: SortOrder
    propertyRate?: SortOrder
    totalRate?: SortOrder
    areaId?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type SocialLifeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SocialLifeAvgOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type SocialLifeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SocialLifeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SocialLifeSumOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type ShoppingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type ShoppingAvgOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type ShoppingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type ShoppingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type ShoppingSumOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type GreenSpaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type GreenSpaceAvgOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type GreenSpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type GreenSpaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type GreenSpaceSumOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type SportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SportAvgOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type SportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrl?: SortOrder
    website?: SortOrder
    areaId?: SortOrder
  }

  export type SportSumOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    price?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    imageUrls?: SortOrder
    type?: SortOrder
    builtYear?: SortOrder
    lotSizeSqFt?: SortOrder
    parkingSpaces?: SortOrder
    inUnitLaundry?: SortOrder
    district?: SortOrder
    areaId?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    id?: SortOrder
    builtYear?: SortOrder
    lotSizeSqFt?: SortOrder
    parkingSpaces?: SortOrder
    areaId?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    price?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    type?: SortOrder
    builtYear?: SortOrder
    lotSizeSqFt?: SortOrder
    parkingSpaces?: SortOrder
    inUnitLaundry?: SortOrder
    district?: SortOrder
    areaId?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    price?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    type?: SortOrder
    builtYear?: SortOrder
    lotSizeSqFt?: SortOrder
    parkingSpaces?: SortOrder
    inUnitLaundry?: SortOrder
    district?: SortOrder
    areaId?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    id?: SortOrder
    builtYear?: SortOrder
    lotSizeSqFt?: SortOrder
    parkingSpaces?: SortOrder
    areaId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PropertySuggestionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    idealFor?: SortOrder
    priceRange?: SortOrder
    fullDescription?: SortOrder
    recommendationId?: SortOrder
  }

  export type PropertySuggestionAvgOrderByAggregateInput = {
    id?: SortOrder
    recommendationId?: SortOrder
  }

  export type PropertySuggestionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    idealFor?: SortOrder
    priceRange?: SortOrder
    fullDescription?: SortOrder
    recommendationId?: SortOrder
  }

  export type PropertySuggestionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    idealFor?: SortOrder
    priceRange?: SortOrder
    fullDescription?: SortOrder
    recommendationId?: SortOrder
  }

  export type PropertySuggestionSumOrderByAggregateInput = {
    id?: SortOrder
    recommendationId?: SortOrder
  }

  export type UserCreatecityInput = {
    set: string[]
  }

  export type UserCreateeducation1Input = {
    set: string[]
  }

  export type UserCreateeducation2Input = {
    set: string[]
  }

  export type UserCreatefamilyInput = {
    set: string[]
  }

  export type UserCreateemployment1Input = {
    set: string[]
  }

  export type UserCreateemployment2Input = {
    set: string[]
  }

  export type UserCreatesocialLifeInput = {
    set: string[]
  }

  export type UserCreatehobbiesInput = {
    set: string[]
  }

  export type UserCreatetransportationInput = {
    set: string[]
  }

  export type UserCreatepetsInput = {
    set: string[]
  }

  export type UserCreategreenSpaceInput = {
    set: string[]
  }

  export type UserCreateshoppingInput = {
    set: string[]
  }

  export type UserCreaterestaurantsInput = {
    set: string[]
  }

  export type OtpCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpCodeCreateWithoutUserInput, OtpCodeUncheckedCreateWithoutUserInput> | OtpCodeCreateWithoutUserInput[] | OtpCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCodeCreateOrConnectWithoutUserInput | OtpCodeCreateOrConnectWithoutUserInput[]
    createMany?: OtpCodeCreateManyUserInputEnvelope
    connect?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
  }

  export type RecommendationCreateNestedManyWithoutUserInput = {
    create?: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput> | RecommendationCreateWithoutUserInput[] | RecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutUserInput | RecommendationCreateOrConnectWithoutUserInput[]
    createMany?: RecommendationCreateManyUserInputEnvelope
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
  }

  export type JourneyCreateNestedManyWithoutUserInput = {
    create?: XOR<JourneyCreateWithoutUserInput, JourneyUncheckedCreateWithoutUserInput> | JourneyCreateWithoutUserInput[] | JourneyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyCreateOrConnectWithoutUserInput | JourneyCreateOrConnectWithoutUserInput[]
    createMany?: JourneyCreateManyUserInputEnvelope
    connect?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
  }

  export type OtpCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpCodeCreateWithoutUserInput, OtpCodeUncheckedCreateWithoutUserInput> | OtpCodeCreateWithoutUserInput[] | OtpCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCodeCreateOrConnectWithoutUserInput | OtpCodeCreateOrConnectWithoutUserInput[]
    createMany?: OtpCodeCreateManyUserInputEnvelope
    connect?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
  }

  export type RecommendationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput> | RecommendationCreateWithoutUserInput[] | RecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutUserInput | RecommendationCreateOrConnectWithoutUserInput[]
    createMany?: RecommendationCreateManyUserInputEnvelope
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
  }

  export type JourneyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JourneyCreateWithoutUserInput, JourneyUncheckedCreateWithoutUserInput> | JourneyCreateWithoutUserInput[] | JourneyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyCreateOrConnectWithoutUserInput | JourneyCreateOrConnectWithoutUserInput[]
    createMany?: JourneyCreateManyUserInputEnvelope
    connect?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdatecityInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateeducation1Input = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateeducation2Input = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatefamilyInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateemployment1Input = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateemployment2Input = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatesocialLifeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatehobbiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatetransportationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatepetsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdategreenSpaceInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateshoppingInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdaterestaurantsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OtpCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpCodeCreateWithoutUserInput, OtpCodeUncheckedCreateWithoutUserInput> | OtpCodeCreateWithoutUserInput[] | OtpCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCodeCreateOrConnectWithoutUserInput | OtpCodeCreateOrConnectWithoutUserInput[]
    upsert?: OtpCodeUpsertWithWhereUniqueWithoutUserInput | OtpCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpCodeCreateManyUserInputEnvelope
    set?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
    disconnect?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
    delete?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
    connect?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
    update?: OtpCodeUpdateWithWhereUniqueWithoutUserInput | OtpCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpCodeUpdateManyWithWhereWithoutUserInput | OtpCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpCodeScalarWhereInput | OtpCodeScalarWhereInput[]
  }

  export type RecommendationUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput> | RecommendationCreateWithoutUserInput[] | RecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutUserInput | RecommendationCreateOrConnectWithoutUserInput[]
    upsert?: RecommendationUpsertWithWhereUniqueWithoutUserInput | RecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecommendationCreateManyUserInputEnvelope
    set?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    disconnect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    delete?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    update?: RecommendationUpdateWithWhereUniqueWithoutUserInput | RecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecommendationUpdateManyWithWhereWithoutUserInput | RecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
  }

  export type JourneyUpdateManyWithoutUserNestedInput = {
    create?: XOR<JourneyCreateWithoutUserInput, JourneyUncheckedCreateWithoutUserInput> | JourneyCreateWithoutUserInput[] | JourneyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyCreateOrConnectWithoutUserInput | JourneyCreateOrConnectWithoutUserInput[]
    upsert?: JourneyUpsertWithWhereUniqueWithoutUserInput | JourneyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JourneyCreateManyUserInputEnvelope
    set?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
    disconnect?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
    delete?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
    connect?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
    update?: JourneyUpdateWithWhereUniqueWithoutUserInput | JourneyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JourneyUpdateManyWithWhereWithoutUserInput | JourneyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JourneyScalarWhereInput | JourneyScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OtpCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpCodeCreateWithoutUserInput, OtpCodeUncheckedCreateWithoutUserInput> | OtpCodeCreateWithoutUserInput[] | OtpCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCodeCreateOrConnectWithoutUserInput | OtpCodeCreateOrConnectWithoutUserInput[]
    upsert?: OtpCodeUpsertWithWhereUniqueWithoutUserInput | OtpCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpCodeCreateManyUserInputEnvelope
    set?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
    disconnect?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
    delete?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
    connect?: OtpCodeWhereUniqueInput | OtpCodeWhereUniqueInput[]
    update?: OtpCodeUpdateWithWhereUniqueWithoutUserInput | OtpCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpCodeUpdateManyWithWhereWithoutUserInput | OtpCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpCodeScalarWhereInput | OtpCodeScalarWhereInput[]
  }

  export type RecommendationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput> | RecommendationCreateWithoutUserInput[] | RecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutUserInput | RecommendationCreateOrConnectWithoutUserInput[]
    upsert?: RecommendationUpsertWithWhereUniqueWithoutUserInput | RecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecommendationCreateManyUserInputEnvelope
    set?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    disconnect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    delete?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    update?: RecommendationUpdateWithWhereUniqueWithoutUserInput | RecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecommendationUpdateManyWithWhereWithoutUserInput | RecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
  }

  export type JourneyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JourneyCreateWithoutUserInput, JourneyUncheckedCreateWithoutUserInput> | JourneyCreateWithoutUserInput[] | JourneyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyCreateOrConnectWithoutUserInput | JourneyCreateOrConnectWithoutUserInput[]
    upsert?: JourneyUpsertWithWhereUniqueWithoutUserInput | JourneyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JourneyCreateManyUserInputEnvelope
    set?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
    disconnect?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
    delete?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
    connect?: JourneyWhereUniqueInput | JourneyWhereUniqueInput[]
    update?: JourneyUpdateWithWhereUniqueWithoutUserInput | JourneyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JourneyUpdateManyWithWhereWithoutUserInput | JourneyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JourneyScalarWhereInput | JourneyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOtpCodesInput = {
    create?: XOR<UserCreateWithoutOtpCodesInput, UserUncheckedCreateWithoutOtpCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpCodesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutOtpCodesNestedInput = {
    create?: XOR<UserCreateWithoutOtpCodesInput, UserUncheckedCreateWithoutOtpCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpCodesInput
    upsert?: UserUpsertWithoutOtpCodesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpCodesInput, UserUpdateWithoutOtpCodesInput>, UserUncheckedUpdateWithoutOtpCodesInput>
  }

  export type JourneyCreateselectedCitiesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutJourneysInput = {
    create?: XOR<UserCreateWithoutJourneysInput, UserUncheckedCreateWithoutJourneysInput>
    connectOrCreate?: UserCreateOrConnectWithoutJourneysInput
    connect?: UserWhereUniqueInput
  }

  export type RecommendationCreateNestedOneWithoutJourneyInput = {
    create?: XOR<RecommendationCreateWithoutJourneyInput, RecommendationUncheckedCreateWithoutJourneyInput>
    connectOrCreate?: RecommendationCreateOrConnectWithoutJourneyInput
    connect?: RecommendationWhereUniqueInput
  }

  export type RecommendationUncheckedCreateNestedOneWithoutJourneyInput = {
    create?: XOR<RecommendationCreateWithoutJourneyInput, RecommendationUncheckedCreateWithoutJourneyInput>
    connectOrCreate?: RecommendationCreateOrConnectWithoutJourneyInput
    connect?: RecommendationWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumJourneyStatusFieldUpdateOperationsInput = {
    set?: $Enums.JourneyStatus
  }

  export type JourneyUpdateselectedCitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutJourneysNestedInput = {
    create?: XOR<UserCreateWithoutJourneysInput, UserUncheckedCreateWithoutJourneysInput>
    connectOrCreate?: UserCreateOrConnectWithoutJourneysInput
    upsert?: UserUpsertWithoutJourneysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJourneysInput, UserUpdateWithoutJourneysInput>, UserUncheckedUpdateWithoutJourneysInput>
  }

  export type RecommendationUpdateOneWithoutJourneyNestedInput = {
    create?: XOR<RecommendationCreateWithoutJourneyInput, RecommendationUncheckedCreateWithoutJourneyInput>
    connectOrCreate?: RecommendationCreateOrConnectWithoutJourneyInput
    upsert?: RecommendationUpsertWithoutJourneyInput
    disconnect?: RecommendationWhereInput | boolean
    delete?: RecommendationWhereInput | boolean
    connect?: RecommendationWhereUniqueInput
    update?: XOR<XOR<RecommendationUpdateToOneWithWhereWithoutJourneyInput, RecommendationUpdateWithoutJourneyInput>, RecommendationUncheckedUpdateWithoutJourneyInput>
  }

  export type RecommendationUncheckedUpdateOneWithoutJourneyNestedInput = {
    create?: XOR<RecommendationCreateWithoutJourneyInput, RecommendationUncheckedCreateWithoutJourneyInput>
    connectOrCreate?: RecommendationCreateOrConnectWithoutJourneyInput
    upsert?: RecommendationUpsertWithoutJourneyInput
    disconnect?: RecommendationWhereInput | boolean
    delete?: RecommendationWhereInput | boolean
    connect?: RecommendationWhereUniqueInput
    update?: XOR<XOR<RecommendationUpdateToOneWithWhereWithoutJourneyInput, RecommendationUpdateWithoutJourneyInput>, RecommendationUncheckedUpdateWithoutJourneyInput>
  }

  export type UserCreateNestedOneWithoutRecommendationInput = {
    create?: XOR<UserCreateWithoutRecommendationInput, UserUncheckedCreateWithoutRecommendationInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecommendationInput
    connect?: UserWhereUniqueInput
  }

  export type JourneyCreateNestedOneWithoutRecommendationInput = {
    create?: XOR<JourneyCreateWithoutRecommendationInput, JourneyUncheckedCreateWithoutRecommendationInput>
    connectOrCreate?: JourneyCreateOrConnectWithoutRecommendationInput
    connect?: JourneyWhereUniqueInput
  }

  export type PropertySuggestionCreateNestedOneWithoutRecommendationInput = {
    create?: XOR<PropertySuggestionCreateWithoutRecommendationInput, PropertySuggestionUncheckedCreateWithoutRecommendationInput>
    connectOrCreate?: PropertySuggestionCreateOrConnectWithoutRecommendationInput
    connect?: PropertySuggestionWhereUniqueInput
  }

  export type RecommendedAreaCreateNestedManyWithoutRecommendationInput = {
    create?: XOR<RecommendedAreaCreateWithoutRecommendationInput, RecommendedAreaUncheckedCreateWithoutRecommendationInput> | RecommendedAreaCreateWithoutRecommendationInput[] | RecommendedAreaUncheckedCreateWithoutRecommendationInput[]
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutRecommendationInput | RecommendedAreaCreateOrConnectWithoutRecommendationInput[]
    createMany?: RecommendedAreaCreateManyRecommendationInputEnvelope
    connect?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
  }

  export type PropertySuggestionUncheckedCreateNestedOneWithoutRecommendationInput = {
    create?: XOR<PropertySuggestionCreateWithoutRecommendationInput, PropertySuggestionUncheckedCreateWithoutRecommendationInput>
    connectOrCreate?: PropertySuggestionCreateOrConnectWithoutRecommendationInput
    connect?: PropertySuggestionWhereUniqueInput
  }

  export type RecommendedAreaUncheckedCreateNestedManyWithoutRecommendationInput = {
    create?: XOR<RecommendedAreaCreateWithoutRecommendationInput, RecommendedAreaUncheckedCreateWithoutRecommendationInput> | RecommendedAreaCreateWithoutRecommendationInput[] | RecommendedAreaUncheckedCreateWithoutRecommendationInput[]
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutRecommendationInput | RecommendedAreaCreateOrConnectWithoutRecommendationInput[]
    createMany?: RecommendedAreaCreateManyRecommendationInputEnvelope
    connect?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutRecommendationNestedInput = {
    create?: XOR<UserCreateWithoutRecommendationInput, UserUncheckedCreateWithoutRecommendationInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecommendationInput
    upsert?: UserUpsertWithoutRecommendationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecommendationInput, UserUpdateWithoutRecommendationInput>, UserUncheckedUpdateWithoutRecommendationInput>
  }

  export type JourneyUpdateOneWithoutRecommendationNestedInput = {
    create?: XOR<JourneyCreateWithoutRecommendationInput, JourneyUncheckedCreateWithoutRecommendationInput>
    connectOrCreate?: JourneyCreateOrConnectWithoutRecommendationInput
    upsert?: JourneyUpsertWithoutRecommendationInput
    disconnect?: JourneyWhereInput | boolean
    delete?: JourneyWhereInput | boolean
    connect?: JourneyWhereUniqueInput
    update?: XOR<XOR<JourneyUpdateToOneWithWhereWithoutRecommendationInput, JourneyUpdateWithoutRecommendationInput>, JourneyUncheckedUpdateWithoutRecommendationInput>
  }

  export type PropertySuggestionUpdateOneWithoutRecommendationNestedInput = {
    create?: XOR<PropertySuggestionCreateWithoutRecommendationInput, PropertySuggestionUncheckedCreateWithoutRecommendationInput>
    connectOrCreate?: PropertySuggestionCreateOrConnectWithoutRecommendationInput
    upsert?: PropertySuggestionUpsertWithoutRecommendationInput
    disconnect?: PropertySuggestionWhereInput | boolean
    delete?: PropertySuggestionWhereInput | boolean
    connect?: PropertySuggestionWhereUniqueInput
    update?: XOR<XOR<PropertySuggestionUpdateToOneWithWhereWithoutRecommendationInput, PropertySuggestionUpdateWithoutRecommendationInput>, PropertySuggestionUncheckedUpdateWithoutRecommendationInput>
  }

  export type RecommendedAreaUpdateManyWithoutRecommendationNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutRecommendationInput, RecommendedAreaUncheckedCreateWithoutRecommendationInput> | RecommendedAreaCreateWithoutRecommendationInput[] | RecommendedAreaUncheckedCreateWithoutRecommendationInput[]
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutRecommendationInput | RecommendedAreaCreateOrConnectWithoutRecommendationInput[]
    upsert?: RecommendedAreaUpsertWithWhereUniqueWithoutRecommendationInput | RecommendedAreaUpsertWithWhereUniqueWithoutRecommendationInput[]
    createMany?: RecommendedAreaCreateManyRecommendationInputEnvelope
    set?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
    disconnect?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
    delete?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
    connect?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
    update?: RecommendedAreaUpdateWithWhereUniqueWithoutRecommendationInput | RecommendedAreaUpdateWithWhereUniqueWithoutRecommendationInput[]
    updateMany?: RecommendedAreaUpdateManyWithWhereWithoutRecommendationInput | RecommendedAreaUpdateManyWithWhereWithoutRecommendationInput[]
    deleteMany?: RecommendedAreaScalarWhereInput | RecommendedAreaScalarWhereInput[]
  }

  export type PropertySuggestionUncheckedUpdateOneWithoutRecommendationNestedInput = {
    create?: XOR<PropertySuggestionCreateWithoutRecommendationInput, PropertySuggestionUncheckedCreateWithoutRecommendationInput>
    connectOrCreate?: PropertySuggestionCreateOrConnectWithoutRecommendationInput
    upsert?: PropertySuggestionUpsertWithoutRecommendationInput
    disconnect?: PropertySuggestionWhereInput | boolean
    delete?: PropertySuggestionWhereInput | boolean
    connect?: PropertySuggestionWhereUniqueInput
    update?: XOR<XOR<PropertySuggestionUpdateToOneWithWhereWithoutRecommendationInput, PropertySuggestionUpdateWithoutRecommendationInput>, PropertySuggestionUncheckedUpdateWithoutRecommendationInput>
  }

  export type RecommendedAreaUncheckedUpdateManyWithoutRecommendationNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutRecommendationInput, RecommendedAreaUncheckedCreateWithoutRecommendationInput> | RecommendedAreaCreateWithoutRecommendationInput[] | RecommendedAreaUncheckedCreateWithoutRecommendationInput[]
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutRecommendationInput | RecommendedAreaCreateOrConnectWithoutRecommendationInput[]
    upsert?: RecommendedAreaUpsertWithWhereUniqueWithoutRecommendationInput | RecommendedAreaUpsertWithWhereUniqueWithoutRecommendationInput[]
    createMany?: RecommendedAreaCreateManyRecommendationInputEnvelope
    set?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
    disconnect?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
    delete?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
    connect?: RecommendedAreaWhereUniqueInput | RecommendedAreaWhereUniqueInput[]
    update?: RecommendedAreaUpdateWithWhereUniqueWithoutRecommendationInput | RecommendedAreaUpdateWithWhereUniqueWithoutRecommendationInput[]
    updateMany?: RecommendedAreaUpdateManyWithWhereWithoutRecommendationInput | RecommendedAreaUpdateManyWithWhereWithoutRecommendationInput[]
    deleteMany?: RecommendedAreaScalarWhereInput | RecommendedAreaScalarWhereInput[]
  }

  export type RecommendedAreaCreateplacesOfInterestInput = {
    set: string[]
  }

  export type RecommendedAreaCreatelifestyleTagsInput = {
    set: string[]
  }

  export type RecommendationCreateNestedOneWithoutAreasInput = {
    create?: XOR<RecommendationCreateWithoutAreasInput, RecommendationUncheckedCreateWithoutAreasInput>
    connectOrCreate?: RecommendationCreateOrConnectWithoutAreasInput
    connect?: RecommendationWhereUniqueInput
  }

  export type RaceEthnicityCreateNestedOneWithoutAreaInput = {
    create?: XOR<RaceEthnicityCreateWithoutAreaInput, RaceEthnicityUncheckedCreateWithoutAreaInput>
    connectOrCreate?: RaceEthnicityCreateOrConnectWithoutAreaInput
    connect?: RaceEthnicityWhereUniqueInput
  }

  export type IncomeLevelsCreateNestedOneWithoutAreaInput = {
    create?: XOR<IncomeLevelsCreateWithoutAreaInput, IncomeLevelsUncheckedCreateWithoutAreaInput>
    connectOrCreate?: IncomeLevelsCreateOrConnectWithoutAreaInput
    connect?: IncomeLevelsWhereUniqueInput
  }

  export type CrimeDataCreateNestedOneWithoutAreaInput = {
    create?: XOR<CrimeDataCreateWithoutAreaInput, CrimeDataUncheckedCreateWithoutAreaInput>
    connectOrCreate?: CrimeDataCreateOrConnectWithoutAreaInput
    connect?: CrimeDataWhereUniqueInput
  }

  export type SchoolCreateNestedManyWithoutAreaInput = {
    create?: XOR<SchoolCreateWithoutAreaInput, SchoolUncheckedCreateWithoutAreaInput> | SchoolCreateWithoutAreaInput[] | SchoolUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAreaInput | SchoolCreateOrConnectWithoutAreaInput[]
    createMany?: SchoolCreateManyAreaInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type SocialLifeCreateNestedManyWithoutAreaInput = {
    create?: XOR<SocialLifeCreateWithoutAreaInput, SocialLifeUncheckedCreateWithoutAreaInput> | SocialLifeCreateWithoutAreaInput[] | SocialLifeUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SocialLifeCreateOrConnectWithoutAreaInput | SocialLifeCreateOrConnectWithoutAreaInput[]
    createMany?: SocialLifeCreateManyAreaInputEnvelope
    connect?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
  }

  export type ShoppingCreateNestedManyWithoutAreaInput = {
    create?: XOR<ShoppingCreateWithoutAreaInput, ShoppingUncheckedCreateWithoutAreaInput> | ShoppingCreateWithoutAreaInput[] | ShoppingUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ShoppingCreateOrConnectWithoutAreaInput | ShoppingCreateOrConnectWithoutAreaInput[]
    createMany?: ShoppingCreateManyAreaInputEnvelope
    connect?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
  }

  export type GreenSpaceCreateNestedManyWithoutAreaInput = {
    create?: XOR<GreenSpaceCreateWithoutAreaInput, GreenSpaceUncheckedCreateWithoutAreaInput> | GreenSpaceCreateWithoutAreaInput[] | GreenSpaceUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: GreenSpaceCreateOrConnectWithoutAreaInput | GreenSpaceCreateOrConnectWithoutAreaInput[]
    createMany?: GreenSpaceCreateManyAreaInputEnvelope
    connect?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
  }

  export type SportCreateNestedManyWithoutAreaInput = {
    create?: XOR<SportCreateWithoutAreaInput, SportUncheckedCreateWithoutAreaInput> | SportCreateWithoutAreaInput[] | SportUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SportCreateOrConnectWithoutAreaInput | SportCreateOrConnectWithoutAreaInput[]
    createMany?: SportCreateManyAreaInputEnvelope
    connect?: SportWhereUniqueInput | SportWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutAreaInput = {
    create?: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput> | PropertyCreateWithoutAreaInput[] | PropertyUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAreaInput | PropertyCreateOrConnectWithoutAreaInput[]
    createMany?: PropertyCreateManyAreaInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput = {
    create?: XOR<RaceEthnicityCreateWithoutAreaInput, RaceEthnicityUncheckedCreateWithoutAreaInput>
    connectOrCreate?: RaceEthnicityCreateOrConnectWithoutAreaInput
    connect?: RaceEthnicityWhereUniqueInput
  }

  export type IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput = {
    create?: XOR<IncomeLevelsCreateWithoutAreaInput, IncomeLevelsUncheckedCreateWithoutAreaInput>
    connectOrCreate?: IncomeLevelsCreateOrConnectWithoutAreaInput
    connect?: IncomeLevelsWhereUniqueInput
  }

  export type CrimeDataUncheckedCreateNestedOneWithoutAreaInput = {
    create?: XOR<CrimeDataCreateWithoutAreaInput, CrimeDataUncheckedCreateWithoutAreaInput>
    connectOrCreate?: CrimeDataCreateOrConnectWithoutAreaInput
    connect?: CrimeDataWhereUniqueInput
  }

  export type SchoolUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<SchoolCreateWithoutAreaInput, SchoolUncheckedCreateWithoutAreaInput> | SchoolCreateWithoutAreaInput[] | SchoolUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAreaInput | SchoolCreateOrConnectWithoutAreaInput[]
    createMany?: SchoolCreateManyAreaInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type SocialLifeUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<SocialLifeCreateWithoutAreaInput, SocialLifeUncheckedCreateWithoutAreaInput> | SocialLifeCreateWithoutAreaInput[] | SocialLifeUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SocialLifeCreateOrConnectWithoutAreaInput | SocialLifeCreateOrConnectWithoutAreaInput[]
    createMany?: SocialLifeCreateManyAreaInputEnvelope
    connect?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
  }

  export type ShoppingUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<ShoppingCreateWithoutAreaInput, ShoppingUncheckedCreateWithoutAreaInput> | ShoppingCreateWithoutAreaInput[] | ShoppingUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ShoppingCreateOrConnectWithoutAreaInput | ShoppingCreateOrConnectWithoutAreaInput[]
    createMany?: ShoppingCreateManyAreaInputEnvelope
    connect?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
  }

  export type GreenSpaceUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<GreenSpaceCreateWithoutAreaInput, GreenSpaceUncheckedCreateWithoutAreaInput> | GreenSpaceCreateWithoutAreaInput[] | GreenSpaceUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: GreenSpaceCreateOrConnectWithoutAreaInput | GreenSpaceCreateOrConnectWithoutAreaInput[]
    createMany?: GreenSpaceCreateManyAreaInputEnvelope
    connect?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
  }

  export type SportUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<SportCreateWithoutAreaInput, SportUncheckedCreateWithoutAreaInput> | SportCreateWithoutAreaInput[] | SportUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SportCreateOrConnectWithoutAreaInput | SportCreateOrConnectWithoutAreaInput[]
    createMany?: SportCreateManyAreaInputEnvelope
    connect?: SportWhereUniqueInput | SportWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput> | PropertyCreateWithoutAreaInput[] | PropertyUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAreaInput | PropertyCreateOrConnectWithoutAreaInput[]
    createMany?: PropertyCreateManyAreaInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type RecommendedAreaUpdateplacesOfInterestInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RecommendedAreaUpdatelifestyleTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RecommendationUpdateOneRequiredWithoutAreasNestedInput = {
    create?: XOR<RecommendationCreateWithoutAreasInput, RecommendationUncheckedCreateWithoutAreasInput>
    connectOrCreate?: RecommendationCreateOrConnectWithoutAreasInput
    upsert?: RecommendationUpsertWithoutAreasInput
    connect?: RecommendationWhereUniqueInput
    update?: XOR<XOR<RecommendationUpdateToOneWithWhereWithoutAreasInput, RecommendationUpdateWithoutAreasInput>, RecommendationUncheckedUpdateWithoutAreasInput>
  }

  export type RaceEthnicityUpdateOneWithoutAreaNestedInput = {
    create?: XOR<RaceEthnicityCreateWithoutAreaInput, RaceEthnicityUncheckedCreateWithoutAreaInput>
    connectOrCreate?: RaceEthnicityCreateOrConnectWithoutAreaInput
    upsert?: RaceEthnicityUpsertWithoutAreaInput
    disconnect?: RaceEthnicityWhereInput | boolean
    delete?: RaceEthnicityWhereInput | boolean
    connect?: RaceEthnicityWhereUniqueInput
    update?: XOR<XOR<RaceEthnicityUpdateToOneWithWhereWithoutAreaInput, RaceEthnicityUpdateWithoutAreaInput>, RaceEthnicityUncheckedUpdateWithoutAreaInput>
  }

  export type IncomeLevelsUpdateOneWithoutAreaNestedInput = {
    create?: XOR<IncomeLevelsCreateWithoutAreaInput, IncomeLevelsUncheckedCreateWithoutAreaInput>
    connectOrCreate?: IncomeLevelsCreateOrConnectWithoutAreaInput
    upsert?: IncomeLevelsUpsertWithoutAreaInput
    disconnect?: IncomeLevelsWhereInput | boolean
    delete?: IncomeLevelsWhereInput | boolean
    connect?: IncomeLevelsWhereUniqueInput
    update?: XOR<XOR<IncomeLevelsUpdateToOneWithWhereWithoutAreaInput, IncomeLevelsUpdateWithoutAreaInput>, IncomeLevelsUncheckedUpdateWithoutAreaInput>
  }

  export type CrimeDataUpdateOneWithoutAreaNestedInput = {
    create?: XOR<CrimeDataCreateWithoutAreaInput, CrimeDataUncheckedCreateWithoutAreaInput>
    connectOrCreate?: CrimeDataCreateOrConnectWithoutAreaInput
    upsert?: CrimeDataUpsertWithoutAreaInput
    disconnect?: CrimeDataWhereInput | boolean
    delete?: CrimeDataWhereInput | boolean
    connect?: CrimeDataWhereUniqueInput
    update?: XOR<XOR<CrimeDataUpdateToOneWithWhereWithoutAreaInput, CrimeDataUpdateWithoutAreaInput>, CrimeDataUncheckedUpdateWithoutAreaInput>
  }

  export type SchoolUpdateManyWithoutAreaNestedInput = {
    create?: XOR<SchoolCreateWithoutAreaInput, SchoolUncheckedCreateWithoutAreaInput> | SchoolCreateWithoutAreaInput[] | SchoolUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAreaInput | SchoolCreateOrConnectWithoutAreaInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutAreaInput | SchoolUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: SchoolCreateManyAreaInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutAreaInput | SchoolUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutAreaInput | SchoolUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type SocialLifeUpdateManyWithoutAreaNestedInput = {
    create?: XOR<SocialLifeCreateWithoutAreaInput, SocialLifeUncheckedCreateWithoutAreaInput> | SocialLifeCreateWithoutAreaInput[] | SocialLifeUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SocialLifeCreateOrConnectWithoutAreaInput | SocialLifeCreateOrConnectWithoutAreaInput[]
    upsert?: SocialLifeUpsertWithWhereUniqueWithoutAreaInput | SocialLifeUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: SocialLifeCreateManyAreaInputEnvelope
    set?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
    disconnect?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
    delete?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
    connect?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
    update?: SocialLifeUpdateWithWhereUniqueWithoutAreaInput | SocialLifeUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: SocialLifeUpdateManyWithWhereWithoutAreaInput | SocialLifeUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: SocialLifeScalarWhereInput | SocialLifeScalarWhereInput[]
  }

  export type ShoppingUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ShoppingCreateWithoutAreaInput, ShoppingUncheckedCreateWithoutAreaInput> | ShoppingCreateWithoutAreaInput[] | ShoppingUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ShoppingCreateOrConnectWithoutAreaInput | ShoppingCreateOrConnectWithoutAreaInput[]
    upsert?: ShoppingUpsertWithWhereUniqueWithoutAreaInput | ShoppingUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ShoppingCreateManyAreaInputEnvelope
    set?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
    disconnect?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
    delete?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
    connect?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
    update?: ShoppingUpdateWithWhereUniqueWithoutAreaInput | ShoppingUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ShoppingUpdateManyWithWhereWithoutAreaInput | ShoppingUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ShoppingScalarWhereInput | ShoppingScalarWhereInput[]
  }

  export type GreenSpaceUpdateManyWithoutAreaNestedInput = {
    create?: XOR<GreenSpaceCreateWithoutAreaInput, GreenSpaceUncheckedCreateWithoutAreaInput> | GreenSpaceCreateWithoutAreaInput[] | GreenSpaceUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: GreenSpaceCreateOrConnectWithoutAreaInput | GreenSpaceCreateOrConnectWithoutAreaInput[]
    upsert?: GreenSpaceUpsertWithWhereUniqueWithoutAreaInput | GreenSpaceUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: GreenSpaceCreateManyAreaInputEnvelope
    set?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
    disconnect?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
    delete?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
    connect?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
    update?: GreenSpaceUpdateWithWhereUniqueWithoutAreaInput | GreenSpaceUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: GreenSpaceUpdateManyWithWhereWithoutAreaInput | GreenSpaceUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: GreenSpaceScalarWhereInput | GreenSpaceScalarWhereInput[]
  }

  export type SportUpdateManyWithoutAreaNestedInput = {
    create?: XOR<SportCreateWithoutAreaInput, SportUncheckedCreateWithoutAreaInput> | SportCreateWithoutAreaInput[] | SportUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SportCreateOrConnectWithoutAreaInput | SportCreateOrConnectWithoutAreaInput[]
    upsert?: SportUpsertWithWhereUniqueWithoutAreaInput | SportUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: SportCreateManyAreaInputEnvelope
    set?: SportWhereUniqueInput | SportWhereUniqueInput[]
    disconnect?: SportWhereUniqueInput | SportWhereUniqueInput[]
    delete?: SportWhereUniqueInput | SportWhereUniqueInput[]
    connect?: SportWhereUniqueInput | SportWhereUniqueInput[]
    update?: SportUpdateWithWhereUniqueWithoutAreaInput | SportUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: SportUpdateManyWithWhereWithoutAreaInput | SportUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: SportScalarWhereInput | SportScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutAreaNestedInput = {
    create?: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput> | PropertyCreateWithoutAreaInput[] | PropertyUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAreaInput | PropertyCreateOrConnectWithoutAreaInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutAreaInput | PropertyUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: PropertyCreateManyAreaInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutAreaInput | PropertyUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutAreaInput | PropertyUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput = {
    create?: XOR<RaceEthnicityCreateWithoutAreaInput, RaceEthnicityUncheckedCreateWithoutAreaInput>
    connectOrCreate?: RaceEthnicityCreateOrConnectWithoutAreaInput
    upsert?: RaceEthnicityUpsertWithoutAreaInput
    disconnect?: RaceEthnicityWhereInput | boolean
    delete?: RaceEthnicityWhereInput | boolean
    connect?: RaceEthnicityWhereUniqueInput
    update?: XOR<XOR<RaceEthnicityUpdateToOneWithWhereWithoutAreaInput, RaceEthnicityUpdateWithoutAreaInput>, RaceEthnicityUncheckedUpdateWithoutAreaInput>
  }

  export type IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput = {
    create?: XOR<IncomeLevelsCreateWithoutAreaInput, IncomeLevelsUncheckedCreateWithoutAreaInput>
    connectOrCreate?: IncomeLevelsCreateOrConnectWithoutAreaInput
    upsert?: IncomeLevelsUpsertWithoutAreaInput
    disconnect?: IncomeLevelsWhereInput | boolean
    delete?: IncomeLevelsWhereInput | boolean
    connect?: IncomeLevelsWhereUniqueInput
    update?: XOR<XOR<IncomeLevelsUpdateToOneWithWhereWithoutAreaInput, IncomeLevelsUpdateWithoutAreaInput>, IncomeLevelsUncheckedUpdateWithoutAreaInput>
  }

  export type CrimeDataUncheckedUpdateOneWithoutAreaNestedInput = {
    create?: XOR<CrimeDataCreateWithoutAreaInput, CrimeDataUncheckedCreateWithoutAreaInput>
    connectOrCreate?: CrimeDataCreateOrConnectWithoutAreaInput
    upsert?: CrimeDataUpsertWithoutAreaInput
    disconnect?: CrimeDataWhereInput | boolean
    delete?: CrimeDataWhereInput | boolean
    connect?: CrimeDataWhereUniqueInput
    update?: XOR<XOR<CrimeDataUpdateToOneWithWhereWithoutAreaInput, CrimeDataUpdateWithoutAreaInput>, CrimeDataUncheckedUpdateWithoutAreaInput>
  }

  export type SchoolUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<SchoolCreateWithoutAreaInput, SchoolUncheckedCreateWithoutAreaInput> | SchoolCreateWithoutAreaInput[] | SchoolUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAreaInput | SchoolCreateOrConnectWithoutAreaInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutAreaInput | SchoolUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: SchoolCreateManyAreaInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutAreaInput | SchoolUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutAreaInput | SchoolUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type SocialLifeUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<SocialLifeCreateWithoutAreaInput, SocialLifeUncheckedCreateWithoutAreaInput> | SocialLifeCreateWithoutAreaInput[] | SocialLifeUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SocialLifeCreateOrConnectWithoutAreaInput | SocialLifeCreateOrConnectWithoutAreaInput[]
    upsert?: SocialLifeUpsertWithWhereUniqueWithoutAreaInput | SocialLifeUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: SocialLifeCreateManyAreaInputEnvelope
    set?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
    disconnect?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
    delete?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
    connect?: SocialLifeWhereUniqueInput | SocialLifeWhereUniqueInput[]
    update?: SocialLifeUpdateWithWhereUniqueWithoutAreaInput | SocialLifeUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: SocialLifeUpdateManyWithWhereWithoutAreaInput | SocialLifeUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: SocialLifeScalarWhereInput | SocialLifeScalarWhereInput[]
  }

  export type ShoppingUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ShoppingCreateWithoutAreaInput, ShoppingUncheckedCreateWithoutAreaInput> | ShoppingCreateWithoutAreaInput[] | ShoppingUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ShoppingCreateOrConnectWithoutAreaInput | ShoppingCreateOrConnectWithoutAreaInput[]
    upsert?: ShoppingUpsertWithWhereUniqueWithoutAreaInput | ShoppingUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ShoppingCreateManyAreaInputEnvelope
    set?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
    disconnect?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
    delete?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
    connect?: ShoppingWhereUniqueInput | ShoppingWhereUniqueInput[]
    update?: ShoppingUpdateWithWhereUniqueWithoutAreaInput | ShoppingUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ShoppingUpdateManyWithWhereWithoutAreaInput | ShoppingUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ShoppingScalarWhereInput | ShoppingScalarWhereInput[]
  }

  export type GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<GreenSpaceCreateWithoutAreaInput, GreenSpaceUncheckedCreateWithoutAreaInput> | GreenSpaceCreateWithoutAreaInput[] | GreenSpaceUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: GreenSpaceCreateOrConnectWithoutAreaInput | GreenSpaceCreateOrConnectWithoutAreaInput[]
    upsert?: GreenSpaceUpsertWithWhereUniqueWithoutAreaInput | GreenSpaceUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: GreenSpaceCreateManyAreaInputEnvelope
    set?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
    disconnect?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
    delete?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
    connect?: GreenSpaceWhereUniqueInput | GreenSpaceWhereUniqueInput[]
    update?: GreenSpaceUpdateWithWhereUniqueWithoutAreaInput | GreenSpaceUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: GreenSpaceUpdateManyWithWhereWithoutAreaInput | GreenSpaceUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: GreenSpaceScalarWhereInput | GreenSpaceScalarWhereInput[]
  }

  export type SportUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<SportCreateWithoutAreaInput, SportUncheckedCreateWithoutAreaInput> | SportCreateWithoutAreaInput[] | SportUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: SportCreateOrConnectWithoutAreaInput | SportCreateOrConnectWithoutAreaInput[]
    upsert?: SportUpsertWithWhereUniqueWithoutAreaInput | SportUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: SportCreateManyAreaInputEnvelope
    set?: SportWhereUniqueInput | SportWhereUniqueInput[]
    disconnect?: SportWhereUniqueInput | SportWhereUniqueInput[]
    delete?: SportWhereUniqueInput | SportWhereUniqueInput[]
    connect?: SportWhereUniqueInput | SportWhereUniqueInput[]
    update?: SportUpdateWithWhereUniqueWithoutAreaInput | SportUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: SportUpdateManyWithWhereWithoutAreaInput | SportUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: SportScalarWhereInput | SportScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput> | PropertyCreateWithoutAreaInput[] | PropertyUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutAreaInput | PropertyCreateOrConnectWithoutAreaInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutAreaInput | PropertyUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: PropertyCreateManyAreaInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutAreaInput | PropertyUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutAreaInput | PropertyUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type RecommendedAreaCreateNestedOneWithoutRaceEthnicityInput = {
    create?: XOR<RecommendedAreaCreateWithoutRaceEthnicityInput, RecommendedAreaUncheckedCreateWithoutRaceEthnicityInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutRaceEthnicityInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RecommendedAreaUpdateOneRequiredWithoutRaceEthnicityNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutRaceEthnicityInput, RecommendedAreaUncheckedCreateWithoutRaceEthnicityInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutRaceEthnicityInput
    upsert?: RecommendedAreaUpsertWithoutRaceEthnicityInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutRaceEthnicityInput, RecommendedAreaUpdateWithoutRaceEthnicityInput>, RecommendedAreaUncheckedUpdateWithoutRaceEthnicityInput>
  }

  export type RecommendedAreaCreateNestedOneWithoutIncomeLevelsInput = {
    create?: XOR<RecommendedAreaCreateWithoutIncomeLevelsInput, RecommendedAreaUncheckedCreateWithoutIncomeLevelsInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutIncomeLevelsInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type RecommendedAreaUpdateOneRequiredWithoutIncomeLevelsNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutIncomeLevelsInput, RecommendedAreaUncheckedCreateWithoutIncomeLevelsInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutIncomeLevelsInput
    upsert?: RecommendedAreaUpsertWithoutIncomeLevelsInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutIncomeLevelsInput, RecommendedAreaUpdateWithoutIncomeLevelsInput>, RecommendedAreaUncheckedUpdateWithoutIncomeLevelsInput>
  }

  export type RecommendedAreaCreateNestedOneWithoutCrimeDataInput = {
    create?: XOR<RecommendedAreaCreateWithoutCrimeDataInput, RecommendedAreaUncheckedCreateWithoutCrimeDataInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutCrimeDataInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type RecommendedAreaUpdateOneRequiredWithoutCrimeDataNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutCrimeDataInput, RecommendedAreaUncheckedCreateWithoutCrimeDataInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutCrimeDataInput
    upsert?: RecommendedAreaUpsertWithoutCrimeDataInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutCrimeDataInput, RecommendedAreaUpdateWithoutCrimeDataInput>, RecommendedAreaUncheckedUpdateWithoutCrimeDataInput>
  }

  export type RecommendedAreaCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<RecommendedAreaCreateWithoutSchoolsInput, RecommendedAreaUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutSchoolsInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type RecommendedAreaUpdateOneRequiredWithoutSchoolsNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutSchoolsInput, RecommendedAreaUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutSchoolsInput
    upsert?: RecommendedAreaUpsertWithoutSchoolsInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutSchoolsInput, RecommendedAreaUpdateWithoutSchoolsInput>, RecommendedAreaUncheckedUpdateWithoutSchoolsInput>
  }

  export type RecommendedAreaCreateNestedOneWithoutSocialLifeInput = {
    create?: XOR<RecommendedAreaCreateWithoutSocialLifeInput, RecommendedAreaUncheckedCreateWithoutSocialLifeInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutSocialLifeInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type RecommendedAreaUpdateOneRequiredWithoutSocialLifeNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutSocialLifeInput, RecommendedAreaUncheckedCreateWithoutSocialLifeInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutSocialLifeInput
    upsert?: RecommendedAreaUpsertWithoutSocialLifeInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutSocialLifeInput, RecommendedAreaUpdateWithoutSocialLifeInput>, RecommendedAreaUncheckedUpdateWithoutSocialLifeInput>
  }

  export type RecommendedAreaCreateNestedOneWithoutShoppingInput = {
    create?: XOR<RecommendedAreaCreateWithoutShoppingInput, RecommendedAreaUncheckedCreateWithoutShoppingInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutShoppingInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type RecommendedAreaUpdateOneRequiredWithoutShoppingNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutShoppingInput, RecommendedAreaUncheckedCreateWithoutShoppingInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutShoppingInput
    upsert?: RecommendedAreaUpsertWithoutShoppingInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutShoppingInput, RecommendedAreaUpdateWithoutShoppingInput>, RecommendedAreaUncheckedUpdateWithoutShoppingInput>
  }

  export type RecommendedAreaCreateNestedOneWithoutGreenSpacesInput = {
    create?: XOR<RecommendedAreaCreateWithoutGreenSpacesInput, RecommendedAreaUncheckedCreateWithoutGreenSpacesInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutGreenSpacesInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type RecommendedAreaUpdateOneRequiredWithoutGreenSpacesNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutGreenSpacesInput, RecommendedAreaUncheckedCreateWithoutGreenSpacesInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutGreenSpacesInput
    upsert?: RecommendedAreaUpsertWithoutGreenSpacesInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutGreenSpacesInput, RecommendedAreaUpdateWithoutGreenSpacesInput>, RecommendedAreaUncheckedUpdateWithoutGreenSpacesInput>
  }

  export type RecommendedAreaCreateNestedOneWithoutSportsInput = {
    create?: XOR<RecommendedAreaCreateWithoutSportsInput, RecommendedAreaUncheckedCreateWithoutSportsInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutSportsInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type RecommendedAreaUpdateOneRequiredWithoutSportsNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutSportsInput, RecommendedAreaUncheckedCreateWithoutSportsInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutSportsInput
    upsert?: RecommendedAreaUpsertWithoutSportsInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutSportsInput, RecommendedAreaUpdateWithoutSportsInput>, RecommendedAreaUncheckedUpdateWithoutSportsInput>
  }

  export type PropertyCreateimageUrlsInput = {
    set: string[]
  }

  export type RecommendedAreaCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<RecommendedAreaCreateWithoutPropertiesInput, RecommendedAreaUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutPropertiesInput
    connect?: RecommendedAreaWhereUniqueInput
  }

  export type PropertyUpdateimageUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type RecommendedAreaUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<RecommendedAreaCreateWithoutPropertiesInput, RecommendedAreaUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: RecommendedAreaCreateOrConnectWithoutPropertiesInput
    upsert?: RecommendedAreaUpsertWithoutPropertiesInput
    connect?: RecommendedAreaWhereUniqueInput
    update?: XOR<XOR<RecommendedAreaUpdateToOneWithWhereWithoutPropertiesInput, RecommendedAreaUpdateWithoutPropertiesInput>, RecommendedAreaUncheckedUpdateWithoutPropertiesInput>
  }

  export type RecommendationCreateNestedOneWithoutPropertySuggestionInput = {
    create?: XOR<RecommendationCreateWithoutPropertySuggestionInput, RecommendationUncheckedCreateWithoutPropertySuggestionInput>
    connectOrCreate?: RecommendationCreateOrConnectWithoutPropertySuggestionInput
    connect?: RecommendationWhereUniqueInput
  }

  export type RecommendationUpdateOneRequiredWithoutPropertySuggestionNestedInput = {
    create?: XOR<RecommendationCreateWithoutPropertySuggestionInput, RecommendationUncheckedCreateWithoutPropertySuggestionInput>
    connectOrCreate?: RecommendationCreateOrConnectWithoutPropertySuggestionInput
    upsert?: RecommendationUpsertWithoutPropertySuggestionInput
    connect?: RecommendationWhereUniqueInput
    update?: XOR<XOR<RecommendationUpdateToOneWithWhereWithoutPropertySuggestionInput, RecommendationUpdateWithoutPropertySuggestionInput>, RecommendationUncheckedUpdateWithoutPropertySuggestionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumJourneyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JourneyStatus | EnumJourneyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJourneyStatusFilter<$PrismaModel> | $Enums.JourneyStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumJourneyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JourneyStatus | EnumJourneyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JourneyStatus[] | ListEnumJourneyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJourneyStatusWithAggregatesFilter<$PrismaModel> | $Enums.JourneyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJourneyStatusFilter<$PrismaModel>
    _max?: NestedEnumJourneyStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type OtpCodeCreateWithoutUserInput = {
    code: string
    phone: string
    email: string
    countryCode: string
    expiresAt: Date | string
    createdAt?: Date | string
    attempts?: number
  }

  export type OtpCodeUncheckedCreateWithoutUserInput = {
    id?: number
    code: string
    phone: string
    email: string
    countryCode: string
    expiresAt: Date | string
    createdAt?: Date | string
    attempts?: number
  }

  export type OtpCodeCreateOrConnectWithoutUserInput = {
    where: OtpCodeWhereUniqueInput
    create: XOR<OtpCodeCreateWithoutUserInput, OtpCodeUncheckedCreateWithoutUserInput>
  }

  export type OtpCodeCreateManyUserInputEnvelope = {
    data: OtpCodeCreateManyUserInput | OtpCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecommendationCreateWithoutUserInput = {
    createdAt?: Date | string
    journey?: JourneyCreateNestedOneWithoutRecommendationInput
    propertySuggestion?: PropertySuggestionCreateNestedOneWithoutRecommendationInput
    areas?: RecommendedAreaCreateNestedManyWithoutRecommendationInput
  }

  export type RecommendationUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    journeyId?: number | null
    propertySuggestion?: PropertySuggestionUncheckedCreateNestedOneWithoutRecommendationInput
    areas?: RecommendedAreaUncheckedCreateNestedManyWithoutRecommendationInput
  }

  export type RecommendationCreateOrConnectWithoutUserInput = {
    where: RecommendationWhereUniqueInput
    create: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput>
  }

  export type RecommendationCreateManyUserInputEnvelope = {
    data: RecommendationCreateManyUserInput | RecommendationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JourneyCreateWithoutUserInput = {
    createdAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.JourneyStatus
    label?: string | null
    selectedState?: string | null
    selectedCities?: JourneyCreateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: number
    recommendation?: RecommendationCreateNestedOneWithoutJourneyInput
  }

  export type JourneyUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.JourneyStatus
    label?: string | null
    selectedState?: string | null
    selectedCities?: JourneyCreateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: number
    recommendation?: RecommendationUncheckedCreateNestedOneWithoutJourneyInput
  }

  export type JourneyCreateOrConnectWithoutUserInput = {
    where: JourneyWhereUniqueInput
    create: XOR<JourneyCreateWithoutUserInput, JourneyUncheckedCreateWithoutUserInput>
  }

  export type JourneyCreateManyUserInputEnvelope = {
    data: JourneyCreateManyUserInput | JourneyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OtpCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: OtpCodeWhereUniqueInput
    update: XOR<OtpCodeUpdateWithoutUserInput, OtpCodeUncheckedUpdateWithoutUserInput>
    create: XOR<OtpCodeCreateWithoutUserInput, OtpCodeUncheckedCreateWithoutUserInput>
  }

  export type OtpCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: OtpCodeWhereUniqueInput
    data: XOR<OtpCodeUpdateWithoutUserInput, OtpCodeUncheckedUpdateWithoutUserInput>
  }

  export type OtpCodeUpdateManyWithWhereWithoutUserInput = {
    where: OtpCodeScalarWhereInput
    data: XOR<OtpCodeUpdateManyMutationInput, OtpCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type OtpCodeScalarWhereInput = {
    AND?: OtpCodeScalarWhereInput | OtpCodeScalarWhereInput[]
    OR?: OtpCodeScalarWhereInput[]
    NOT?: OtpCodeScalarWhereInput | OtpCodeScalarWhereInput[]
    id?: IntFilter<"OtpCode"> | number
    code?: StringFilter<"OtpCode"> | string
    phone?: StringFilter<"OtpCode"> | string
    email?: StringFilter<"OtpCode"> | string
    countryCode?: StringFilter<"OtpCode"> | string
    expiresAt?: DateTimeFilter<"OtpCode"> | Date | string
    userId?: IntNullableFilter<"OtpCode"> | number | null
    createdAt?: DateTimeFilter<"OtpCode"> | Date | string
    attempts?: IntFilter<"OtpCode"> | number
  }

  export type RecommendationUpsertWithWhereUniqueWithoutUserInput = {
    where: RecommendationWhereUniqueInput
    update: XOR<RecommendationUpdateWithoutUserInput, RecommendationUncheckedUpdateWithoutUserInput>
    create: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput>
  }

  export type RecommendationUpdateWithWhereUniqueWithoutUserInput = {
    where: RecommendationWhereUniqueInput
    data: XOR<RecommendationUpdateWithoutUserInput, RecommendationUncheckedUpdateWithoutUserInput>
  }

  export type RecommendationUpdateManyWithWhereWithoutUserInput = {
    where: RecommendationScalarWhereInput
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyWithoutUserInput>
  }

  export type RecommendationScalarWhereInput = {
    AND?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
    OR?: RecommendationScalarWhereInput[]
    NOT?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
    id?: IntFilter<"Recommendation"> | number
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    userId?: IntFilter<"Recommendation"> | number
    journeyId?: IntNullableFilter<"Recommendation"> | number | null
  }

  export type JourneyUpsertWithWhereUniqueWithoutUserInput = {
    where: JourneyWhereUniqueInput
    update: XOR<JourneyUpdateWithoutUserInput, JourneyUncheckedUpdateWithoutUserInput>
    create: XOR<JourneyCreateWithoutUserInput, JourneyUncheckedCreateWithoutUserInput>
  }

  export type JourneyUpdateWithWhereUniqueWithoutUserInput = {
    where: JourneyWhereUniqueInput
    data: XOR<JourneyUpdateWithoutUserInput, JourneyUncheckedUpdateWithoutUserInput>
  }

  export type JourneyUpdateManyWithWhereWithoutUserInput = {
    where: JourneyScalarWhereInput
    data: XOR<JourneyUpdateManyMutationInput, JourneyUncheckedUpdateManyWithoutUserInput>
  }

  export type JourneyScalarWhereInput = {
    AND?: JourneyScalarWhereInput | JourneyScalarWhereInput[]
    OR?: JourneyScalarWhereInput[]
    NOT?: JourneyScalarWhereInput | JourneyScalarWhereInput[]
    id?: IntFilter<"Journey"> | number
    createdAt?: DateTimeFilter<"Journey"> | Date | string
    completedAt?: DateTimeNullableFilter<"Journey"> | Date | string | null
    status?: EnumJourneyStatusFilter<"Journey"> | $Enums.JourneyStatus
    label?: StringNullableFilter<"Journey"> | string | null
    selectedState?: StringNullableFilter<"Journey"> | string | null
    selectedCities?: StringNullableListFilter<"Journey">
    inputs?: JsonNullableFilter<"Journey">
    index?: IntFilter<"Journey"> | number
    userId?: IntFilter<"Journey"> | number
  }

  export type UserCreateWithoutOtpCodesInput = {
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
    Recommendation?: RecommendationCreateNestedManyWithoutUserInput
    journeys?: JourneyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpCodesInput = {
    id?: number
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
    Recommendation?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpCodesInput, UserUncheckedCreateWithoutOtpCodesInput>
  }

  export type UserUpsertWithoutOtpCodesInput = {
    update: XOR<UserUpdateWithoutOtpCodesInput, UserUncheckedUpdateWithoutOtpCodesInput>
    create: XOR<UserCreateWithoutOtpCodesInput, UserUncheckedCreateWithoutOtpCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpCodesInput, UserUncheckedUpdateWithoutOtpCodesInput>
  }

  export type UserUpdateWithoutOtpCodesInput = {
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    Recommendation?: RecommendationUpdateManyWithoutUserNestedInput
    journeys?: JourneyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    Recommendation?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutJourneysInput = {
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
    otpCodes?: OtpCodeCreateNestedManyWithoutUserInput
    Recommendation?: RecommendationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJourneysInput = {
    id?: number
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
    otpCodes?: OtpCodeUncheckedCreateNestedManyWithoutUserInput
    Recommendation?: RecommendationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJourneysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJourneysInput, UserUncheckedCreateWithoutJourneysInput>
  }

  export type RecommendationCreateWithoutJourneyInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRecommendationInput
    propertySuggestion?: PropertySuggestionCreateNestedOneWithoutRecommendationInput
    areas?: RecommendedAreaCreateNestedManyWithoutRecommendationInput
  }

  export type RecommendationUncheckedCreateWithoutJourneyInput = {
    id?: number
    createdAt?: Date | string
    userId: number
    propertySuggestion?: PropertySuggestionUncheckedCreateNestedOneWithoutRecommendationInput
    areas?: RecommendedAreaUncheckedCreateNestedManyWithoutRecommendationInput
  }

  export type RecommendationCreateOrConnectWithoutJourneyInput = {
    where: RecommendationWhereUniqueInput
    create: XOR<RecommendationCreateWithoutJourneyInput, RecommendationUncheckedCreateWithoutJourneyInput>
  }

  export type UserUpsertWithoutJourneysInput = {
    update: XOR<UserUpdateWithoutJourneysInput, UserUncheckedUpdateWithoutJourneysInput>
    create: XOR<UserCreateWithoutJourneysInput, UserUncheckedCreateWithoutJourneysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJourneysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJourneysInput, UserUncheckedUpdateWithoutJourneysInput>
  }

  export type UserUpdateWithoutJourneysInput = {
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    otpCodes?: OtpCodeUpdateManyWithoutUserNestedInput
    Recommendation?: RecommendationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJourneysInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    otpCodes?: OtpCodeUncheckedUpdateManyWithoutUserNestedInput
    Recommendation?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecommendationUpsertWithoutJourneyInput = {
    update: XOR<RecommendationUpdateWithoutJourneyInput, RecommendationUncheckedUpdateWithoutJourneyInput>
    create: XOR<RecommendationCreateWithoutJourneyInput, RecommendationUncheckedCreateWithoutJourneyInput>
    where?: RecommendationWhereInput
  }

  export type RecommendationUpdateToOneWithWhereWithoutJourneyInput = {
    where?: RecommendationWhereInput
    data: XOR<RecommendationUpdateWithoutJourneyInput, RecommendationUncheckedUpdateWithoutJourneyInput>
  }

  export type RecommendationUpdateWithoutJourneyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecommendationNestedInput
    propertySuggestion?: PropertySuggestionUpdateOneWithoutRecommendationNestedInput
    areas?: RecommendedAreaUpdateManyWithoutRecommendationNestedInput
  }

  export type RecommendationUncheckedUpdateWithoutJourneyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    propertySuggestion?: PropertySuggestionUncheckedUpdateOneWithoutRecommendationNestedInput
    areas?: RecommendedAreaUncheckedUpdateManyWithoutRecommendationNestedInput
  }

  export type UserCreateWithoutRecommendationInput = {
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
    otpCodes?: OtpCodeCreateNestedManyWithoutUserInput
    journeys?: JourneyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecommendationInput = {
    id?: number
    email: string
    phone: string
    createdAt?: Date | string
    countryCode: string
    name?: string | null
    state?: string | null
    city?: UserCreatecityInput | string[]
    environment?: string | null
    education1?: UserCreateeducation1Input | string[]
    education2?: UserCreateeducation2Input | string[]
    family?: UserCreatefamilyInput | string[]
    employment1?: UserCreateemployment1Input | string[]
    employment2?: UserCreateemployment2Input | string[]
    socialLife?: UserCreatesocialLifeInput | string[]
    hobbies?: UserCreatehobbiesInput | string[]
    transportation?: UserCreatetransportationInput | string[]
    pets?: UserCreatepetsInput | string[]
    greenSpace?: UserCreategreenSpaceInput | string[]
    shopping?: UserCreateshoppingInput | string[]
    restaurants?: UserCreaterestaurantsInput | string[]
    occupancy?: string | null
    property?: string | null
    timeframe?: string | null
    priceRange?: string | null
    downPayment?: string | null
    employmentStatus?: string | null
    grossAnnual?: number | null
    credit?: string | null
    otpCodes?: OtpCodeUncheckedCreateNestedManyWithoutUserInput
    journeys?: JourneyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecommendationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecommendationInput, UserUncheckedCreateWithoutRecommendationInput>
  }

  export type JourneyCreateWithoutRecommendationInput = {
    createdAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.JourneyStatus
    label?: string | null
    selectedState?: string | null
    selectedCities?: JourneyCreateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: number
    user: UserCreateNestedOneWithoutJourneysInput
  }

  export type JourneyUncheckedCreateWithoutRecommendationInput = {
    id?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.JourneyStatus
    label?: string | null
    selectedState?: string | null
    selectedCities?: JourneyCreateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: number
    userId: number
  }

  export type JourneyCreateOrConnectWithoutRecommendationInput = {
    where: JourneyWhereUniqueInput
    create: XOR<JourneyCreateWithoutRecommendationInput, JourneyUncheckedCreateWithoutRecommendationInput>
  }

  export type PropertySuggestionCreateWithoutRecommendationInput = {
    type: string
    idealFor: string
    priceRange: string
    fullDescription?: string | null
  }

  export type PropertySuggestionUncheckedCreateWithoutRecommendationInput = {
    id?: number
    type: string
    idealFor: string
    priceRange: string
    fullDescription?: string | null
  }

  export type PropertySuggestionCreateOrConnectWithoutRecommendationInput = {
    where: PropertySuggestionWhereUniqueInput
    create: XOR<PropertySuggestionCreateWithoutRecommendationInput, PropertySuggestionUncheckedCreateWithoutRecommendationInput>
  }

  export type RecommendedAreaCreateWithoutRecommendationInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutRecommendationInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutRecommendationInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutRecommendationInput, RecommendedAreaUncheckedCreateWithoutRecommendationInput>
  }

  export type RecommendedAreaCreateManyRecommendationInputEnvelope = {
    data: RecommendedAreaCreateManyRecommendationInput | RecommendedAreaCreateManyRecommendationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRecommendationInput = {
    update: XOR<UserUpdateWithoutRecommendationInput, UserUncheckedUpdateWithoutRecommendationInput>
    create: XOR<UserCreateWithoutRecommendationInput, UserUncheckedCreateWithoutRecommendationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecommendationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecommendationInput, UserUncheckedUpdateWithoutRecommendationInput>
  }

  export type UserUpdateWithoutRecommendationInput = {
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    otpCodes?: OtpCodeUpdateManyWithoutUserNestedInput
    journeys?: JourneyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecommendationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: UserUpdatecityInput | string[]
    environment?: NullableStringFieldUpdateOperationsInput | string | null
    education1?: UserUpdateeducation1Input | string[]
    education2?: UserUpdateeducation2Input | string[]
    family?: UserUpdatefamilyInput | string[]
    employment1?: UserUpdateemployment1Input | string[]
    employment2?: UserUpdateemployment2Input | string[]
    socialLife?: UserUpdatesocialLifeInput | string[]
    hobbies?: UserUpdatehobbiesInput | string[]
    transportation?: UserUpdatetransportationInput | string[]
    pets?: UserUpdatepetsInput | string[]
    greenSpace?: UserUpdategreenSpaceInput | string[]
    shopping?: UserUpdateshoppingInput | string[]
    restaurants?: UserUpdaterestaurantsInput | string[]
    occupancy?: NullableStringFieldUpdateOperationsInput | string | null
    property?: NullableStringFieldUpdateOperationsInput | string | null
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    priceRange?: NullableStringFieldUpdateOperationsInput | string | null
    downPayment?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    grossAnnual?: NullableIntFieldUpdateOperationsInput | number | null
    credit?: NullableStringFieldUpdateOperationsInput | string | null
    otpCodes?: OtpCodeUncheckedUpdateManyWithoutUserNestedInput
    journeys?: JourneyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JourneyUpsertWithoutRecommendationInput = {
    update: XOR<JourneyUpdateWithoutRecommendationInput, JourneyUncheckedUpdateWithoutRecommendationInput>
    create: XOR<JourneyCreateWithoutRecommendationInput, JourneyUncheckedCreateWithoutRecommendationInput>
    where?: JourneyWhereInput
  }

  export type JourneyUpdateToOneWithWhereWithoutRecommendationInput = {
    where?: JourneyWhereInput
    data: XOR<JourneyUpdateWithoutRecommendationInput, JourneyUncheckedUpdateWithoutRecommendationInput>
  }

  export type JourneyUpdateWithoutRecommendationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutJourneysNestedInput
  }

  export type JourneyUncheckedUpdateWithoutRecommendationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PropertySuggestionUpsertWithoutRecommendationInput = {
    update: XOR<PropertySuggestionUpdateWithoutRecommendationInput, PropertySuggestionUncheckedUpdateWithoutRecommendationInput>
    create: XOR<PropertySuggestionCreateWithoutRecommendationInput, PropertySuggestionUncheckedCreateWithoutRecommendationInput>
    where?: PropertySuggestionWhereInput
  }

  export type PropertySuggestionUpdateToOneWithWhereWithoutRecommendationInput = {
    where?: PropertySuggestionWhereInput
    data: XOR<PropertySuggestionUpdateWithoutRecommendationInput, PropertySuggestionUncheckedUpdateWithoutRecommendationInput>
  }

  export type PropertySuggestionUpdateWithoutRecommendationInput = {
    type?: StringFieldUpdateOperationsInput | string
    idealFor?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertySuggestionUncheckedUpdateWithoutRecommendationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    idealFor?: StringFieldUpdateOperationsInput | string
    priceRange?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecommendedAreaUpsertWithWhereUniqueWithoutRecommendationInput = {
    where: RecommendedAreaWhereUniqueInput
    update: XOR<RecommendedAreaUpdateWithoutRecommendationInput, RecommendedAreaUncheckedUpdateWithoutRecommendationInput>
    create: XOR<RecommendedAreaCreateWithoutRecommendationInput, RecommendedAreaUncheckedCreateWithoutRecommendationInput>
  }

  export type RecommendedAreaUpdateWithWhereUniqueWithoutRecommendationInput = {
    where: RecommendedAreaWhereUniqueInput
    data: XOR<RecommendedAreaUpdateWithoutRecommendationInput, RecommendedAreaUncheckedUpdateWithoutRecommendationInput>
  }

  export type RecommendedAreaUpdateManyWithWhereWithoutRecommendationInput = {
    where: RecommendedAreaScalarWhereInput
    data: XOR<RecommendedAreaUpdateManyMutationInput, RecommendedAreaUncheckedUpdateManyWithoutRecommendationInput>
  }

  export type RecommendedAreaScalarWhereInput = {
    AND?: RecommendedAreaScalarWhereInput | RecommendedAreaScalarWhereInput[]
    OR?: RecommendedAreaScalarWhereInput[]
    NOT?: RecommendedAreaScalarWhereInput | RecommendedAreaScalarWhereInput[]
    id?: IntFilter<"RecommendedArea"> | number
    name?: StringFilter<"RecommendedArea"> | string
    state?: StringFilter<"RecommendedArea"> | string
    reason?: StringFilter<"RecommendedArea"> | string
    imageUrl?: StringNullableFilter<"RecommendedArea"> | string | null
    fullDescription?: StringNullableFilter<"RecommendedArea"> | string | null
    recommendationId?: IntFilter<"RecommendedArea"> | number
    placesOfInterest?: StringNullableListFilter<"RecommendedArea">
    lifestyleTags?: StringNullableListFilter<"RecommendedArea">
  }

  export type RecommendationCreateWithoutAreasInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRecommendationInput
    journey?: JourneyCreateNestedOneWithoutRecommendationInput
    propertySuggestion?: PropertySuggestionCreateNestedOneWithoutRecommendationInput
  }

  export type RecommendationUncheckedCreateWithoutAreasInput = {
    id?: number
    createdAt?: Date | string
    userId: number
    journeyId?: number | null
    propertySuggestion?: PropertySuggestionUncheckedCreateNestedOneWithoutRecommendationInput
  }

  export type RecommendationCreateOrConnectWithoutAreasInput = {
    where: RecommendationWhereUniqueInput
    create: XOR<RecommendationCreateWithoutAreasInput, RecommendationUncheckedCreateWithoutAreasInput>
  }

  export type RaceEthnicityCreateWithoutAreaInput = {
    white: number
    hispanic: number
    asian: number
    black: number
    other: number
  }

  export type RaceEthnicityUncheckedCreateWithoutAreaInput = {
    id?: number
    white: number
    hispanic: number
    asian: number
    black: number
    other: number
  }

  export type RaceEthnicityCreateOrConnectWithoutAreaInput = {
    where: RaceEthnicityWhereUniqueInput
    create: XOR<RaceEthnicityCreateWithoutAreaInput, RaceEthnicityUncheckedCreateWithoutAreaInput>
  }

  export type IncomeLevelsCreateWithoutAreaInput = {
    perCapitaIncome: number
    medianHouseholdIncome: number
  }

  export type IncomeLevelsUncheckedCreateWithoutAreaInput = {
    id?: number
    perCapitaIncome: number
    medianHouseholdIncome: number
  }

  export type IncomeLevelsCreateOrConnectWithoutAreaInput = {
    where: IncomeLevelsWhereUniqueInput
    create: XOR<IncomeLevelsCreateWithoutAreaInput, IncomeLevelsUncheckedCreateWithoutAreaInput>
  }

  export type CrimeDataCreateWithoutAreaInput = {
    violentCrimes: number
    propertyCrimes: number
    totalCrimes: number
    violentRate: number
    propertyRate: number
    totalRate: number
  }

  export type CrimeDataUncheckedCreateWithoutAreaInput = {
    id?: number
    violentCrimes: number
    propertyCrimes: number
    totalCrimes: number
    violentRate: number
    propertyRate: number
    totalRate: number
  }

  export type CrimeDataCreateOrConnectWithoutAreaInput = {
    where: CrimeDataWhereUniqueInput
    create: XOR<CrimeDataCreateWithoutAreaInput, CrimeDataUncheckedCreateWithoutAreaInput>
  }

  export type SchoolCreateWithoutAreaInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type SchoolUncheckedCreateWithoutAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type SchoolCreateOrConnectWithoutAreaInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAreaInput, SchoolUncheckedCreateWithoutAreaInput>
  }

  export type SchoolCreateManyAreaInputEnvelope = {
    data: SchoolCreateManyAreaInput | SchoolCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type SocialLifeCreateWithoutAreaInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type SocialLifeUncheckedCreateWithoutAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type SocialLifeCreateOrConnectWithoutAreaInput = {
    where: SocialLifeWhereUniqueInput
    create: XOR<SocialLifeCreateWithoutAreaInput, SocialLifeUncheckedCreateWithoutAreaInput>
  }

  export type SocialLifeCreateManyAreaInputEnvelope = {
    data: SocialLifeCreateManyAreaInput | SocialLifeCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type ShoppingCreateWithoutAreaInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type ShoppingUncheckedCreateWithoutAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type ShoppingCreateOrConnectWithoutAreaInput = {
    where: ShoppingWhereUniqueInput
    create: XOR<ShoppingCreateWithoutAreaInput, ShoppingUncheckedCreateWithoutAreaInput>
  }

  export type ShoppingCreateManyAreaInputEnvelope = {
    data: ShoppingCreateManyAreaInput | ShoppingCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type GreenSpaceCreateWithoutAreaInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type GreenSpaceUncheckedCreateWithoutAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type GreenSpaceCreateOrConnectWithoutAreaInput = {
    where: GreenSpaceWhereUniqueInput
    create: XOR<GreenSpaceCreateWithoutAreaInput, GreenSpaceUncheckedCreateWithoutAreaInput>
  }

  export type GreenSpaceCreateManyAreaInputEnvelope = {
    data: GreenSpaceCreateManyAreaInput | GreenSpaceCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type SportCreateWithoutAreaInput = {
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type SportUncheckedCreateWithoutAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type SportCreateOrConnectWithoutAreaInput = {
    where: SportWhereUniqueInput
    create: XOR<SportCreateWithoutAreaInput, SportUncheckedCreateWithoutAreaInput>
  }

  export type SportCreateManyAreaInputEnvelope = {
    data: SportCreateManyAreaInput | SportCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutAreaInput = {
    address: string
    price: string
    description: string
    fullDescription?: string | null
    imageUrls?: PropertyCreateimageUrlsInput | string[]
    type: string
    builtYear: number
    lotSizeSqFt: number
    parkingSpaces: number
    inUnitLaundry: boolean
    district: string
  }

  export type PropertyUncheckedCreateWithoutAreaInput = {
    id?: number
    address: string
    price: string
    description: string
    fullDescription?: string | null
    imageUrls?: PropertyCreateimageUrlsInput | string[]
    type: string
    builtYear: number
    lotSizeSqFt: number
    parkingSpaces: number
    inUnitLaundry: boolean
    district: string
  }

  export type PropertyCreateOrConnectWithoutAreaInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput>
  }

  export type PropertyCreateManyAreaInputEnvelope = {
    data: PropertyCreateManyAreaInput | PropertyCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type RecommendationUpsertWithoutAreasInput = {
    update: XOR<RecommendationUpdateWithoutAreasInput, RecommendationUncheckedUpdateWithoutAreasInput>
    create: XOR<RecommendationCreateWithoutAreasInput, RecommendationUncheckedCreateWithoutAreasInput>
    where?: RecommendationWhereInput
  }

  export type RecommendationUpdateToOneWithWhereWithoutAreasInput = {
    where?: RecommendationWhereInput
    data: XOR<RecommendationUpdateWithoutAreasInput, RecommendationUncheckedUpdateWithoutAreasInput>
  }

  export type RecommendationUpdateWithoutAreasInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecommendationNestedInput
    journey?: JourneyUpdateOneWithoutRecommendationNestedInput
    propertySuggestion?: PropertySuggestionUpdateOneWithoutRecommendationNestedInput
  }

  export type RecommendationUncheckedUpdateWithoutAreasInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyId?: NullableIntFieldUpdateOperationsInput | number | null
    propertySuggestion?: PropertySuggestionUncheckedUpdateOneWithoutRecommendationNestedInput
  }

  export type RaceEthnicityUpsertWithoutAreaInput = {
    update: XOR<RaceEthnicityUpdateWithoutAreaInput, RaceEthnicityUncheckedUpdateWithoutAreaInput>
    create: XOR<RaceEthnicityCreateWithoutAreaInput, RaceEthnicityUncheckedCreateWithoutAreaInput>
    where?: RaceEthnicityWhereInput
  }

  export type RaceEthnicityUpdateToOneWithWhereWithoutAreaInput = {
    where?: RaceEthnicityWhereInput
    data: XOR<RaceEthnicityUpdateWithoutAreaInput, RaceEthnicityUncheckedUpdateWithoutAreaInput>
  }

  export type RaceEthnicityUpdateWithoutAreaInput = {
    white?: FloatFieldUpdateOperationsInput | number
    hispanic?: FloatFieldUpdateOperationsInput | number
    asian?: FloatFieldUpdateOperationsInput | number
    black?: FloatFieldUpdateOperationsInput | number
    other?: FloatFieldUpdateOperationsInput | number
  }

  export type RaceEthnicityUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    white?: FloatFieldUpdateOperationsInput | number
    hispanic?: FloatFieldUpdateOperationsInput | number
    asian?: FloatFieldUpdateOperationsInput | number
    black?: FloatFieldUpdateOperationsInput | number
    other?: FloatFieldUpdateOperationsInput | number
  }

  export type IncomeLevelsUpsertWithoutAreaInput = {
    update: XOR<IncomeLevelsUpdateWithoutAreaInput, IncomeLevelsUncheckedUpdateWithoutAreaInput>
    create: XOR<IncomeLevelsCreateWithoutAreaInput, IncomeLevelsUncheckedCreateWithoutAreaInput>
    where?: IncomeLevelsWhereInput
  }

  export type IncomeLevelsUpdateToOneWithWhereWithoutAreaInput = {
    where?: IncomeLevelsWhereInput
    data: XOR<IncomeLevelsUpdateWithoutAreaInput, IncomeLevelsUncheckedUpdateWithoutAreaInput>
  }

  export type IncomeLevelsUpdateWithoutAreaInput = {
    perCapitaIncome?: FloatFieldUpdateOperationsInput | number
    medianHouseholdIncome?: FloatFieldUpdateOperationsInput | number
  }

  export type IncomeLevelsUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    perCapitaIncome?: FloatFieldUpdateOperationsInput | number
    medianHouseholdIncome?: FloatFieldUpdateOperationsInput | number
  }

  export type CrimeDataUpsertWithoutAreaInput = {
    update: XOR<CrimeDataUpdateWithoutAreaInput, CrimeDataUncheckedUpdateWithoutAreaInput>
    create: XOR<CrimeDataCreateWithoutAreaInput, CrimeDataUncheckedCreateWithoutAreaInput>
    where?: CrimeDataWhereInput
  }

  export type CrimeDataUpdateToOneWithWhereWithoutAreaInput = {
    where?: CrimeDataWhereInput
    data: XOR<CrimeDataUpdateWithoutAreaInput, CrimeDataUncheckedUpdateWithoutAreaInput>
  }

  export type CrimeDataUpdateWithoutAreaInput = {
    violentCrimes?: IntFieldUpdateOperationsInput | number
    propertyCrimes?: IntFieldUpdateOperationsInput | number
    totalCrimes?: IntFieldUpdateOperationsInput | number
    violentRate?: FloatFieldUpdateOperationsInput | number
    propertyRate?: FloatFieldUpdateOperationsInput | number
    totalRate?: FloatFieldUpdateOperationsInput | number
  }

  export type CrimeDataUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    violentCrimes?: IntFieldUpdateOperationsInput | number
    propertyCrimes?: IntFieldUpdateOperationsInput | number
    totalCrimes?: IntFieldUpdateOperationsInput | number
    violentRate?: FloatFieldUpdateOperationsInput | number
    propertyRate?: FloatFieldUpdateOperationsInput | number
    totalRate?: FloatFieldUpdateOperationsInput | number
  }

  export type SchoolUpsertWithWhereUniqueWithoutAreaInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutAreaInput, SchoolUncheckedUpdateWithoutAreaInput>
    create: XOR<SchoolCreateWithoutAreaInput, SchoolUncheckedCreateWithoutAreaInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutAreaInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutAreaInput, SchoolUncheckedUpdateWithoutAreaInput>
  }

  export type SchoolUpdateManyWithWhereWithoutAreaInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutAreaInput>
  }

  export type SchoolScalarWhereInput = {
    AND?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    OR?: SchoolScalarWhereInput[]
    NOT?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    id?: IntFilter<"School"> | number
    name?: StringFilter<"School"> | string
    description?: StringFilter<"School"> | string
    fullDescription?: StringNullableFilter<"School"> | string | null
    imageUrl?: StringNullableFilter<"School"> | string | null
    website?: StringNullableFilter<"School"> | string | null
    areaId?: IntFilter<"School"> | number
  }

  export type SocialLifeUpsertWithWhereUniqueWithoutAreaInput = {
    where: SocialLifeWhereUniqueInput
    update: XOR<SocialLifeUpdateWithoutAreaInput, SocialLifeUncheckedUpdateWithoutAreaInput>
    create: XOR<SocialLifeCreateWithoutAreaInput, SocialLifeUncheckedCreateWithoutAreaInput>
  }

  export type SocialLifeUpdateWithWhereUniqueWithoutAreaInput = {
    where: SocialLifeWhereUniqueInput
    data: XOR<SocialLifeUpdateWithoutAreaInput, SocialLifeUncheckedUpdateWithoutAreaInput>
  }

  export type SocialLifeUpdateManyWithWhereWithoutAreaInput = {
    where: SocialLifeScalarWhereInput
    data: XOR<SocialLifeUpdateManyMutationInput, SocialLifeUncheckedUpdateManyWithoutAreaInput>
  }

  export type SocialLifeScalarWhereInput = {
    AND?: SocialLifeScalarWhereInput | SocialLifeScalarWhereInput[]
    OR?: SocialLifeScalarWhereInput[]
    NOT?: SocialLifeScalarWhereInput | SocialLifeScalarWhereInput[]
    id?: IntFilter<"SocialLife"> | number
    name?: StringFilter<"SocialLife"> | string
    description?: StringFilter<"SocialLife"> | string
    fullDescription?: StringNullableFilter<"SocialLife"> | string | null
    imageUrl?: StringNullableFilter<"SocialLife"> | string | null
    website?: StringNullableFilter<"SocialLife"> | string | null
    areaId?: IntFilter<"SocialLife"> | number
  }

  export type ShoppingUpsertWithWhereUniqueWithoutAreaInput = {
    where: ShoppingWhereUniqueInput
    update: XOR<ShoppingUpdateWithoutAreaInput, ShoppingUncheckedUpdateWithoutAreaInput>
    create: XOR<ShoppingCreateWithoutAreaInput, ShoppingUncheckedCreateWithoutAreaInput>
  }

  export type ShoppingUpdateWithWhereUniqueWithoutAreaInput = {
    where: ShoppingWhereUniqueInput
    data: XOR<ShoppingUpdateWithoutAreaInput, ShoppingUncheckedUpdateWithoutAreaInput>
  }

  export type ShoppingUpdateManyWithWhereWithoutAreaInput = {
    where: ShoppingScalarWhereInput
    data: XOR<ShoppingUpdateManyMutationInput, ShoppingUncheckedUpdateManyWithoutAreaInput>
  }

  export type ShoppingScalarWhereInput = {
    AND?: ShoppingScalarWhereInput | ShoppingScalarWhereInput[]
    OR?: ShoppingScalarWhereInput[]
    NOT?: ShoppingScalarWhereInput | ShoppingScalarWhereInput[]
    id?: IntFilter<"Shopping"> | number
    name?: StringFilter<"Shopping"> | string
    description?: StringFilter<"Shopping"> | string
    fullDescription?: StringNullableFilter<"Shopping"> | string | null
    imageUrl?: StringNullableFilter<"Shopping"> | string | null
    website?: StringNullableFilter<"Shopping"> | string | null
    areaId?: IntFilter<"Shopping"> | number
  }

  export type GreenSpaceUpsertWithWhereUniqueWithoutAreaInput = {
    where: GreenSpaceWhereUniqueInput
    update: XOR<GreenSpaceUpdateWithoutAreaInput, GreenSpaceUncheckedUpdateWithoutAreaInput>
    create: XOR<GreenSpaceCreateWithoutAreaInput, GreenSpaceUncheckedCreateWithoutAreaInput>
  }

  export type GreenSpaceUpdateWithWhereUniqueWithoutAreaInput = {
    where: GreenSpaceWhereUniqueInput
    data: XOR<GreenSpaceUpdateWithoutAreaInput, GreenSpaceUncheckedUpdateWithoutAreaInput>
  }

  export type GreenSpaceUpdateManyWithWhereWithoutAreaInput = {
    where: GreenSpaceScalarWhereInput
    data: XOR<GreenSpaceUpdateManyMutationInput, GreenSpaceUncheckedUpdateManyWithoutAreaInput>
  }

  export type GreenSpaceScalarWhereInput = {
    AND?: GreenSpaceScalarWhereInput | GreenSpaceScalarWhereInput[]
    OR?: GreenSpaceScalarWhereInput[]
    NOT?: GreenSpaceScalarWhereInput | GreenSpaceScalarWhereInput[]
    id?: IntFilter<"GreenSpace"> | number
    name?: StringFilter<"GreenSpace"> | string
    description?: StringFilter<"GreenSpace"> | string
    fullDescription?: StringNullableFilter<"GreenSpace"> | string | null
    imageUrl?: StringNullableFilter<"GreenSpace"> | string | null
    website?: StringNullableFilter<"GreenSpace"> | string | null
    areaId?: IntFilter<"GreenSpace"> | number
  }

  export type SportUpsertWithWhereUniqueWithoutAreaInput = {
    where: SportWhereUniqueInput
    update: XOR<SportUpdateWithoutAreaInput, SportUncheckedUpdateWithoutAreaInput>
    create: XOR<SportCreateWithoutAreaInput, SportUncheckedCreateWithoutAreaInput>
  }

  export type SportUpdateWithWhereUniqueWithoutAreaInput = {
    where: SportWhereUniqueInput
    data: XOR<SportUpdateWithoutAreaInput, SportUncheckedUpdateWithoutAreaInput>
  }

  export type SportUpdateManyWithWhereWithoutAreaInput = {
    where: SportScalarWhereInput
    data: XOR<SportUpdateManyMutationInput, SportUncheckedUpdateManyWithoutAreaInput>
  }

  export type SportScalarWhereInput = {
    AND?: SportScalarWhereInput | SportScalarWhereInput[]
    OR?: SportScalarWhereInput[]
    NOT?: SportScalarWhereInput | SportScalarWhereInput[]
    id?: IntFilter<"Sport"> | number
    name?: StringFilter<"Sport"> | string
    description?: StringFilter<"Sport"> | string
    fullDescription?: StringNullableFilter<"Sport"> | string | null
    imageUrl?: StringNullableFilter<"Sport"> | string | null
    website?: StringNullableFilter<"Sport"> | string | null
    areaId?: IntFilter<"Sport"> | number
  }

  export type PropertyUpsertWithWhereUniqueWithoutAreaInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutAreaInput, PropertyUncheckedUpdateWithoutAreaInput>
    create: XOR<PropertyCreateWithoutAreaInput, PropertyUncheckedCreateWithoutAreaInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutAreaInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutAreaInput, PropertyUncheckedUpdateWithoutAreaInput>
  }

  export type PropertyUpdateManyWithWhereWithoutAreaInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutAreaInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: IntFilter<"Property"> | number
    address?: StringFilter<"Property"> | string
    price?: StringFilter<"Property"> | string
    description?: StringFilter<"Property"> | string
    fullDescription?: StringNullableFilter<"Property"> | string | null
    imageUrls?: StringNullableListFilter<"Property">
    type?: StringFilter<"Property"> | string
    builtYear?: IntFilter<"Property"> | number
    lotSizeSqFt?: IntFilter<"Property"> | number
    parkingSpaces?: IntFilter<"Property"> | number
    inUnitLaundry?: BoolFilter<"Property"> | boolean
    district?: StringFilter<"Property"> | string
    areaId?: IntFilter<"Property"> | number
  }

  export type RecommendedAreaCreateWithoutRaceEthnicityInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutRaceEthnicityInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutRaceEthnicityInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutRaceEthnicityInput, RecommendedAreaUncheckedCreateWithoutRaceEthnicityInput>
  }

  export type RecommendedAreaUpsertWithoutRaceEthnicityInput = {
    update: XOR<RecommendedAreaUpdateWithoutRaceEthnicityInput, RecommendedAreaUncheckedUpdateWithoutRaceEthnicityInput>
    create: XOR<RecommendedAreaCreateWithoutRaceEthnicityInput, RecommendedAreaUncheckedCreateWithoutRaceEthnicityInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutRaceEthnicityInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutRaceEthnicityInput, RecommendedAreaUncheckedUpdateWithoutRaceEthnicityInput>
  }

  export type RecommendedAreaUpdateWithoutRaceEthnicityInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutRaceEthnicityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateWithoutIncomeLevelsInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutIncomeLevelsInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutIncomeLevelsInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutIncomeLevelsInput, RecommendedAreaUncheckedCreateWithoutIncomeLevelsInput>
  }

  export type RecommendedAreaUpsertWithoutIncomeLevelsInput = {
    update: XOR<RecommendedAreaUpdateWithoutIncomeLevelsInput, RecommendedAreaUncheckedUpdateWithoutIncomeLevelsInput>
    create: XOR<RecommendedAreaCreateWithoutIncomeLevelsInput, RecommendedAreaUncheckedCreateWithoutIncomeLevelsInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutIncomeLevelsInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutIncomeLevelsInput, RecommendedAreaUncheckedUpdateWithoutIncomeLevelsInput>
  }

  export type RecommendedAreaUpdateWithoutIncomeLevelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutIncomeLevelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateWithoutCrimeDataInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutCrimeDataInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutCrimeDataInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutCrimeDataInput, RecommendedAreaUncheckedCreateWithoutCrimeDataInput>
  }

  export type RecommendedAreaUpsertWithoutCrimeDataInput = {
    update: XOR<RecommendedAreaUpdateWithoutCrimeDataInput, RecommendedAreaUncheckedUpdateWithoutCrimeDataInput>
    create: XOR<RecommendedAreaCreateWithoutCrimeDataInput, RecommendedAreaUncheckedCreateWithoutCrimeDataInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutCrimeDataInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutCrimeDataInput, RecommendedAreaUncheckedUpdateWithoutCrimeDataInput>
  }

  export type RecommendedAreaUpdateWithoutCrimeDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutCrimeDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateWithoutSchoolsInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutSchoolsInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutSchoolsInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutSchoolsInput, RecommendedAreaUncheckedCreateWithoutSchoolsInput>
  }

  export type RecommendedAreaUpsertWithoutSchoolsInput = {
    update: XOR<RecommendedAreaUpdateWithoutSchoolsInput, RecommendedAreaUncheckedUpdateWithoutSchoolsInput>
    create: XOR<RecommendedAreaCreateWithoutSchoolsInput, RecommendedAreaUncheckedCreateWithoutSchoolsInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutSchoolsInput, RecommendedAreaUncheckedUpdateWithoutSchoolsInput>
  }

  export type RecommendedAreaUpdateWithoutSchoolsInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutSchoolsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateWithoutSocialLifeInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutSocialLifeInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutSocialLifeInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutSocialLifeInput, RecommendedAreaUncheckedCreateWithoutSocialLifeInput>
  }

  export type RecommendedAreaUpsertWithoutSocialLifeInput = {
    update: XOR<RecommendedAreaUpdateWithoutSocialLifeInput, RecommendedAreaUncheckedUpdateWithoutSocialLifeInput>
    create: XOR<RecommendedAreaCreateWithoutSocialLifeInput, RecommendedAreaUncheckedCreateWithoutSocialLifeInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutSocialLifeInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutSocialLifeInput, RecommendedAreaUncheckedUpdateWithoutSocialLifeInput>
  }

  export type RecommendedAreaUpdateWithoutSocialLifeInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutSocialLifeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateWithoutShoppingInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutShoppingInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutShoppingInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutShoppingInput, RecommendedAreaUncheckedCreateWithoutShoppingInput>
  }

  export type RecommendedAreaUpsertWithoutShoppingInput = {
    update: XOR<RecommendedAreaUpdateWithoutShoppingInput, RecommendedAreaUncheckedUpdateWithoutShoppingInput>
    create: XOR<RecommendedAreaCreateWithoutShoppingInput, RecommendedAreaUncheckedCreateWithoutShoppingInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutShoppingInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutShoppingInput, RecommendedAreaUncheckedUpdateWithoutShoppingInput>
  }

  export type RecommendedAreaUpdateWithoutShoppingInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutShoppingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateWithoutGreenSpacesInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutGreenSpacesInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutGreenSpacesInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutGreenSpacesInput, RecommendedAreaUncheckedCreateWithoutGreenSpacesInput>
  }

  export type RecommendedAreaUpsertWithoutGreenSpacesInput = {
    update: XOR<RecommendedAreaUpdateWithoutGreenSpacesInput, RecommendedAreaUncheckedUpdateWithoutGreenSpacesInput>
    create: XOR<RecommendedAreaCreateWithoutGreenSpacesInput, RecommendedAreaUncheckedCreateWithoutGreenSpacesInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutGreenSpacesInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutGreenSpacesInput, RecommendedAreaUncheckedUpdateWithoutGreenSpacesInput>
  }

  export type RecommendedAreaUpdateWithoutGreenSpacesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutGreenSpacesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateWithoutSportsInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    properties?: PropertyCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutSportsInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    properties?: PropertyUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutSportsInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutSportsInput, RecommendedAreaUncheckedCreateWithoutSportsInput>
  }

  export type RecommendedAreaUpsertWithoutSportsInput = {
    update: XOR<RecommendedAreaUpdateWithoutSportsInput, RecommendedAreaUncheckedUpdateWithoutSportsInput>
    create: XOR<RecommendedAreaCreateWithoutSportsInput, RecommendedAreaUncheckedCreateWithoutSportsInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutSportsInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutSportsInput, RecommendedAreaUncheckedUpdateWithoutSportsInput>
  }

  export type RecommendedAreaUpdateWithoutSportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutSportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaCreateWithoutPropertiesInput = {
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    recommendation: RecommendationCreateNestedOneWithoutAreasInput
    raceEthnicity?: RaceEthnicityCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataCreateNestedOneWithoutAreaInput
    schools?: SchoolCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeCreateNestedManyWithoutAreaInput
    shopping?: ShoppingCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceCreateNestedManyWithoutAreaInput
    sports?: SportCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaUncheckedCreateWithoutPropertiesInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    recommendationId: number
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedCreateNestedOneWithoutAreaInput
    incomeLevels?: IncomeLevelsUncheckedCreateNestedOneWithoutAreaInput
    crimeData?: CrimeDataUncheckedCreateNestedOneWithoutAreaInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAreaInput
    socialLife?: SocialLifeUncheckedCreateNestedManyWithoutAreaInput
    shopping?: ShoppingUncheckedCreateNestedManyWithoutAreaInput
    greenSpaces?: GreenSpaceUncheckedCreateNestedManyWithoutAreaInput
    sports?: SportUncheckedCreateNestedManyWithoutAreaInput
  }

  export type RecommendedAreaCreateOrConnectWithoutPropertiesInput = {
    where: RecommendedAreaWhereUniqueInput
    create: XOR<RecommendedAreaCreateWithoutPropertiesInput, RecommendedAreaUncheckedCreateWithoutPropertiesInput>
  }

  export type RecommendedAreaUpsertWithoutPropertiesInput = {
    update: XOR<RecommendedAreaUpdateWithoutPropertiesInput, RecommendedAreaUncheckedUpdateWithoutPropertiesInput>
    create: XOR<RecommendedAreaCreateWithoutPropertiesInput, RecommendedAreaUncheckedCreateWithoutPropertiesInput>
    where?: RecommendedAreaWhereInput
  }

  export type RecommendedAreaUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: RecommendedAreaWhereInput
    data: XOR<RecommendedAreaUpdateWithoutPropertiesInput, RecommendedAreaUncheckedUpdateWithoutPropertiesInput>
  }

  export type RecommendedAreaUpdateWithoutPropertiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    recommendation?: RecommendationUpdateOneRequiredWithoutAreasNestedInput
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    recommendationId?: IntFieldUpdateOperationsInput | number
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendationCreateWithoutPropertySuggestionInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRecommendationInput
    journey?: JourneyCreateNestedOneWithoutRecommendationInput
    areas?: RecommendedAreaCreateNestedManyWithoutRecommendationInput
  }

  export type RecommendationUncheckedCreateWithoutPropertySuggestionInput = {
    id?: number
    createdAt?: Date | string
    userId: number
    journeyId?: number | null
    areas?: RecommendedAreaUncheckedCreateNestedManyWithoutRecommendationInput
  }

  export type RecommendationCreateOrConnectWithoutPropertySuggestionInput = {
    where: RecommendationWhereUniqueInput
    create: XOR<RecommendationCreateWithoutPropertySuggestionInput, RecommendationUncheckedCreateWithoutPropertySuggestionInput>
  }

  export type RecommendationUpsertWithoutPropertySuggestionInput = {
    update: XOR<RecommendationUpdateWithoutPropertySuggestionInput, RecommendationUncheckedUpdateWithoutPropertySuggestionInput>
    create: XOR<RecommendationCreateWithoutPropertySuggestionInput, RecommendationUncheckedCreateWithoutPropertySuggestionInput>
    where?: RecommendationWhereInput
  }

  export type RecommendationUpdateToOneWithWhereWithoutPropertySuggestionInput = {
    where?: RecommendationWhereInput
    data: XOR<RecommendationUpdateWithoutPropertySuggestionInput, RecommendationUncheckedUpdateWithoutPropertySuggestionInput>
  }

  export type RecommendationUpdateWithoutPropertySuggestionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecommendationNestedInput
    journey?: JourneyUpdateOneWithoutRecommendationNestedInput
    areas?: RecommendedAreaUpdateManyWithoutRecommendationNestedInput
  }

  export type RecommendationUncheckedUpdateWithoutPropertySuggestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyId?: NullableIntFieldUpdateOperationsInput | number | null
    areas?: RecommendedAreaUncheckedUpdateManyWithoutRecommendationNestedInput
  }

  export type OtpCodeCreateManyUserInput = {
    id?: number
    code: string
    phone: string
    email: string
    countryCode: string
    expiresAt: Date | string
    createdAt?: Date | string
    attempts?: number
  }

  export type RecommendationCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    journeyId?: number | null
  }

  export type JourneyCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.JourneyStatus
    label?: string | null
    selectedState?: string | null
    selectedCities?: JourneyCreateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: number
  }

  export type OtpCodeUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type OtpCodeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type OtpCodeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: IntFieldUpdateOperationsInput | number
  }

  export type RecommendationUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journey?: JourneyUpdateOneWithoutRecommendationNestedInput
    propertySuggestion?: PropertySuggestionUpdateOneWithoutRecommendationNestedInput
    areas?: RecommendedAreaUpdateManyWithoutRecommendationNestedInput
  }

  export type RecommendationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeyId?: NullableIntFieldUpdateOperationsInput | number | null
    propertySuggestion?: PropertySuggestionUncheckedUpdateOneWithoutRecommendationNestedInput
    areas?: RecommendedAreaUncheckedUpdateManyWithoutRecommendationNestedInput
  }

  export type RecommendationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JourneyUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
    recommendation?: RecommendationUpdateOneWithoutJourneyNestedInput
  }

  export type JourneyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
    recommendation?: RecommendationUncheckedUpdateOneWithoutJourneyNestedInput
  }

  export type JourneyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumJourneyStatusFieldUpdateOperationsInput | $Enums.JourneyStatus
    label?: NullableStringFieldUpdateOperationsInput | string | null
    selectedState?: NullableStringFieldUpdateOperationsInput | string | null
    selectedCities?: JourneyUpdateselectedCitiesInput | string[]
    inputs?: NullableJsonNullValueInput | InputJsonValue
    index?: IntFieldUpdateOperationsInput | number
  }

  export type RecommendedAreaCreateManyRecommendationInput = {
    id?: number
    name: string
    state: string
    reason: string
    imageUrl?: string | null
    fullDescription?: string | null
    placesOfInterest?: RecommendedAreaCreateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaCreatelifestyleTagsInput | string[]
  }

  export type RecommendedAreaUpdateWithoutRecommendationInput = {
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUpdateOneWithoutAreaNestedInput
    schools?: SchoolUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUpdateManyWithoutAreaNestedInput
    sports?: SportUpdateManyWithoutAreaNestedInput
    properties?: PropertyUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateWithoutRecommendationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
    raceEthnicity?: RaceEthnicityUncheckedUpdateOneWithoutAreaNestedInput
    incomeLevels?: IncomeLevelsUncheckedUpdateOneWithoutAreaNestedInput
    crimeData?: CrimeDataUncheckedUpdateOneWithoutAreaNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAreaNestedInput
    socialLife?: SocialLifeUncheckedUpdateManyWithoutAreaNestedInput
    shopping?: ShoppingUncheckedUpdateManyWithoutAreaNestedInput
    greenSpaces?: GreenSpaceUncheckedUpdateManyWithoutAreaNestedInput
    sports?: SportUncheckedUpdateManyWithoutAreaNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type RecommendedAreaUncheckedUpdateManyWithoutRecommendationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    placesOfInterest?: RecommendedAreaUpdateplacesOfInterestInput | string[]
    lifestyleTags?: RecommendedAreaUpdatelifestyleTagsInput | string[]
  }

  export type SchoolCreateManyAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type SocialLifeCreateManyAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type ShoppingCreateManyAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type GreenSpaceCreateManyAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type SportCreateManyAreaInput = {
    id?: number
    name: string
    description: string
    fullDescription?: string | null
    imageUrl?: string | null
    website?: string | null
  }

  export type PropertyCreateManyAreaInput = {
    id?: number
    address: string
    price: string
    description: string
    fullDescription?: string | null
    imageUrls?: PropertyCreateimageUrlsInput | string[]
    type: string
    builtYear: number
    lotSizeSqFt: number
    parkingSpaces: number
    inUnitLaundry: boolean
    district: string
  }

  export type SchoolUpdateWithoutAreaInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLifeUpdateWithoutAreaInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLifeUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLifeUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoppingUpdateWithoutAreaInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoppingUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoppingUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GreenSpaceUpdateWithoutAreaInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GreenSpaceUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GreenSpaceUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SportUpdateWithoutAreaInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SportUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SportUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyUpdateWithoutAreaInput = {
    address?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: PropertyUpdateimageUrlsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    builtYear?: IntFieldUpdateOperationsInput | number
    lotSizeSqFt?: IntFieldUpdateOperationsInput | number
    parkingSpaces?: IntFieldUpdateOperationsInput | number
    inUnitLaundry?: BoolFieldUpdateOperationsInput | boolean
    district?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: PropertyUpdateimageUrlsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    builtYear?: IntFieldUpdateOperationsInput | number
    lotSizeSqFt?: IntFieldUpdateOperationsInput | number
    parkingSpaces?: IntFieldUpdateOperationsInput | number
    inUnitLaundry?: BoolFieldUpdateOperationsInput | boolean
    district?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: PropertyUpdateimageUrlsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    builtYear?: IntFieldUpdateOperationsInput | number
    lotSizeSqFt?: IntFieldUpdateOperationsInput | number
    parkingSpaces?: IntFieldUpdateOperationsInput | number
    inUnitLaundry?: BoolFieldUpdateOperationsInput | boolean
    district?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}